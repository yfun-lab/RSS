[{"title":"你每天用的中文有个节日，如何输入这件事也有些门道","date":"2023-04-20 08:00:00","description":"谷雨偕汉字，键落呈中文。<a href=\"https://sspai.com/post/79385\" target=\"_blank\">查看全文</a>\n","link":"https://sspai.com/post/79385"},{"title":"旅行拍照虽然开心，但别忘了清洁相机","date":"2023-04-20 06:55:35","description":"希望你能在假期里玩得尽兴，拍出大片。<a href=\"https://sspai.com/post/68863\" target=\"_blank\">查看全文</a>\n","link":"https://sspai.com/post/68863"},{"title":"零碎的卡片笔记谁最擅长整理输出？flomo、Seeds 和 Writeathon 对比","date":"2023-04-20 03:34:00","description":"有时候人就是这样，如果没见过某些功能，可能永远也不会认为需要它们，而无论是已有的多端同步、双向链接，还是新发现的白板和卡片写作，都是「一旦见过，就想一直拥有」的好功能。<a href=\"https://sspai.com/post/79373\" target=\"_blank\">查看全文</a>\n","link":"https://sspai.com/post/79373"},{"title":"派早报：HomePod 系列支持声音识别、索尼上调游戏价格等","date":"2023-04-20 00:43:26","description":"网易游戏发布五一劳动节假期未成年人限玩通知、Reddit 计划向公司收取访问其 API 的费用等。<a href=\"https://sspai.com/post/79383\" target=\"_blank\">查看全文</a>\n","link":"https://sspai.com/post/79383"},{"title":"为工程师而生的 Linear，为何也是设计师的灵感源泉","date":"2023-04-19 09:43:15","description":"Linear 设计风格在大面积暗色背景下，工程师是如何巧妙营造其独特又神秘的锋利质感的，而这些元素又是如何成为设计师的灵感源泉的？这篇文章帮你一起来梳理 Linear 设计风格。<a href=\"https://sspai.com/post/79347\" target=\"_blank\">查看全文</a>\n","link":"https://sspai.com/post/79347"},{"title":"用 10 万条微信聊天记录和 280 篇博客文章，我克隆了一个数字版自己","date":"2023-04-19 06:21:53","description":"Matrix精选Matrix是少数派的写作社区，我们主张分享真实的产品体验，有实用价值的经验与思考。我们会不定期挑选Matrix最优质的文章，展示来自用户的最真实的体验和观点。文章代表作者个人观点，少 ...<a href=\"https://sspai.com/post/79230\" target=\"_blank\">查看全文</a>\n","link":"https://sspai.com/post/79230"},{"title":"也许是最适合普通人的 Pro 设备：PICO 4 Pro 上手体验","date":"2023-04-19 03:30:00","description":"近几年，目之所及的几乎所有品牌都开始推出Pro产品。然而正如Pro的全称Professional那样，这些设备大多都是面向专业用户推出的设备。对于普通人来说，很多Pro的设备或许都存在着性能过剩、零件 ...<a href=\"https://sspai.com/post/79364\" target=\"_blank\">查看全文</a>\n","link":"https://sspai.com/post/79364"},{"title":"派早报：小米 13 Ultra 发布、蔚来推出 ES6 纯电中型 SUV 等","date":"2023-04-19 00:46:51","description":"蔚来推出 ES6 纯电中型 SUV，Apple Pay 上线「绿色出行」主题快捷交通卡卡面等。<a href=\"https://sspai.com/post/79369\" target=\"_blank\">查看全文</a>\n","link":"https://sspai.com/post/79369"},{"title":"Discogs——见证二手唱片的繁荣、失落与复兴","date":"2023-04-18 11:43:47","description":"本章节中，我们来谈谈全球最大、最重要的二手唱片在线交易市场——Discogs。<a href=\"https://sspai.com/prime/story/music-database-discogs\" target=\"_blank\">查看全文</a><p>本文为会员文章，出自<a href=\"https://sspai.com/prime/precog/sp-02-music-database\" target=\"_blank\">《隐秘的巨人：谈谈音乐数据库》</a>，订阅后可阅读全文。</p>\n","link":"https://sspai.com/prime/story/music-database-discogs"},{"title":"从「会背」单词到「会用」单词，这些工具与方法帮得上忙","date":"2023-04-18 09:32:02","description":"本文探讨使用可导出 csv 的词典、Anki、写作辅助工具协同，提升自己外语学习效率的方法。<a href=\"https://sspai.com/post/79241\" target=\"_blank\">查看全文</a>\n","link":"https://sspai.com/post/79241"},{"title":"快使用 Dprint 换掉你的 Prettier 罢（迫切","date":"2023-04-07 05:23:52","description":"\n<h1>前言：什么是代码格式化工具？</h1>\n<p>在写代码的时候，我们有时候会写出来这些丑陋的代码，没有分号，没有换行，奇怪的缩进和空格，不统一的引号：</p>\n<pre><code class=\"language-ts\">// 手动造的（\nconst a=1;let b= 114514,c='1',d=\"homo\"\nfunction\n    a\n    (\n\n    ){}\ntype A={ a:string}\n</code></pre>\n<p>可恶，太丑陋力！如果没有代码格式化工具，我们就必须一个一个一个修改，而且还没办法做到全部人员写的代码风格都统一。 如果我们使用了代码格式化工具（这里使用 <a href=\"https://github.com/dprint/dprint\">Dprint</a>），它会自动将以上代码格式化为：</p>\n<pre><code class=\"language-ts\">// 手动造的（\nconst a = 1;\nlet b = 114514, c = \"1\", d = \"homo\";\nfunction a() {}\ntype A = { a: string };\n</code></pre>\n<p>是不是好看多了？自动加上了分号，统一了引号，空格也适当地添加了。（<del>代码写得好看的有奖励，写的难看的有惩罚</del>）<br>\n这就是代码格式化工具的作用：将代码统一为一致的格式。</p>\n<h1>Why not Prettier？</h1>\n<p>如果你曾经做过 JS 开发，那么你或许对 Prettier 有所耳闻。Prettier 在其官网将自己称为“一个固执己见的代码格式化工具”（An opinionated code formatter），同时“拥有极少配置项”（Has few options）。这也使得其开箱即用，不必要为配置而烦恼——它会自动统一你的代码风格（而且默认的并不丑！），可以说是<code>ni prettier</code>，<code>nlx prettier --write .</code> 就能用。</p>\n<p>那么，为什么这篇文章不向你推荐 Prettier 而要用 <del>不知名</del> Dprint？原因有下：</p>\n<ol>\n<li>\n<p>Prettier 的配置项很少。前面提到了，它是一个“固执己见”的代码格式化工具，也就意味着它并不能让你自定义代码风格。比如有些人喜欢把等号对齐到一行，不喜欢在花括号前面加空格（虽然我本人对这种风格不感冒），Prettier 就没法做到这一点。一些示例：</p>\n<pre><code class=\"language-ts\">function foo () {} // 这里，括号前面带有空格\nfunction bar&lt;T&gt;() {} // 泛型函数没有\n</code></pre>\n<p>这是我个人比较喜欢的一种码风，Prettier 却并不支持它。而且你也无法申请添加这一功能，因为 Prettier <a href=\"https://prettier.io/docs/en/option-philosophy.html\">不再添加新的配置项</a>。</p>\n</li>\n<li>\n<p>速度慢。虽然说 Prettier 相比 ESLint 快了不止一个量级（我知道 ESLint 不是一个专门的格式化工具），但是面对大型代码库时，Prettier 仍然需要数秒时间来解析代码然后格式化。这是脚本语言本身的限制，指不定 Node 在解析 Prettier 代码的时候原生语言写的工具都格式化完了（指Dprint</p>\n</li>\n</ol>\n<p>出于以上几点，我选择转投 Dprint 的怀抱（</p>\n<h1>Dprint</h1>\n<blockquote>\n<p>注意，Dprint 目前尚未达到 1.0 稳定版，但是 Bug 不多，可以试着用</p>\n<p>反正我的 <a href=\"https://github.com/so1ve/eslint-config\">eslint-config</a> 用的 Dprint 来格式化</p>\n</blockquote>\n<p><a href=\"https://github.com/dprint/dprint\">Dprint</a> 对自己的描述是“Rust 写的插件化、可配置的代码格式化<strong>平台</strong>”（<del>虽然我看不懂这个平台<code>platform</code>是什么意思，但是 nb 就对了</del>），注意奥，Rust 写的，那基本上就意味着高性能（）同时，它使用多线程进行格式化，可配置化也是其一大亮点，像是上面提到的括号前加空格就可以实现。</p>\n<h2>Talk is cheap, show me the code</h2>\n<p>没有使用方法的介绍文章都是耍流氓，上代码（这里使用 <a href=\"https://github.com/antfu/ni\">@antfu/ni</a> 进行依赖安装)：</p>\n<pre><code class=\"language-bash\">$ ni dprint\n</code></pre>\n<p>随后：</p>\n<pre><code class=\"language-bash\">$ nlx dprint help\n</code></pre>\n<p>看到输出帮助信息就说明安装成功了。</p>\n<p>然后初始化：</p>\n<pre><code class=\"language-bash\">$ nlx dprint init\n</code></pre>\n<p>选择需要装的插件按回车（这里装了 <code>typescript</code> <code>json</code> <code>markdown</code> <code>toml</code> 插件），应该会在当前目录生成一个 <code>dprint.json</code>：</p>\n<pre><code class=\"language-json\">{\n  \"typescript\": {\n  },\n  \"json\": {\n  },\n  \"markdown\": {\n  },\n  \"toml\": {\n  },\n  \"includes\": [\"**/*.{ts,tsx,js,jsx,cjs,mjs,json,md,toml}\"],\n  \"excludes\": [\n    \"**/node_modules\",\n    \"**/*-lock.json\"\n  ],\n  \"plugins\": [\n    \"https://plugins.dprint.dev/typescript-0.84.1.wasm\",\n    \"https://plugins.dprint.dev/json-0.17.1.wasm\",\n    \"https://plugins.dprint.dev/markdown-0.15.2.wasm\",\n    \"https://plugins.dprint.dev/toml-0.5.4.wasm\"\n  ]\n}\n\n</code></pre>\n<p>或者你也可以自己指定：</p>\n<pre><code class=\"language-bash\">$ nlx dprint init --config .dprint.json\n</code></pre>\n<p>此时运行 <code>nlx dprint check</code> 就能够检测代码中存在的格式问题， <code>nlx dprint fmt</code> 就能自动格式化！</p>\n<p>可以看到安装步骤也是非常简单（）</p>\n<h2>配置</h2>\n<p>配置这里不多说，需要自定义请自行查看官网：<a href=\"https://dprint.dev/config\">https://dprint.dev/config</a></p>\n<h2>与编辑器集成</h2>\n<p>如果不按照编辑器插件，你每次写代码都必须要手动进行格式化，挺烦人的。如果装了编辑器插件，就可以在保存 / 输入时自动格式化！</p>\n<p>打开你的用户设置 <code>settings.json</code>（不会打开的自己看文档），加入如下内容：</p>\n<pre><code class=\"language-json\">{\n  \"editor.defaultFormatter\": \"dprint.dprint\",\n  \"editor.formatOnSave\": true\n}\n</code></pre>\n<p>或者如果你只想让 JS 使用 Dprint （TS 同理）：</p>\n<pre><code class=\"language-json\">{\n  \"[javascript]\": {\n    \"editor.defaultFormatter\": \"dprint.dprint\",\n    \"editor.formatOnSave\": true\n  }\n}\n</code></pre>\n<p>注意，以上配置只适用于 <code>全局安装的 Dprint</code> 。如果是在项目中装的 Dprint，请在工作区配置中添加：</p>\n<pre><code class=\"language-json\">{\n  \"dprint.path\": \"./node_modules/dprint/dprint.exe\"\n}\n</code></pre>\n<p>可以看到，上面这种方式是比较麻烦的。而且，它没法显示格式化更改了那些地方，没有 Diff，看着可难受了。有没有什么更好的办法呢？</p>\n<p>有！如果你用了 ESLint，请看下一部分！</p>\n<h2>与 ESLint 集成</h2>\n<p>Prettier 有一个插件可以让 Prettier 作为一个 ESLint 规则来运行，它叫 <a href=\"https://github.com/prettier/eslint-plugin-prettier\">eslint-plugin-prettier</a>。我也做了个类似的插件，<a href=\"https://github.com/so1ve/eslint-plugin-dprint-integration\">eslint-plugin-dprint-integration</a> （eslint-plugin-dprint 被人抢了），内置了 <code>typescript</code> <code>json</code> <code>markdown</code> <code>toml</code> <code>dockerfile</code> 的格式化，以及 Vue 的 Script 部分。（以后会支持 CSS）。使用方法很简单：</p>\n<pre><code class=\"language-bash\">$ ni eslint-plugin-dprint-integration -D\n</code></pre>\n<p>随后，在你的 ESLint 配置文件（这里是 <code>.eslintrc.cjs</code>）中添加：</p>\n<pre><code class=\"language-js\">module.exports = {\n  extends: [\n    \"plugin:dprint-integration/recommended\",\n    // 关闭冲突 ESLint 规则\n    \"plugin:dprint-integration/disable-conflict\",\n  ]\n};\n</code></pre>\n<p>齐活！打开你的 VSCode，装上 ESLint 插件，可以看到格式化的修改都可视化了:P</p>\n","link":"https://blog.mk1.io/posts/introduce-dprint"},{"title":"JSEW —— 类似于 jsDelivr 的静态资源加速","date":"2023-01-29 07:30:00","description":"\n<p>现在网络上大部分公益项目都为 jsDelivr 提供镜像加速，此时用户的资源文件必须从源服务器经 jsDelivr 再绕过公益服务才能回到用户手上。本身 jsDelivr 也回源 GitHub 和 NPM，那么为什么不从源拉起？</p>\n<p>那好，那就从源拉起。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%9F%9F%E5%90%8D\" class=\"headerlink\" title=\"域名\"></a>域名</h2>\n<p>目前，JSEW 的域名已经开启中国大陆境内和境外双 CDN 加速，为用户提供快速的服务。</p>\n<p>使用 <code>s.cky.qystu.cc</code> 替换 <code>fastly.jsdelivr.net</code>, <code>cdn.jsdelivr.net</code> 作为加速域名，遵循中国大陆相关地区的法律法规。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E7%AB%AF%E7%82%B9\" class=\"headerlink\" title=\"端点\"></a>端点</h2>\n<blockquote><p>目前仅支持使用 <code>/gh</code> 和 <code>npm</code>，并且自动开启 HTTPS 访问与 Gzip 压缩。</p></blockquote>\n<h3>\n<a href=\"https://blog.yfun.top/#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h3>\n<p>GitHub 文件来源于 <code>raw.githubusercontent.com</code>，将自动转换路径，API 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/gh/[USER_NAME]/[REPO_NAME]@[BRANCH_NAME]/[FILE]</span><br></pre></td></tr></table></figure><p>请求链接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://s.cky.qystu.cc/gh/detalkjs/client@master/dist/detalk.js</span><br></pre></td></tr></table></figure><p>需要注意的是，部分 CDN 的缓存时间会比较长，如果是仓库 <code>master</code> 等变动较快的分支不建议使用。如果你需要实时获取最新的 Commit，那么请在请求 URL 后追加 <code>!latest</code>，这样 JSEW 会自动 307 跳转至最新的 Commit Tag.</p>\n<p>同时，如果没有指定分支名，则会自动默认为 <code>master</code>。</p>\n<h3>\n<a href=\"https://blog.yfun.top/#NPM\" class=\"headerlink\" title=\"NPM\"></a>NPM</h3>\n<p>NPM 文件来源于 <code>www.npmjs.com</code>，将自动转换路径并获取文件 Hex，API 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/npm/[PACKAGE_NAME]@[VERSION]/[FILE]</span><br></pre></td></tr></table></figure><p>请求链接例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://s.cky.qystu.cc/npm/@detalk/static@1.3.2/dist/detalk.js</span><br></pre></td></tr></table></figure><p>如果当版本号为 <code>@latest</code> 时，为了避免缓存问题，将会自动 307 跳转至最新的版本号。</p>\n<p>如果版本号为 <code>@1</code> 等只包含 <code>major</code> 或 <code>minor</code> 的形式时，将会自动 307 跳转至最新的以指定版本号为限制条件的完整版本号。</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://s.cky.qystu.cc/npm/@detalk/static@1/dist/detalk.js</span><br><span class=\"line\">Redirect to =&gt;</span><br><span class=\"line\">https://s.cky.qystu.cc/npm/@detalk/static@1.3.2/dist/detalk.js</span><br></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://s.cky.qystu.cc/npm/@detalk/static@1.2/dist/detalk.js</span><br><span class=\"line\">Redirect to =&gt;</span><br><span class=\"line\">https://s.cky.qystu.cc/npm/@detalk/static@1.2.1/dist/detalk.js</span><br></pre></td></tr></table></figure><p>为了避免潜在问题，<strong>即使不指定版本号，也必须指定 <code>@latest</code>，否则无法访问。</strong></p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E8%87%AA%E5%8A%A8%E5%8E%8B%E7%BC%A9\" class=\"headerlink\" title=\"自动压缩\"></a>自动压缩</h2>\n<p>除 Gzip 压缩外，目前 CKY#JSEW 还兼容部分文件的自动压缩功能。</p>\n<p>例如，请求 <code>main.min.js</code> 文件，而目录下无对应文件，只有 <code>main.js</code>，那么则会自动获取 <code>main.js</code> 并进行压缩返回。</p>\n<p>此功能目前适用于 CSS 与 JavaScript，只有在请求文件为 <code>.min.js</code> 或 <code>.min.css</code> 且对应文件不存在时可用。</p>\n<p>感谢您对公益服务的支持！</p>\n","link":"https://blog.yfun.top/posts/2023/jsew/"},{"title":"chi的小红包冒险 v.e.r. 2023","date":"2023-01-20 14:21:36","description":"\n<p>之前看到好多大佬都有在新年发红包的好习惯（x），可惜Ray穷穷又没有zfb没办法发红包（恼</p>\n<p>于是就只能白嫖大佬们的力（</p>\n<p>今年<a href=\"https://blog.chihuo2104.dev/posts/rb-2023\">chihuo2104</a>也做了一个小冒险<del>并且让我发小软文推广</del>，那么大家一起来玩罢（</p>\n<p>以下为原文：</p>\n<p>太可惜了！去年因为没有钱钱，所以红包活动就暂停力</p>\n<p>今年红包活动正常进行！！！</p>\n<p>活动时间：<strong>2023.1.21 10:00 - 2023.1.22 10:00</strong></p>\n<p>支付宝红包会在1.21 10:00准时发出，有24小时的时限的~~，所以抓紧速度哦~~</p>\n<p><del>小提示：一共有三个quiz，有一些是受到<a href=\"https://hack.lug.ustc.edu.cn/\">Hackergame 2022</a>的启发设计的题目qwq</del></p>\n<p>活动网页：<a href=\"https://rb.chihuo2104.dev/\">https://rb.chihuo2104.dev/</a></p>\n<p>做出来的可以在本页评论（x</p>\n<p><del>那时候chiblog的评论肯定能修好(立flag)(x</del></p>\n","link":"https://blog.mk1.io/posts/chi-rb-2023"},{"title":"Meta Keywords：是什么、为什么不","date":"2023-01-15 12:47:00","description":"\n<p>形如 <code>&lt;meta keywords=\"sukka, skk.moe\"&gt;</code> 的 Meta Keywords 是 Meta 标签的一种，仅存在于 HTML 代码中、不会在浏览器中展示。过去，Meta Keywords 标签被用于告诉搜索引擎爬虫关于网页的信息。但是，现在搜索引擎还尊重 Meta Keywords 么？Meta Keywords 是否仍然是 SEO 的最佳实践？</p>\n<img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/206133/15/29952/14316/63c3f4c9F348e255c/41cd99246b2b32f8.png\"><br><p>请前往 <a href=\"https://blog.skk.moe/post/say-no-to-meta-keywords/\">https://blog.skk.moe/post/say-no-to-meta-keywords/</a> 阅读全文</p>\n","link":"https://blog.skk.moe/post/say-no-to-meta-keywords/"},{"title":"打造一个强大的 PowerShell 终端 =)","date":"2023-01-13 08:58:47","description":"\n<h2>注意</h2>\n<p>请使用PowerShell 7。</p>\n<h2>安装所需要的软件</h2>\n<p>这里我使用Scoop进行安装，如果本地没有Scoop的话可以去看看<a href=\"https://blog.mk1.io/posts/hey-managers\">这篇文章</a>。</p>\n<pre><code class=\"language-bash\">$ scoop install pscolor posh-cargo posh-docker posh-git scoop-completion dockercompletion bottom starship zoxide git-aliases hub\n</code></pre>\n<p>我的PowerShell配置：</p>\n<pre><code class=\"language-powershell\">using namespace System.Management.Automation\nusing namespace System.Management.Automation.Language\n\n#############################\n# Encoding\n#############################\n\n# 编码\n[console]::InputEncoding = [console]::OutputEncoding = New-Object System.Text.UTF8Encoding\n\n#############################\n# PSReadLine\n#############################\n\nImport-Module PSReadLine\n\n# 补全括号和引号\nSet-PSReadLineOption -HistorySearchCursorMovesToEnd\nSet-PSReadlineKeyHandler -Key Tab -Function MenuComplete\nSet-PSReadlineKeyHandler -Key UpArrow -Function HistorySearchBackward\nSet-PSReadlineKeyHandler -Key DownArrow -Function HistorySearchForward\n\nSet-PSReadLineOption -Predictionsource History\n\n# Smart Insertion\n\nSet-PSReadLineKeyHandler -Key '\"', \"'\" `\n    -BriefDescription SmartInsertQuote `\n    -LongDescription \"Insert paired quotes if not already on a quote\" `\n    -ScriptBlock {\n    param($key, $arg)\n\n    $quote = $key.KeyChar\n\n    $selectionStart = $null\n    $selectionLength = $null\n    [Microsoft.PowerShell.PSConsoleReadLine]::GetSelectionState([ref]$selectionStart, [ref]$selectionLength)\n\n    $line = $null\n    $cursor = $null\n    [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$line, [ref]$cursor)\n\n    # If text is selected, just quote it without any smarts\n    if ($selectionStart -ne -1) {\n        [Microsoft.PowerShell.PSConsoleReadLine]::Replace($selectionStart, $selectionLength, $quote + $line.SubString($selectionStart, $selectionLength) + $quote)\n        [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($selectionStart + $selectionLength + 2)\n        return\n    }\n\n    $ast = $null\n    $tokens = $null\n    $parseErrors = $null\n    [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$ast, [ref]$tokens, [ref]$parseErrors, [ref]$null)\n\n    function FindToken {\n        param($tokens, $cursor)\n\n        foreach ($token in $tokens) {\n            if ($cursor -lt $token.Extent.StartOffset) { continue }\n            if ($cursor -lt $token.Extent.EndOffset) {\n                $result = $token\n                $token = $token -as [StringExpandableToken]\n                if ($token) {\n                    $nested = FindToken $token.NestedTokens $cursor\n                    if ($nested) { $result = $nested }\n                }\n\n                return $result\n            }\n        }\n        return $null\n    }\n\n    $token = FindToken $tokens $cursor\n\n    # If we're on or inside a **quoted** string token (so not generic), we need to be smarter\n    if ($token -is [StringToken] -and $token.Kind -ne [TokenKind]::Generic) {\n        # If we're at the start of the string, assume we're inserting a new string\n        if ($token.Extent.StartOffset -eq $cursor) {\n            [Microsoft.PowerShell.PSConsoleReadLine]::Insert(\"$quote$quote \")\n            [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($cursor + 1)\n            return\n        }\n\n        # If we're at the end of the string, move over the closing quote if present.\n        if ($token.Extent.EndOffset -eq ($cursor + 1) -and $line[$cursor] -eq $quote) {\n            [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($cursor + 1)\n            return\n        }\n    }\n\n    if ($null -eq $token -or\n        $token.Kind -eq [TokenKind]::RParen -or $token.Kind -eq [TokenKind]::RCurly -or $token.Kind -eq [TokenKind]::RBracket) {\n        if ($line[0..$cursor].Where{ $_ -eq $quote }.Count % 2 -eq 1) {\n            # Odd number of quotes before the cursor, insert a single quote\n            [Microsoft.PowerShell.PSConsoleReadLine]::Insert($quote)\n        } else {\n            # Insert matching quotes, move cursor to be in between the quotes\n            [Microsoft.PowerShell.PSConsoleReadLine]::Insert(\"$quote$quote\")\n            [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($cursor + 1)\n        }\n        return\n    }\n\n    # If cursor is at the start of a token, enclose it in quotes.\n    if ($token.Extent.StartOffset -eq $cursor) {\n        if ($token.Kind -eq [TokenKind]::Generic -or $token.Kind -eq [TokenKind]::Identifier -or \n            $token.Kind -eq [TokenKind]::Variable -or $token.TokenFlags.hasFlag([TokenFlags]::Keyword)) {\n            $end = $token.Extent.EndOffset\n            $len = $end - $cursor\n            [Microsoft.PowerShell.PSConsoleReadLine]::Replace($cursor, $len, $quote + $line.SubString($cursor, $len) + $quote)\n            [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($end + 2)\n            return\n        }\n    }\n\n    # We failed to be smart, so just insert a single quote\n    [Microsoft.PowerShell.PSConsoleReadLine]::Insert($quote)\n}\n\nSet-PSReadLineKeyHandler -Key '(', '{', '[' `\n    -BriefDescription InsertPairedBraces `\n    -LongDescription \"Insert matching braces\" `\n    -ScriptBlock {\n    param($key, $arg)\n\n    $closeChar = switch ($key.KeyChar) {\n        &lt;#case#&gt; '(' { [char]')'; break }\n        &lt;#case#&gt; '{' { [char]'}'; break }\n        &lt;#case#&gt; '[' { [char]']'; break }\n    }\n\n    $selectionStart = $null\n    $selectionLength = $null\n    [Microsoft.PowerShell.PSConsoleReadLine]::GetSelectionState([ref]$selectionStart, [ref]$selectionLength)\n\n    $line = $null\n    $cursor = $null\n    [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$line, [ref]$cursor)\n    \n    if ($selectionStart -ne -1) {\n        # Text is selected, wrap it in brackets\n        [Microsoft.PowerShell.PSConsoleReadLine]::Replace($selectionStart, $selectionLength, $key.KeyChar + $line.SubString($selectionStart, $selectionLength) + $closeChar)\n        [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($selectionStart + $selectionLength + 2)\n    } else {\n        # No text is selected, insert a pair\n        [Microsoft.PowerShell.PSConsoleReadLine]::Insert(\"$($key.KeyChar)$closeChar\")\n        [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($cursor + 1)\n    }\n}\n\nSet-PSReadLineKeyHandler -Key ')', ']', '}' `\n    -BriefDescription SmartCloseBraces `\n    -LongDescription \"Insert closing brace or skip\" `\n    -ScriptBlock {\n    param($key, $arg)\n\n    $line = $null\n    $cursor = $null\n    [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$line, [ref]$cursor)\n\n    if ($line[$cursor] -eq $key.KeyChar) {\n        [Microsoft.PowerShell.PSConsoleReadLine]::SetCursorPosition($cursor + 1)\n    } else {\n        [Microsoft.PowerShell.PSConsoleReadLine]::Insert(\"$($key.KeyChar)\")\n    }\n}\n\nSet-PSReadLineKeyHandler -Key Backspace `\n    -BriefDescription SmartBackspace `\n    -LongDescription \"Delete previous character or matching quotes/parens/braces\" `\n    -ScriptBlock {\n    param($key, $arg)\n\n    $line = $null\n    $cursor = $null\n    [Microsoft.PowerShell.PSConsoleReadLine]::GetBufferState([ref]$line, [ref]$cursor)\n\n    if ($cursor -gt 0) {\n        $toMatch = $null\n        if ($cursor -lt $line.Length) {\n            switch ($line[$cursor]) {\n                &lt;#case#&gt; '\"' { $toMatch = '\"'; break }\n                &lt;#case#&gt; \"'\" { $toMatch = \"'\"; break }\n                &lt;#case#&gt; ')' { $toMatch = '('; break }\n                &lt;#case#&gt; ']' { $toMatch = '['; break }\n                &lt;#case#&gt; '}' { $toMatch = '{'; break }\n            }\n        }\n\n        if ($toMatch -ne $null -and $line[$cursor - 1] -eq $toMatch) {\n            [Microsoft.PowerShell.PSConsoleReadLine]::Delete($cursor - 1, 2)\n        } else {\n            [Microsoft.PowerShell.PSConsoleReadLine]::BackwardDeleteChar($key, $arg)\n        }\n    }\n}\n\n#############################\n# Highlighting\n#############################\n\n# 高亮\nImport-Module PSColor\n# Import-Module syntax-highlighting\n\n#############################\n# Completions\n#############################\n\n# 自动补全\nImport-Module $Env:SCOOP\\modules\\posh-cargo\nImport-Module $Env:SCOOP\\modules\\posh-docker\nImport-Module $Env:SCOOP\\modules\\posh-git\nImport-Module $Env:SCOOP\\modules\\scoop-completion\nImport-Module $Env:SCOOP\\modules\\dockercompletion\nImport-Module $Env:SCOOP\\apps\\bottom\\current\\completion\\_btm.ps1\nstarship completions powershell | Out-String | Invoke-Expression\n# 注意：以下补全为开发环境的补全，你的电脑上可能没有装，请自行删除 =v=\nrustup completions powershell | Out-String | Invoke-Expression\nfnm completions --shell powershell | Out-String | Invoke-Expression\ndvm completions powershell | Out-String | Invoke-Expression\ndeno completions powershell --unstable | Out-String | Invoke-Expression\n# (&amp; conda 'shell.powershell' 'hook') | Out-String | Invoke-Expression\n(&amp; volta completions powershell) | Out-String | Invoke-Expression\nInvoke-Expression (&amp; { $hook = if ($PSVersionTable.PSVersion.Major -ge 6) { 'pwd' } else { 'prompt' } (zoxide init powershell --hook $hook | Out-String) })\n\n#############################\n# Starship\n#############################\n\n# 初始化Starship，这一块之后会讲\nInvoke-Expression (&amp;starship init powershell)\n\n#############################\n# Rust\n#############################\n\n# Rustup\n# 设置Rustup的镜像\n$Env:RUSTUP_DIST_SERVER = \"https://mirrors.ustc.edu.cn/rust-static\"\n$Env:RUSTUP_UPDATE_ROOT = \"https://mirrors.ustc.edu.cn/rust-static/rustup\"\n\n#############################\n# fnm\n#############################\n\n# 设置FNM镜像和安装目录\n$Env:FNM_DIR = \"D:\\.fnm\"\n$Env:FNM_NODE_DIST_MIRROR = \"https://cdn.npmmirror.com/binaries/node\"\n\nfnm env --use-on-cd | Out-String | Invoke-Expression\n\n#############################\n# PyEnv\n#############################\n\n# $Env:PYTHON_BUILD_MIRROR_URL = \"https://npm.taobao.org/mirrors/python\"\n\n#############################\n# Zoxide alias\n# Well, this should be here\n#############################\n\n# Remove-Alias -Name cd -Force\n# Set-Alias cd z\n\n#############################\n# PNPM\n#############################\n\n# 设置PNPM目录\n$Env:PNPM_HOME = \"D:\\.pnpm\"\n$Env:Path += \";$Env:PNPM_HOME\"\n\n#############################\n# Path\n#############################\n\n# 添加deno install目录\n$Env:Path += \";C:\\Users\\Hatsune_Miku\\.deno\\bin\"\n\n#############################\n# Aliases\n#############################\n\n# Fix @antfu/ni\nRemove-Alias -Name ni -Force\n# Fix Scoop Install alias\nRemove-Alias -Name si -Force\n\n# Git\nImport-Module git-aliases -DisableNameChecking\nSet-Alias git hub\nSet-Alias code code-insiders\n\n# 一些缩写，同样你的电脑上可能没有装，请自行删除\n# Node\n# 这里需要你npm安装@antfu/ni\nfunction nio { ni --prefer-offline @Args }\nfunction nid { ni -D @Args }\nfunction nd { nr dev @Args }\nfunction ns { nr start @Args }\nfunction nb { nr build @Args }\nfunction nbw { nr build --watch @Args }\nfunction nt { nr test @Args }\nfunction ntu { nr test -u @Args }\nfunction ntw { nr test --watch @Args }\nfunction nw { nr watch @Args }\nfunction np { pnpm publish --access public --no-git-checks @Args }\nfunction nc { nr typecheck @Args }\nfunction nl { nr lint @Args }\nfunction nlf { nr lint --fix @Args }\nfunction nrelease { nr release @Args }\nfunction nre { nr release @Args }\n\n# 这里需要你npm安装taze\nfunction vc { nx vercel@latest @Args }\nfunction taze { nx taze@latest @Args }\nfunction tzm { taze major @Args }\nfunction tz { taze major -wfri @Args }\nfunction giget { nx giget@latest @Args }\nfunction vcp { vc --prod @Args }\n\n# Deno\n# 这里需要你deno安装deployctl\nfunction dctl { deployctl deploy @Args }\nfunction dctlp { dctl --prod @Args }\n\n# Go\n# 这里需要你安装Go\nfunction gg { go get @Args }\nfunction gmt { go mod tidy @Args }\nfunction gmi { go mod init @Args }\nfunction gt { go test @Args }\nfunction gta { go test ./... @Args }\n\n# Python\n# 这里需要你安装Python\nfunction pi { pip install @Args }\nfunction pu { pip install --upgrade @Args }\nfunction pup { pu pip }\n\n# Misc\n# 这里需要你安装you-get和scoop\nfunction yg { you-get -o=\"D:\\.you-get\" @Args } # You-get\nfunction si { scoop install @Args } # Scoop Install\nfunction sun { scoop uninstall @Args } # Scoop Uninstall\n# 代理\nfunction proxy {\n    $Env:http_proxy = \"http://127.0.0.1:7890\"\n    $Env:https_proxy = \"http://127.0.0.1:7890\"\n}\nfunction unproxy {\n    $Env:http_proxy = \"\"\n    $Env:https_proxy = \"\"\n}\n# 安装夜间版Node\nfunction fnmn { fnm --node-dist-mirror https://nodejs.org/download/nightly/ @Args }\nfunction Rename-Branch {\n    git branch -m $Args[0] $Args[1]\n    git fetch origin\n    git branch -u \"origin/$Args[1]\" $Args[1]\n    git remote set-head origin -a\n}\n\n# INIT Proxy\n\nproxy\n</code></pre>\n","link":"https://blog.mk1.io/posts/powerful-powershell"},{"title":"2022：浏览器从 A 到 Z","date":"2023-01-12 09:56:00","description":"\n<p>将 A-Z 逐一输入到 Google Chrome 的地址栏里，Google Chrome 都会自动补全出哪些域名呢？</p>\n<img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/192427/31/30756/24965/63bfdc62Fc08329f1/29b23b69b5df0ec9.png\"><br><p>请前往 <a href=\"https://blog.skk.moe/post/2022-browser-from-a-to-z/\">https://blog.skk.moe/post/2022-browser-from-a-to-z/</a> 阅读全文</p>\n","link":"https://blog.skk.moe/post/2022-browser-from-a-to-z/"},{"title":"Detalk.js —— 具有高自定义性、简洁、轻量的开源评论系统","date":"2023-01-09 16:00:00","description":"\n<h2>\n<a href=\"https://blog.yfun.top/#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%8F%91-Detalk-js\" class=\"headerlink\" title=\"为什么开发 Detalk.js?\"></a>为什么开发 Detalk.js?</h2>\n<p>我一直在寻找开源、可以免费部署的评论系统，在 Valine 发现隐私问题和 XSS 漏洞后，我就放弃了 Valine 和「无后端」解决方案。</p>\n<p>Waline 是「有后端的 Valine」，保留了 Valine 的很多特性，但还是没有让我满意。</p>\n<p>后来，<a href=\"https://blog.yfun.top/posts/1987652759/#%E8%AF%84%E8%AE%BA\">我转到了 Twikoo</a>，这也是我使用最久的评论系统。它有非常丰富的特性，但我最后还是弃用了它。</p>\n<p>Detalk.js 的部署平台从名字就可以看出，基于 Deta Bases 和 Deta Micros. 这些平台对个人开发者免费使用，非常的友好。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91\" class=\"headerlink\" title=\"服务端开发\"></a>服务端开发</h2>\n<p>Detalk.js 一开始就选择优先开发服务端，而前端则可以随意构建，有完整的服务端文档。</p>\n<p>所以，我将主代码放到了 <a href=\"https://github.com/detalkjs/server\">detalkjs/server</a> 中，得益于 Deta 平台，现在可以一键部署，稍等片刻就可以直接使用。</p>\n<p>服务端我直接从官方的 Demo 开始写，使用官方推荐的 Express 框架，代码语言选择 JavaScript.</p>\n<p>在开发过程中，我发现 Detalk.js 的响应时长至少在 1s+，我推测是与 Deta 平台的运行方案和冷启动有关，但对于评论系统来说，这无伤大雅。</p>\n<h3>\n<a href=\"https://blog.yfun.top/#%E6%95%B0%E6%8D%AE%E5%BA%93\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3>\n<p>Deta 平台上，最方便的数据库就是 Deta Bases. 这又是一款 Key-Value 数据库，有着简单易于理解的 SDK 文档。</p>\n<p>导入方法也很简单：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> { Deta } = <span class=\"built_in\">require</span>(<span class=\"string\">'deta'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> deta = Deta();</span><br><span class=\"line\"><span class=\"comment\">// 为了方便用户部署多个 Detalk，用户可自定义 Base Name.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> db = deta.Base(process.env.BASE_NAME || <span class=\"string\">'detalk'</span>);</span><br></pre></td></tr></table></figure><p>使用方法整体类似于 <a href=\"https://github.com/yfun-lab/gh-worker-kv\">yfun-lab/gh-worker-kv</a>，对于部分代码的上手也是很简单的。</p>\n<p>前往 Web 面板截图，可以看到，Detalk 所创建的数据库基本格式如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.19/rawimg/ck31673269985711.png\"></p>\n<p>以 <code>CMT_</code> 开头的存放评论，<code>FUNCTION_</code> 开头的存放事件函数，还有一些关于站点的配置。</p>\n<h3>\n<a href=\"https://blog.yfun.top/#API\" class=\"headerlink\" title=\"API\"></a>API</h3>\n<p>目前，所有后端的 API 都在 <a href=\"https://detalk.js.org/server/api.html\">API | Detalk.js</a> 可以查看。</p>\n<p>部分 API 需要鉴权登录操作，部分为公共 API，只需要后端地址即可调用。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91\" class=\"headerlink\" title=\"前端开发\"></a>前端开发</h2>\n<p>我对前端 <a href=\"https://github.com/detalkjs/client\">detalkjs/client</a> 的简介是：</p>\n<blockquote><p>⚡ The fastest way to add Detalk (Based on Deta) to your website. | 将 Detalk (Based on Deta) 加入你的网站。</p></blockquote>\n<p>（这再次说明官方提供的前端只是一种方案，完全可以自己开发</p>\n<p>也正因如此，前端的 NPM 包名是 <code>@detalk/static</code> （逃</p>\n<h3>\n<a href=\"https://blog.yfun.top/#%E6%89%93%E5%8C%85\" class=\"headerlink\" title=\"打包\"></a>打包</h3>\n<p>前端打包是 Webpack 5 方案，我多加了一个配置文件，可以打包出 JS, CSS 分离的版本。这样或许可以方便部分用户的引入需要。</p>\n<p>但是从各方面来看，还是建议引入单 JS 的版本，大小约为 43kb，Gzip 压缩后约 12kb.</p>\n<h3>\n<a href=\"https://blog.yfun.top/#%E5%89%8D%E7%AB%AF%E9%85%8D%E7%BD%AE%EF%BC%9F\" class=\"headerlink\" title=\"前端配置？\"></a>前端配置？</h3>\n<p>设计前端时有两种读取配置文件的方案，一种是类似于 Twikoo，从服务端读取，另一种是直接在 <code>detalk.init</code> 时配置。</p>\n<p>明显，前者需要多发送 1 - 2 次 HTTP 请求，加载速度也会变慢，所以我选择了后者。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF\" class=\"headerlink\" title=\"控制面板\"></a>控制面板</h2>\n<p>控制面板也可以使用完全 API 自构建，但是，我们提供了「依托答辩」的官方后端：<a href=\"https://detalk-dash.netlify.app/\">https://detalk-dash.netlify.app/</a> </p>\n<p><del>除可维护角度以外，都挺好的（</del></p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98\" class=\"headerlink\" title=\"一些问题\"></a>一些问题</h2>\n<h3>\n<a href=\"https://blog.yfun.top/#Markdown-%E8%A7%A3%E6%9E%90\" class=\"headerlink\" title=\"Markdown 解析\"></a>Markdown 解析</h3>\n<p>如果你没有额外的配置，那么点击「预览」的时候。你肯定会发现需要等待一段时间。</p>\n<p>我之前想把 Marked.js（号称轻量）的 Markdown 解析器加入 Detalk.js，结果发现包体积直接翻了一倍，于是放弃。</p>\n<p>如果你需要更换解析器，不用担心，<a href=\"https://detalk.js.org/client/advanced.html#%E8%87%AA%E5%AE%9A%E4%B9%89-markdown-%E9%A2%84%E8%A7%88\">这里</a>给出了方法。</p>\n<h3>\n<a href=\"https://blog.yfun.top/#URL-%E8%BD%BD%E5%85%A5%E9%85%8D%E7%BD%AE\" class=\"headerlink\" title=\"URL 载入配置\"></a>URL 载入配置</h3>\n<p>前文说到，Detalk 并没有采取后端配置的方法，但是，我们还是支持了从 URL 载入配置。</p>\n<p>关于这一特性，可<a href=\"https://detalk.js.org/client/advanced.html#beta-%E4%BB%8E-url-%E8%BD%BD%E5%85%A5%E9%85%8D%E7%BD%AE\">见此处</a>。</p>\n<h3>\n<a href=\"https://blog.yfun.top/#%E5%A4%9A%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%9E%E7%8E%B0\" class=\"headerlink\" title=\"多语言的实现\"></a>多语言的实现</h3>\n<p>Detalk.js 并没有默认提供多语言功能，这主要是因为不同站点的使用者受众不同，于是我决定这项功能可以由用户实现。</p>\n<p>这依赖 <code>window.DETALK_I18N</code> 参数，如果没有此项，则会在 <code>detalk.init</code> 时由程序默认提供简体中文项。</p>\n<p>实现代码可以见如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (navigator.language == <span class=\"string\">'zh-CN'</span>) {</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.DETALK_I18N = {</span><br><span class=\"line\">      loadMore: <span class=\"string\">'加载更多'</span>,</span><br><span class=\"line\">      notAllowedInput: <span class=\"string\">'输入内容不符合要求！'</span>,</span><br><span class=\"line\">      send: <span class=\"string\">'发送'</span>,</span><br><span class=\"line\">      preview: <span class=\"string\">'预览'</span>,</span><br><span class=\"line\">      reply: <span class=\"string\">'回复'</span>,</span><br><span class=\"line\">      replyTo: <span class=\"string\">'回复'</span>,</span><br><span class=\"line\">      cancel: <span class=\"string\">'取消'</span>,</span><br><span class=\"line\">      loadingLoginFrame: <span class=\"string\">'登录窗口加载中...'</span>,</span><br><span class=\"line\">      gotoLoginFrame: <span class=\"string\">'请在登录窗口中继续'</span>,</span><br><span class=\"line\">      waitingInfo: <span class=\"string\">'登录成功，正在获取用户信息...'</span>,</span><br><span class=\"line\">      loginSuccess: <span class=\"string\">'登录成功'</span>,</span><br><span class=\"line\">      failedLoadingInfo: <span class=\"string\">'获取用户信息失败'</span>,</span><br><span class=\"line\">      deleteConfirm: <span class=\"string\">'即将删除 ID:[#ID] 评论，是否继续？'</span>,</span><br><span class=\"line\">      total: <span class=\"string\">'共 [#TOTAL] 条评论'</span>,</span><br><span class=\"line\">      noComment: <span class=\"string\">'暂无评论'</span>,</span><br><span class=\"line\">      up: <span class=\"string\">'正序'</span>,</span><br><span class=\"line\">      down: <span class=\"string\">'倒序'</span>,</span><br><span class=\"line\">      <span class=\"keyword\">delete</span>: <span class=\"string\">'删除'</span>,</span><br><span class=\"line\">      top: <span class=\"string\">'置顶'</span>,</span><br><span class=\"line\">      login: <span class=\"string\">'登录'</span>,</span><br><span class=\"line\">      required: <span class=\"string\">'必填'</span>,</span><br><span class=\"line\">      optional: <span class=\"string\">'选填'</span>,</span><br><span class=\"line\">      nickname: <span class=\"string\">'昵称'</span>,</span><br><span class=\"line\">      email: <span class=\"string\">'邮箱'</span>,</span><br><span class=\"line\">      link: <span class=\"string\">'网址'</span>,</span><br><span class=\"line\">      day: {</span><br><span class=\"line\">      justNow: <span class=\"string\">'刚刚'</span>,</span><br><span class=\"line\">      minute: <span class=\"string\">'[#TIME] 分钟前'</span>,</span><br><span class=\"line\">      hour: <span class=\"string\">'[#TIME] 小时前'</span>,</span><br><span class=\"line\">      day: <span class=\"string\">'[#TIME] 天前'</span>,</span><br><span class=\"line\">  }</span><br><span class=\"line\">} <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (navigator.language == <span class=\"string\">'zh-TW'</span>) {</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.DETALK_I18N = {</span><br><span class=\"line\">      loadMore: <span class=\"string\">'加載更多'</span>,</span><br><span class=\"line\">      notAllowedInput: <span class=\"string\">'輸入內容不符合要求！'</span>,</span><br><span class=\"line\">      send: <span class=\"string\">'發送'</span>,</span><br><span class=\"line\">      preview: <span class=\"string\">'預覽'</span>,</span><br><span class=\"line\">      reply: <span class=\"string\">'回复'</span>,</span><br><span class=\"line\">      replyTo: <span class=\"string\">'回复'</span>,</span><br><span class=\"line\">      cancel: <span class=\"string\">'取消'</span>,</span><br><span class=\"line\">      loadingLoginFrame: <span class=\"string\">'登錄窗口加載中...'</span>,</span><br><span class=\"line\">      gotoLoginFrame: <span class=\"string\">'請在登錄窗口中繼續'</span>,</span><br><span class=\"line\">      waitingInfo: <span class=\"string\">'登錄成功，正在獲取用戶信息...'</span>,</span><br><span class=\"line\">      loginSuccess: <span class=\"string\">'登錄成功'</span>,</span><br><span class=\"line\">      failedLoadingInfo: <span class=\"string\">'獲取用戶信息失敗'</span>,</span><br><span class=\"line\">      deleteConfirm: <span class=\"string\">'即將刪除 ID:[#ID] 評論，是否繼續？'</span>,</span><br><span class=\"line\">      total: <span class=\"string\">'共 [#TOTAL] 條評論'</span>,</span><br><span class=\"line\">      noComment: <span class=\"string\">'暫無評論'</span>,</span><br><span class=\"line\">      up: <span class=\"string\">'正序'</span>,</span><br><span class=\"line\">      down: <span class=\"string\">'倒序'</span>,</span><br><span class=\"line\">      <span class=\"keyword\">delete</span>: <span class=\"string\">'刪除'</span>,</span><br><span class=\"line\">      top: <span class=\"string\">'置頂'</span>,</span><br><span class=\"line\">      login: <span class=\"string\">'登錄'</span>,</span><br><span class=\"line\">      required: <span class=\"string\">'必填'</span>,</span><br><span class=\"line\">      optional: <span class=\"string\">'選填'</span>,</span><br><span class=\"line\">      nickname: <span class=\"string\">'暱稱'</span>,</span><br><span class=\"line\">      email: <span class=\"string\">'郵箱'</span>,</span><br><span class=\"line\">      link: <span class=\"string\">'網址'</span>,</span><br><span class=\"line\">      day: {</span><br><span class=\"line\">      justNow: <span class=\"string\">'剛剛'</span>,</span><br><span class=\"line\">      minute: <span class=\"string\">'[#TIME] 分鐘前'</span>,</span><br><span class=\"line\">      hour: <span class=\"string\">'[#TIME] 小時前'</span>,</span><br><span class=\"line\">      day: <span class=\"string\">'[#TIME] 天前'</span>,</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><h2>\n<a href=\"https://blog.yfun.top/#%E6%9C%80%E5%90%8E\" class=\"headerlink\" title=\"最后\"></a>最后</h2>\n<p>Detalk.js 未来会与 ESHexoN 融合，在 ESHexoN 中提供管理面板。</p>\n<p>同时，YFun's Blog 也会在后续更新有关 Detalk.js 的更多文章。</p>\n<p>目前，此博客已经更换至 Detalk.js 评论系统，欢迎测试与使用！</p>\n","link":"https://blog.yfun.top/posts/2023/detalkjs/"},{"title":"无垠 2022 年度总结","date":"2023-01-02 17:14:32","description":"\n<p>依然是忙碌的一年，晚了几天，2022 的年度总结终于还是写完了。</p>\n<h1>统计数据</h1>\n<p>年度总结的第一部分仍然是一些统计数据。以下数据截止 2022 年 12 月 31 日 23:39:59。</p>\n<h2>博客主站</h2>\n<p>无垠博客主站，年 UV 26,399 (<span>-9.2%</span>)，年 PV 55,460 (<span>-18.07%</span>)，日均 UV 72.33，平均停留时间 3分31秒 (<span>-1.4%</span>)，平均跳出率 60% (<span>-9.1%</span>)。一年有效文章数 1，新增评论 33 条 (<span>-69.72%</span>)。</p>\n<a href=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/blog.jpg\"><img decoding=\"async\" loading=\"lazy\" src=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/blog.jpg\" alt=\"\" width=\"800\" height=\"773\" class=\"aligncenter size-full wp-image-2677\" srcset=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/blog.jpg 800w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/blog-300x290.jpg 300w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/blog-768x742.jpg 768w\" sizes=\"(max-width: 800px) 100vw, 800px\"></a>\n<p>在八月 MDx 被 wpjam 推荐了，访问量有两天大幅上涨；在九月底十月初的几天似乎我的统计域名在大陆被临时屏蔽了，几乎没有获取到统计数据。</p>\n<p>2022 忙碌于进一步求学等事情，并没有更新太多文章，评论区也没有怎么维护，导致数据全部下滑。算上去年欠下的文章，实际上现在有五篇写了一半的文章在我的草稿箱里，希望可以尽快完成吧。</p>\n<h2>个人主页</h2>\n<p>个人页总 UV 1,734 (<span>-50.67%</span>)，总 PV 2,195 (<span>-44.13%</span>)，日均 UV 4.75，平均停留时间 49秒 (<span>-10.91%</span>)。访问的主要来源是知乎，WordPress.org 和 GitHub。</p>\n<a href=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/axton.jpg\"><img decoding=\"async\" loading=\"lazy\" src=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/axton.jpg\" alt=\"\" width=\"800\" height=\"765\" class=\"aligncenter size-full wp-image-2678\" srcset=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/axton.jpg 800w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/axton-300x287.jpg 300w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/axton-768x734.jpg 768w\" sizes=\"(max-width: 800px) 100vw, 800px\"></a>\n<p>仍然是没有更新个人主页的一年，我也没有继续宣传这个页面，统计数据发生了大幅下滑。</p>\n<h2>MDx</h2>\n<p>很遗憾，尽管 MDx 得到了 wpjam 的推荐，2022 年 MDx 并没有得到我足够的关注。在这一年中，MDx 更新了 0 次，新增 3 commits。还是希望等这阵子忙完，明年可以把更多的时间花在维护 MDx 上，尽快更新新的版本。无论如何，还是感谢各位对于 MDx 的支持！</p>\n<h1>2022 大事记</h1>\n<p>2022 真的做了很多事。不过由于年中手机损坏，丢失了半年的照片，下面的列表大概确实遗漏了几件事。2022 主要是把停滞了一阵子的摄影爱好重新捡了起来，但遗憾并没有在开源领域投入太多时间。希望 2023 年我可以进一步平衡不同事情上花的时间。</p>\n<ul>\n<li>三月：MDx 喜提 800 Stars</li>\n<li>四月：第二次前往爱丁堡，不经意拍下了我今年最喜欢的照片之一</li>\n<li>六月：在考试周期间用了三年的 OnePlus 7 Pro 突然暴毙，丢了一堆照片，滚去 iOS 了</li>\n<li>六月：第一次申请申根签证，贵（</li>\n<li>六月：第一次前往西班牙，热成傻逼（没写游记，懒）</li>\n<li>六月：第一次跳伞！（当然有教练带）</li>\n<li>六月：一个暑假同时做了一个实习和一个 Research，累成傻逼</li>\n<li>七月：第一次求到英国邮戳</li>\n<li>七月：迫于开发需求，狂暴购入 Pixel 6 一台，这下双持了</li>\n<li>七月：第一次跨国寄信</li>\n<li>八月：第一次前往法国，只在巴黎呆了两天</li>\n<li>八月：第一次前往瑞士，在少女峰下休息了三天，并第一次摔坏了镜头（详情见<a href=\"https://flyhigher.top/diary/2639.html\">这篇文章</a>）</li>\n<li>八月：然后阳了（</li>\n<li>八月：MDx 被 wpjam 推荐</li>\n<li>九月：卖了全部的摄影装备，然后第一次升级到全画幅（在 ebay 上捡漏的二手尼康 Z 6）</li>\n<li>九月：在威尔士拍到了我目前拍的最好的星空和银河</li>\n<li>十月：尽管胶片大涨价，但想拍反转胶片的心突然死灰复燃；胶片机不在身边，于是在 ebay 上从日本狂暴购入尼康 F80S 全自动胶片机，重新拍起了胶片</li>\n<li>十二月：MDx 喜提 900 Stars</li>\n<li>十二月：第二次前往瑞士，在马特洪峰下住了五天，拍了一堆照片，还在雪里打了滚（参阅上面的游记）</li>\n</ul>\n<section><div class=\"set-images-div\">\n<a href=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-12-wm.jpg\"><img decoding=\"async\" loading=\"lazy\" src=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-12-wm.jpg\" alt=\"威尔士滕比的星空，我目前拍得最好的银河\" width=\"1523\" height=\"2500\" class=\"aligncenter size-full wp-image-2673\" srcset=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-12-wm.jpg 1523w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-12-wm-183x300.jpg 183w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-12-wm-624x1024.jpg 624w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-12-wm-768x1261.jpg 768w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-12-wm-936x1536.jpg 936w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-12-wm-1248x2048.jpg 1248w\" sizes=\"(max-width: 1523px) 100vw, 1523px\"></a><br><a href=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-6-5-wm.jpg\"><img decoding=\"async\" loading=\"lazy\" src=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-6-5-wm.jpg\" alt=\"西班牙圣家堂\" width=\"1667\" height=\"2500\" class=\"aligncenter size-full wp-image-2670\"></a><br><a href=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-12-5-wm.jpg\"><img decoding=\"async\" loading=\"lazy\" src=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-12-5-wm.jpg\" alt=\"去看了飞机，胶片拍摄\" width=\"1707\" height=\"2500\" class=\"aligncenter size-full wp-image-2674\" srcset=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-12-5-wm.jpg 1707w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-12-5-wm-205x300.jpg 205w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-12-5-wm-699x1024.jpg 699w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-12-5-wm-768x1125.jpg 768w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-12-5-wm-1049x1536.jpg 1049w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-12-5-wm-1398x2048.jpg 1398w\" sizes=\"(max-width: 1707px) 100vw, 1707px\"></a><br><a href=\"https://acdn.flyhigher.top/wp-content/uploads/2022/12/2022-12-9-wm.jpg\"><img decoding=\"async\" loading=\"lazy\" src=\"https://acdn.flyhigher.top/wp-content/uploads/2022/12/2022-12-9-wm.jpg\" alt=\"采尔马特的日落\" width=\"1584\" height=\"2500\" class=\"aligncenter size-full wp-image-2591\" srcset=\"https://acdn.flyhigher.top/wp-content/uploads/2022/12/2022-12-9-wm.jpg 1584w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/2022-12-9-wm-190x300.jpg 190w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/2022-12-9-wm-649x1024.jpg 649w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/2022-12-9-wm-768x1212.jpg 768w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/2022-12-9-wm-973x1536.jpg 973w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/2022-12-9-wm-1298x2048.jpg 1298w\" sizes=\"(max-width: 1584px) 100vw, 1584px\"></a><br><a href=\"https://acdn.flyhigher.top/wp-content/uploads/2022/12/DSC_1705.jpg\"><img decoding=\"async\" loading=\"lazy\" src=\"https://acdn.flyhigher.top/wp-content/uploads/2022/12/DSC_1705.jpg\" alt=\"徒步最后变成在雪里打滚\" width=\"2400\" height=\"1554\" class=\"aligncenter size-full wp-image-2609\" srcset=\"https://acdn.flyhigher.top/wp-content/uploads/2022/12/DSC_1705.jpg 2400w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/DSC_1705-300x194.jpg 300w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/DSC_1705-1024x663.jpg 1024w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/DSC_1705-768x497.jpg 768w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/DSC_1705-1536x995.jpg 1536w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/DSC_1705-2048x1326.jpg 2048w\" sizes=\"(max-width: 2400px) 100vw, 2400px\"></a>\n</div>\n<div class=\"set-images-div2\">\n<a href=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-4-11-wm.jpg\"><img decoding=\"async\" loading=\"lazy\" src=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-4-11-wm.jpg\" alt=\"目前我最喜欢的照片，爱丁堡\" width=\"1633\" height=\"2500\" class=\"aligncenter size-full wp-image-2669\" srcset=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-4-11-wm.jpg 1633w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-4-11-wm-196x300.jpg 196w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-4-11-wm-669x1024.jpg 669w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-4-11-wm-768x1176.jpg 768w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-4-11-wm-1003x1536.jpg 1003w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-4-11-wm-1338x2048.jpg 1338w\" sizes=\"(max-width: 1633px) 100vw, 1633px\"></a><br><a href=\"https://acdn.flyhigher.top/wp-content/uploads/2022/12/IMG_2403-scaled.jpg\"><img decoding=\"async\" loading=\"lazy\" src=\"https://acdn.flyhigher.top/wp-content/uploads/2022/12/IMG_2403-scaled.jpg\" alt=\"2022 我最喜欢的照片之一，瑞士格林德瓦\" width=\"1648\" height=\"2560\" class=\"aligncenter size-full wp-image-2628\" srcset=\"https://acdn.flyhigher.top/wp-content/uploads/2022/12/IMG_2403-scaled.jpg 1648w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/IMG_2403-193x300.jpg 193w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/IMG_2403-659x1024.jpg 659w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/IMG_2403-768x1193.jpg 768w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/IMG_2403-989x1536.jpg 989w, https://acdn.flyhigher.top/wp-content/uploads/2022/12/IMG_2403-1319x2048.jpg 1319w\" sizes=\"(max-width: 1648px) 100vw, 1648px\"></a><br><a href=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-5-wm.jpg\"><img decoding=\"async\" loading=\"lazy\" src=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-5-wm.jpg\" alt=\"2022 我最喜欢的星空照片，威尔士滕比\" width=\"1750\" height=\"2500\" class=\"aligncenter size-full wp-image-2672\" srcset=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-5-wm.jpg 1750w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-5-wm-210x300.jpg 210w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-5-wm-717x1024.jpg 717w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-5-wm-768x1097.jpg 768w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-5-wm-1075x1536.jpg 1075w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/2022-9-5-wm-1434x2048.jpg 1434w\" sizes=\"(max-width: 1750px) 100vw, 1750px\"></a>\n</div>\n</section><p><span>点击图片查看描述</span></p>\n<h1>跨年红包</h1>\n<p>最近实在太忙，请容许我摸一摸。我知道去年的题解甚至都还没有发布，我会尽量赶在春节前发布去年题解并更新今年的谜题。</p>\n<h1>跨年海报</h1>\n<p>还是传统艺能，今年的海报只用到了 PS，胡乱整了点。</p>\n<a href=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/26.jpg\"><img decoding=\"async\" loading=\"lazy\" src=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/26.jpg\" alt=\"\" width=\"2500\" height=\"1768\" class=\"aligncenter size-full wp-image-2664\" srcset=\"https://acdn.flyhigher.top/wp-content/uploads/2023/01/26.jpg 2500w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/26-300x212.jpg 300w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/26-1024x724.jpg 1024w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/26-768x543.jpg 768w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/26-1536x1086.jpg 1536w, https://acdn.flyhigher.top/wp-content/uploads/2023/01/26-2048x1448.jpg 2048w\" sizes=\"(max-width: 2500px) 100vw, 2500px\"></a>\n<p>那么祝各位（迟到的）2023 年快乐！</p>\n","link":"https://flyhigher.top/diary/2662.html"},{"title":"2023新年快乐！ + 年度总结","date":"2022-12-31 10:11:51","description":"\n<p>今天事2022的最后一天，当你看到这篇文章的时候说不定已经是2023年啦（</p>\n<p>Ray之前都没有写过年度总结，不过今年对于我来说意义重大，还是写罢（</p>\n<h2>博客</h2>\n<p>今年Ray的小博客系统<a href=\"https://github.com/dolan-x\">Dolan</a>正式启用，虽然还有很多大大小小的问题，不过这也算是建站历史上一个里程碑式的事件了……之后的打算是在新年前给博客加上新年主题（挂个灯笼啥的），然后找个时间把Admin用Vue + Element Plus重构一下，React的单向数据流用起来真TM膈应人……</p>\n<h2>文章</h2>\n<p>今年Ray中考结束如愿上了三线小城市的屑高中（），由于学业原因以及住校的缘故无法抽出时间来更新文章，就连文章也没有更新几篇，唯一的那三篇甚至有两篇没有写完（全恼</p>\n<p>明年会努力的！</p>\n<h2>友链</h2>\n<p>今年加了不少大佬的友链，也清了一些死链）</p>\n<p>新增的有<a href=\"https://blog.yfun.top/\">YFun</a>，<a href=\"https://mzwing.eu.org/\">mzwing</a>、<a href=\"https://blog.imlete.cn/\">乐特</a>、<a href=\"https://blog.chwin.asia/\">伊緻幻</a>以及<a href=\"https://blog.cyfan.top/\">CYF</a>，但是CYF太高冷了并没有鸟我）</p>\n<h2>数据</h2>\n<p>有个毛的数据啊，都没加统计（），数据为N/A</p>\n<h2>学习</h2>\n<p>高中开始了，意味着又要三年苦读（恼），不过这次不是中考，而是更重要的高考😅</p>\n<p>希望自己能够不负三年的努力吧，给自己一个满意的结果！</p>\n<h2>未来……</h2>\n<p>有人见尘埃，有人望星辰。告别2022，拥抱2023。</p>\n<p>我们的每一天都在见证历史，欢迎2023！</p>\n","link":"https://blog.mk1.io/posts/2023"},{"title":"2023: 新年快乐 &amp; 博客总结","date":"2022-12-29 16:00:00","description":"\n<p>这一年对于我来说过的非常快，同时，也是很不平凡的一年。同样，今年也是 Blog 的第三年了。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%8F%8B%E9%93%BE\" class=\"headerlink\" title=\"友链\"></a>友链</h2>\n<p>在这一年中，YFun's Blog 友链数量（不包括本站站点）为 9 个，其中很多都是大佬 (\\=!!</p>\n<p>其中，<a href=\"https://dusays.com/\">杜老师说</a> 最活跃力！</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E6%96%87%E7%AB%A0\" class=\"headerlink\" title=\"文章\"></a>文章</h2>\n<p>在 2022 年中，YFun's Blog 发布 6 篇文章。</p>\n<p>其中，在 1 月 14 日到 8 月 4 日之间<strong>整整咕了七个月</strong>（</p>\n<p>今年水了两篇文章，其余的自认为质量还行。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%8D%9A%E5%AE%A2\" class=\"headerlink\" title=\"博客\"></a>博客</h2>\n<p>与去年相同，YFun's Blog 依然在使用自己开发的 <a href=\"https://github.com/oCoke/hexo-theme-miracle\">Theme Miracle</a>.</p>\n<p>今年 Miracle 已经迭代到 <code>v2.2.1</code> 版本，主要在修 Bug 和提升体验<del>（比如高斯模糊又加回来了</del></p>\n<p>目前，我正在使用 ESHexoN 编辑，如果想了解更多信息，可以看这篇文章：<a href=\"https://blog.yfun.top/posts/2022/eshexon/\">抛弃静态博客的缺点，用 ESHexoN 在线编辑！</a></p>\n<p>此外，还有一个项目可能会在 2023 年初加入到 YFun's Blog 上，那就是 <a href=\"https://detalk.js.org/\">Detalk.js</a>。我尝试用它实现自定义性更强的评论系统。</p>\n<p>现在，Detalk 已具备基础功能，感兴趣的同学可以试用一下（（</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E7%BB%9F%E8%AE%A1\" class=\"headerlink\" title=\"统计\"></a>统计</h2>\n<p>与去年一样，今年的数据是：<code>N/A</code>。</p>\n<p>虽然 Cloudflare Web Analytics 在 2021 年 4 月份启用，但后来又将统计代码去除。所以关于本站的统计信息一直是个谜。</p>\n<p>关于这一点，我有计划加入开源统计系统。</p>\n<blockquote><p>我希望是一款<strong>不会侵犯用户隐私</strong>、<strong>不收集用户指纹信息</strong>的统计系统，目前考虑 <a href=\"https://umami.is/\">umami</a>.</p></blockquote>\n<h2>\n<a href=\"https://blog.yfun.top/#%E6%9C%AA%E6%9D%A5\" class=\"headerlink\" title=\"未来\"></a>未来</h2>\n<p>我希望有时间可以重构这个 Blog，计划使用 <code>Vue 3 + Nuxt.js + TypeScript</code>。当然，这只是个计划。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E6%9B%B4%E5%A4%9A\" class=\"headerlink\" title=\"更多\"></a>更多</h2>\n<p>这个世界变化太快，我们生活中的每一秒都是在见证历史。</p>\n<p>2022 已经过去，欢迎 2023 的到来，希望新的一年中，一切会变得更好。</p>\n","link":"https://blog.yfun.top/posts/2023/"},{"title":"阿尔卑斯的夏与冬：瑞士双游记","date":"2022-12-28 03:05:20","description":"在种种机缘巧合之下，今年我有幸在夏天和冬天两次前往瑞士，并分别在在阿尔卑斯山的少女峰和马特洪峰的脚下度过了三天 […]","link":"https://flyhigher.top/diary/2639.html"},{"title":"Clerc：一个轻量但强大的命令行框架","date":"2022-12-21 11:10:52","description":"\n<blockquote>\n<p>TODO</p>\n</blockquote>\n<p>Clerc项目地址：<a href=\"https://github.com/so1ve/clerc\">https://github.com/so1ve/clerc</a></p>\n<p>感觉Clerc写的很牛逼啊，啥功能都有（大嘘</p>\n<p>功能列表：</p>\n<ul>\n<li>插件化</li>\n<li>高度可定制</li>\n<li>高度解耦，功能大部分可通过插件实现</li>\n<li>链式API</li>\n<li>子命令 + 嵌套命令</li>\n<li>可切换的单命令 / 多命令模式</li>\n<li>自动映射参数</li>\n<li>强类型参数、Flag</li>\n<li>把Flag转换为驼峰命名</li>\n<li>通过<a href=\"https://github.com/so1ve/clerc/tree/main/packages/plugin-help\">plugin-help</a>实现自动生成的帮助</li>\n<li>通过<a href=\"https://github.com/so1ve/clerc/tree/main/packages/plugin-completions\">plugin-completions</a>实现自动补全</li>\n<li>通过<a href=\"https://github.com/so1ve/clerc/tree/main/packages/plugin-not-found\">plugin-not-found</a>实现在命令未找到的时候给出最接近的命令（即<code>Did you mean</code>）</li>\n<li>通过<a href=\"https://github.com/so1ve/clerc/tree/main/packages/plugin-version\">plugin-version</a>实现输出版本的命令，及传入<code>--version</code>或<code>-V</code>（可自定义）时输出版本号</li>\n<li>通过<a href=\"https://github.com/so1ve/clerc/tree/main/packages/plugin-strict-flags\">plugin-strict-flags</a>实现在传入多余 / 未定义参数时报错</li>\n<li>通过<a href=\"https://github.com/so1ve/clerc/tree/main/packages/plugin-friendly-error\">plugin-friendly-error</a>实现错误自动美化输出</li>\n<li>以及强大的<a href=\"https://github.com/so1ve/clerc/tree/main/packages/toolkit\">toolkit</a>（也就是重新导出了一下几个好用的CLI工具（bushi</li>\n<li>等等等等……</li>\n</ul>\n<h1>安装</h1>\n<pre><code class=\"language-bash\">$ npm install clerc -S\n$ yarn add clerc\n$ pnpm add clerc\n</code></pre>\n<h1>使用</h1>\n<p>下面是一个最简单的命令：</p>\n<pre><code class=\"language-ts\">import { Clerc } from \"clerc\";\n\nconst cli = Clerc.create()\n  .name(\"foo-cli\")\n  .description(\"A simple cli\")\n  .version(\"1.0.0\")\n  .command(\"foo\", \"A foo command\")\n  .on(\"foo\", (ctx) =&gt; {\n    console.log(ctx);\n  })\n  .parse();\n</code></pre>\n<p>这么几行代码它做了些什么事呢（？）让我们来分析下罢</p>\n<p><code>Clerc.create()</code>：没啥好说的，字面意义，创建一个新的Clerc实例</p>\n<p><code>cli.name()</code>，<code>cli.description()</code>，<code>cli.version()</code>：也都是字面意思，分别设置CLI的名称，描述和版本。注意这三个方法是必须调用的，否则会报错=v=</p>\n<p><code>cli.command()</code>：这个方法说是Clerc中最重要的方法也不为过，它负责注册命令。它接受1~3个参数。</p>\n<ul>\n<li>2~3个参数形式：<code>cli.command(name, description, options?)</code>。其中options的类型为：</li>\n</ul>\n<pre><code class=\"language-ts\">type CommandOptions = {\n  alias?: string | string[]\n  parameters?: string[]\n  flags?: Record&lt;string, FlagOptions&gt;\n  examples?: [string, string][]\n  notes?: string[]\n}\n</code></pre>\n<p><code>alias</code>为一个字符串或一个字符串列表，即该命令的别名</p>\n<p><code>parameters</code>为一个字符串列表，即该命令的参数，格式为<code>&lt;foo&gt;</code>（必选参数），<code>[foo]</code>（可选参数），<code>&lt;foo...&gt;</code>（必选展开参数）或<code>[foo...]</code>（可选展开参数）。注意可选参数必须在必选参数后，展开参数必须在非展开参数后</p>\n<p><code>flags</code>为命令接受的Flag，一个对象。这个东西我们之后再说</p>\n<p><code>examples</code>为该命令的示例，为一个字符串双层数组，每个元素的格式为<code>[命令示范, 描述]</code>。</p>\n<p><code>notes</code>为该命令的一些提示。</p>\n<ul>\n<li>单个参数形式：<code>cli.command(commandObject)</code>。这里的commandObject的类型就是上面提到的options类型再加上<code>name</code>和<code>description</code>两个字段，以及一个<code>handler</code>字段（下面会讲）。为什么要添加一个这么奇怪的形式来注册命令呢？有时你不想把命令都写在一个文件里，这样子可以方便地注册命令。</li>\n</ul>\n<p><code>cli.on(name, handler)</code>：当某命令被触发时调用handler。handler的签名为<code>(ctx) =&gt; void</code>。其中ctx</p>\n<p>算了之后再写，好烦</p>\n","link":"https://blog.mk1.io/posts/hey-clerc"},{"title":"什么年代还在用传统 Pjax? —— 自定义 Pjax 提升页面加载速度","date":"2022-12-15 04:30:00","description":"\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%89%8D%E8%A8%80\" class=\"headerlink\" title=\"前言\"></a>前言</h2>\n<p>Hexo 属于静态博客，很多同学给自己的博客加上 Pjax 是为了音乐播放器等功能不中断。</p>\n<p>之前我也想过对博客和主题加入 Pjax 支持，但经过一番分析后觉得，这不仅引入了一个巨大的 <code>jquery.pjax.js</code>，反而优化效果不明显。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%8E%9F%E7%90%86\" class=\"headerlink\" title=\"原理\"></a>原理</h2>\n<p>其实，Pjax 的原理并不复杂。或许说，README 一开始就告诉你了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pjax = pushState + ajax</span><br></pre></td></tr></table></figure><p>其中 <code>ajax</code> 用于页面的新内容，<code>pushState</code> 改变浏览器状态。</p>\n<p>很简单吧。</p>\n<p>事实上，<code>pjax</code> 并不应该应用于整个页面当中。而应该只是局部更改。</p>\n<p>这样，Blog 当中的导航栏、样式文件等就不需要重复下载与预览。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%88%86%E6%9E%90\" class=\"headerlink\" title=\"分析\"></a>分析</h2>\n<p>以我使用 Miracle 为主题的博客为例，进入首页，按 <code>F12</code> 查看页面 Elements.</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.18/rawimg/2022-12-15_12-32-37.png\"></p>\n<p>可以发现，页面主要更改的也就是 <code>#page-main</code> 部分，只需要实现动态刷新这部分的内容就可以了。</p>\n<p>那怎么实现呢？</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E6%9C%80%E5%B0%8F%E5%8C%96%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3\" class=\"headerlink\" title=\"最小化的数据接口\"></a>最小化的数据接口</h2>\n<p>现在生成的页面当中，有 <code>&lt;head&gt;</code> 部分声明大量样式与元信息，<code>&lt;body&gt;</code> 之下重复的页脚、导航栏，还有每个页面下方都有的一些 <code>&lt;script&gt;</code>。</p>\n<p>很明显，我们不需要这些。我们只要 <code>#page-main</code> 中的主要内容。</p>\n<p>最重要的是，Hexo 是静态博客，这一点只能在生成文件时进行。</p>\n<h3>\n<a href=\"https://blog.yfun.top/#%E8%BD%BD%E5%85%A5-HTML\" class=\"headerlink\" title=\"载入 HTML\"></a>载入 HTML</h3>\n<p>我是用 Cheerio 模块帮我完成这一工作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">'cheerio'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">\"path\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> filePath = path.resolve(<span class=\"string\">'public/'</span>);</span><br></pre></td></tr></table></figure><p>定义一个 <code>parse function</code>，打开文件并解析相关信息，顺便把不是 HTML 的文件排除掉。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> parse = <span class=\"function\">(<span class=\"params\">filename, fullpath</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 不是 .html 我不要</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!filename.endsWith(<span class=\"string\">\".html\"</span>)) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><p>然后通过 Cheerio 解析 HTML:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">{...</span><br><span class=\"line\">  <span class=\"comment\">// 组合新文件名</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> filepath = fullpath+<span class=\"string\">\".page.json\"</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 读取文件内容</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> pageContent = fs.readFileSync(fullpath).toString();</span><br><span class=\"line\">  <span class=\"comment\">// 解析页面内容</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> $pg = cheerio.load(pageContent);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rtData = {};</span><br><span class=\"line\">...}</span><br></pre></td></tr></table></figure><p>然后获取页面的标题和 <code>#page-main</code> 下的 HTML.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">{...</span><br><span class=\"line\"><span class=\"comment\">// 页面标题</span></span><br><span class=\"line\">    rtData.title = $pg(<span class=\"string\">\"title\"</span>).text();</span><br><span class=\"line\">    <span class=\"comment\">// OR $pg(\"#page-main\").html()</span></span><br><span class=\"line\">    <span class=\"comment\">// 我这么写是因为主题 #page-main 下还有 script 无法执行</span></span><br><span class=\"line\">    rtData.page = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=\"mg-top\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        <span class=\"subst\">${$pg(<span class=\"string\">\".mg-top\"</span>).html() || <span class=\"string\">\"\"</span>}</span></span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;footer class=\"text-center\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        <span class=\"subst\">${$pg(<span class=\"string\">\"footer\"</span>).html() || <span class=\"string\">\"\"</span>}</span></span></span><br><span class=\"line\"><span class=\"string\">    &lt;/footer&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div class=\"p-btn\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">        <span class=\"subst\">${$pg(<span class=\"string\">\".p-btn\"</span>).html() || <span class=\"string\">\"\"</span>}</span></span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span>;</span><br><span class=\"line\">    rtData.path = filename;</span><br><span class=\"line\">...}</span><br></pre></td></tr></table></figure><p>页面中还有一些 <code>script</code>，比如阅读进度、懒加载等。所以需要一个 <code>extraJS</code> 放置额外的 Script.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">{...</span><br><span class=\"line\">    rtData.extraJS = []</span><br><span class=\"line\">    <span class=\"comment\">// 只解析 #page-main 下的 script</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> $pageMain = cheerio.load($pg(<span class=\"string\">\"#page-main\"</span>).html());</span><br><span class=\"line\">    $pageMain(<span class=\"string\">'script'</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i, el</span>) </span>{</span><br><span class=\"line\">        <span class=\"comment\">// 尝试往 extraJS 中 push 相关代码</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> {rtData.extraJS.push($pageMain(<span class=\"built_in\">this</span>)[<span class=\"number\">0</span>].children[<span class=\"number\">0</span>].data);} <span class=\"keyword\">catch</span>(e) {}</span><br><span class=\"line\">        $pageMain(<span class=\"built_in\">this</span>).remove();</span><br><span class=\"line\">    });</span><br><span class=\"line\">...}</span><br></pre></td></tr></table></figure><p>最后，将 JSON 写入文件中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">{...</span><br><span class=\"line\">    fs.writeFileSync(filepath, <span class=\"built_in\">JSON</span>.stringify(rtData));</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><h3>\n<a href=\"https://blog.yfun.top/#%E6%96%87%E4%BB%B6%E9%80%92%E5%BD%92\" class=\"headerlink\" title=\"文件递归\"></a>文件递归</h3>\n<p>我们还需要一个函数递归 <code>public</code> 目录下的所有文件，这个不用多说。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fileDisplay</span>(<span class=\"params\">filePath</span>) </span>{</span><br><span class=\"line\">    <span class=\"comment\">// 根据文件路径读取文件，返回文件列表</span></span><br><span class=\"line\">    fs.readdir(filePath, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, files</span>) </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) {</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.warn(err, <span class=\"string\">\"读取文件夹错误！\"</span>)</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"comment\">// 遍历读取到的文件列表</span></span><br><span class=\"line\">            files.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">filename</span>) </span>{</span><br><span class=\"line\">                <span class=\"comment\">// 获取当前文件的绝对路径</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> filedir = path.join(filePath, filename);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> fullname = filedir.split(<span class=\"string\">\"public\"</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">                fs.stat(filedir, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eror, stats</span>) </span>{</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (eror) {</span><br><span class=\"line\">                        <span class=\"built_in\">console</span>.warn(<span class=\"string\">'获取文件 Stats 失败!'</span>);</span><br><span class=\"line\">                    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                        <span class=\"keyword\">var</span> isFile = stats.isFile(); <span class=\"comment\">// 是文件</span></span><br><span class=\"line\">                        <span class=\"keyword\">var</span> isDir = stats.isDirectory(); <span class=\"comment\">// 是文件夹</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (isFile) {</span><br><span class=\"line\">                            parse(fullname, filedir);</span><br><span class=\"line\">                        }</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (isDir) {</span><br><span class=\"line\">                            fileDisplay(filedir); <span class=\"comment\">// 递归，如果是文件夹，就继续遍历该文件夹下面的文件</span></span><br><span class=\"line\">                        }</span><br><span class=\"line\">                    }</span><br><span class=\"line\">                });</span><br><span class=\"line\">            });</span><br><span class=\"line\">        }</span><br><span class=\"line\">    });</span><br><span class=\"line\">}</span><br><span class=\"line\">fileDisplay(filePath);</span><br></pre></td></tr></table></figure><p>最后运行这个 Node.js 文件，就可以看到 <code>public/</code> 目录下多出很多 <code>***.page.json</code> 文件。</p>\n<h3>\n<a href=\"https://blog.yfun.top/#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h3>\n<p>这些文件内容也很简单，基本如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"comment\">// 页面的标题</span></span><br><span class=\"line\">    <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Hello World\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 内容</span></span><br><span class=\"line\">    <span class=\"attr\">\"page\"</span>: <span class=\"string\">\"...\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 路径</span></span><br><span class=\"line\">    <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"/foo/bar\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">// JS</span></span><br><span class=\"line\">    <span class=\"attr\">\"extraJS\"</span>: ['alert(<span class=\"string\">\"Hello World\"</span>);']</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><h2>\n<a href=\"https://blog.yfun.top/#%E5%89%8D%E7%AB%AF-pjax-js\" class=\"headerlink\" title=\"前端 pjax.js\"></a>前端 <code>pjax.js</code>\n</h2>\n<p>新建一个 <code>pjax.js</code>。</p>\n<h3>\n<a href=\"https://blog.yfun.top/#%E6%9B%BF%E6%8D%A2%E9%93%BE%E6%8E%A5\" class=\"headerlink\" title=\"替换链接\"></a>替换链接</h3>\n<p>我们需要先将页面当中所有本站链接转为 Pjax 的 Jump 函数。</p>\n<p>判断条件是：有链接，不带 hash，且为本站链接</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 转换页面中的链接为 Pjax 链接</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> $pjax_convertAllLinks = <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\"><span class=\"comment\">// 所有的 a 标签</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> linkElements = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> linkElements) {</span><br><span class=\"line\">        <span class=\"comment\">// 有链接，不带 hash，且为本站链接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i.href &amp;&amp; !i.href.includes(<span class=\"string\">\"/#\"</span>) &amp;&amp; (i.href.startsWith(<span class=\"string\">\"/\"</span>) || i.href.match(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"built_in\">window</span>.location.hostname)))) {</span><br><span class=\"line\">            <span class=\"keyword\">let</span> thisLink = <span class=\"keyword\">new</span> URL(i.href).pathname+<span class=\"keyword\">new</span> URL(i.href).hash;</span><br><span class=\"line\">            i.href = <span class=\"string\">`javascript:$pjax_jump('<span class=\"subst\">${thisLink}</span>');`</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><p>另外，要转化页面链接为全路径。</p>\n<p>这里参考了下 ChenYFan 的 Service Worker 函数，需要根据实际情况做出调整。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 转换路径为全路径</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> $pjax_fullpath = <span class=\"function\">(<span class=\"params\">path</span>) =&gt;</span> {</span><br><span class=\"line\">    path = path.split(<span class=\"string\">'?'</span>)[<span class=\"number\">0</span>].split(<span class=\"string\">'#'</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path.match(<span class=\"regexp\">/\\/$/</span>)) {</span><br><span class=\"line\">        path += <span class=\"string\">'index.html'</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!path.match(<span class=\"regexp\">/\\.[a-zA-Z]+$/</span>)) {</span><br><span class=\"line\">        path += <span class=\"string\">'/index.html'</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> path;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $pjax_fullpath('/') =&gt; /index.html</span></span><br></pre></td></tr></table></figure><h3>\n<a href=\"https://blog.yfun.top/#%E8%B7%B3%E8%BD%AC\" class=\"headerlink\" title=\"跳转\"></a>跳转</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 跳转页面</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> $pjax_jump = <span class=\"keyword\">async</span> (path) =&gt; {</span><br><span class=\"line\">    <span class=\"keyword\">try</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 是 # 就别跳转了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.startsWith(<span class=\"string\">\"#\"</span>)) {</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.hash = path;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">// 加载动画</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> loading = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">        loading.innerHTML = <span class=\"string\">`&lt;div style=\"position: fixed;top:0;left:0;z-index:99999;display: block;width: 100%;height: 4px;overflow: hidden;background-color: rgba(63,81,181,.2);border-radius: 2px;\"&gt;&lt;div class=\"progress-indeterminate\" style=\"background-color: #3f51b5;\"&gt;&lt;/div&gt;&lt;style&gt;#page-main{transition:0.2s;}.progress-indeterminate::before{position:absolute;top:0;bottom:0;left:0;background-color:inherit;-webkit-animation:mdui-progress-indeterminate 2s linear infinite;animation:mdui-progress-indeterminate 2s linear infinite;content:' ';will-change:left,width;}.progress-indeterminate::after{position:absolute;top:0;bottom:0;left:0;background-color:inherit;-webkit-animation:mdui-progress-indeterminate-short 2s linear infinite;animation:mdui-progress-indeterminate-short 2s linear infinite;content:' ';will-change:left,width;}@keyframes mdui-progress-indeterminate{0%{left:0;width:0;}50%{left:30%;width:70%;}75%{left:100%;width:0;}}@keyframes mdui-progress-indeterminate-short{0%{left:0;width:0;}50%{left:0;width:0;}75%{left:0;width:25%;}100%{left:100%;width:0;}}&lt;/style&gt;&lt;/div&gt;`</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 在 body 后加入 &lt;div&gt;</span></span><br><span class=\"line\">        <span class=\"built_in\">document</span>.body.appendChild(loading);</span><br><span class=\"line\">        <span class=\"comment\">// 如果页面中没有 page.css 或 search.css，为防止样式错乱，需要在加载过程中隐藏页面内容</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"page_css\"</span>) || !<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"search_css\"</span>)) <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"page-main\"</span>).style.opacity = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 获取页面数据</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> pageData;</span><br><span class=\"line\">        <span class=\"comment\">// 看看 SessionStorage 里有没有缓存</span></span><br><span class=\"line\">        <span class=\"comment\">// 依赖后文的 prefetch</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sessionStorage.getItem(<span class=\"string\">`<span class=\"subst\">${location.protocol}</span>//<span class=\"subst\">${location.hostname}</span><span class=\"subst\">${location.port ? <span class=\"string\">\":\"</span>+location.port:location.port}</span><span class=\"subst\">${$pjax_fullpath(path)}</span>`</span>)) {</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"FROM SESSIONSTORAGE\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> {</span><br><span class=\"line\">                pageData = <span class=\"built_in\">JSON</span>.parse(sessionStorage.getItem(<span class=\"string\">`<span class=\"subst\">${location.protocol}</span>//<span class=\"subst\">${location.hostname}</span><span class=\"subst\">${location.port ? <span class=\"string\">\":\"</span>+location.port:location.port}</span><span class=\"subst\">${$pjax_fullpath(path)}</span>`</span>));</span><br><span class=\"line\">            } <span class=\"keyword\">catch</span>(e) {</span><br><span class=\"line\">                <span class=\"comment\">// 还是出错就从服务器获取</span></span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"FROM SERVER\"</span>);</span><br><span class=\"line\">                pageData = <span class=\"keyword\">await</span> fetch($pjax_fullpath(path) + <span class=\"string\">\".page.json\"</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.json());</span><br><span class=\"line\">                <span class=\"comment\">// 写到 SessionStorage 中</span></span><br><span class=\"line\">                sessionStorage.setItem(<span class=\"string\">`<span class=\"subst\">${location.protocol}</span>//<span class=\"subst\">${location.hostname}</span><span class=\"subst\">${location.port ? <span class=\"string\">\":\"</span>+location.port:location.port}</span><span class=\"subst\">${$pjax_fullpath(path)}</span>`</span>, <span class=\"built_in\">JSON</span>.stringify(pageData));</span><br><span class=\"line\">            }</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"FROM SERVER\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// fetch JSON</span></span><br><span class=\"line\">            pageData = <span class=\"keyword\">await</span> fetch($pjax_fullpath(path) + <span class=\"string\">\".page.json\"</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.json());</span><br><span class=\"line\">            sessionStorage.setItem(<span class=\"string\">`<span class=\"subst\">${location.protocol}</span>//<span class=\"subst\">${location.hostname}</span><span class=\"subst\">${location.port ? <span class=\"string\">\":\"</span>+location.port:location.port}</span><span class=\"subst\">${$pjax_fullpath(path)}</span>`</span>, <span class=\"built_in\">JSON</span>.stringify(pageData));</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">// 补齐页面 CSS</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"search_css\"</span>)) {</span><br><span class=\"line\">            fetch(<span class=\"string\">\"/css/search.css\"</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.text()).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">                <span class=\"keyword\">let</span> ele = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"style\"</span>);</span><br><span class=\"line\">                ele.innerHTML = res;</span><br><span class=\"line\">                ele.id = <span class=\"string\">\"search_css\"</span>;</span><br><span class=\"line\">                <span class=\"built_in\">document</span>.body.appendChild(ele);</span><br><span class=\"line\">            });</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"page_css\"</span>)) {</span><br><span class=\"line\">            fetch(<span class=\"string\">\"/css/page.css\"</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.text()).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">                <span class=\"keyword\">let</span> ele = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"style\"</span>);</span><br><span class=\"line\">                ele.innerHTML = res;</span><br><span class=\"line\">                ele.id = <span class=\"string\">\"page_css\"</span>;</span><br><span class=\"line\">                <span class=\"built_in\">document</span>.body.appendChild(ele);</span><br><span class=\"line\">            });</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!pageData) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 组合 state</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> state = { <span class=\"attr\">title</span>: <span class=\"string\">''</span>, <span class=\"attr\">url</span>: <span class=\"built_in\">window</span>.location.href.split(<span class=\"string\">\"?\"</span>)[<span class=\"number\">0</span>] };</span><br><span class=\"line\">        <span class=\"comment\">// 利用 history.pushState() 修改地址栏而不跳转</span></span><br><span class=\"line\">        history.pushState(state, <span class=\"string\">''</span>, path);</span><br><span class=\"line\">        <span class=\"comment\">// 修改页面标题</span></span><br><span class=\"line\">        <span class=\"built_in\">document</span>.title = pageData.title;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">            <span class=\"comment\">// 滚动到页面顶部</span></span><br><span class=\"line\">            <span class=\"built_in\">window</span>.scrollTo({<span class=\"attr\">top</span>: <span class=\"number\">0</span>, <span class=\"attr\">behavior</span>: <span class=\"string\">\"smooth\"</span>});</span><br><span class=\"line\">            <span class=\"comment\">// 写入 HTML</span></span><br><span class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"page-main\"</span>).innerHTML = pageData.page;</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.onscroll = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> pageData.extraJS) {</span><br><span class=\"line\">                <span class=\"keyword\">try</span> {</span><br><span class=\"line\">                    <span class=\"comment\">// eval() 执行 JS</span></span><br><span class=\"line\">                    <span class=\"built_in\">eval</span>(pageData.extraJS[i]);</span><br><span class=\"line\">                } <span class=\"keyword\">catch</span>(e) {}</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">try</span>{$pjax_prefetch();}<span class=\"keyword\">catch</span>(e){}</span><br><span class=\"line\">            <span class=\"comment\">// 再次转换所有链接</span></span><br><span class=\"line\">            $pjax_convertAllLinks();</span><br><span class=\"line\">        }, <span class=\"number\">200</span>);</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">            <span class=\"comment\">// 重新显示页面</span></span><br><span class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"page-main\"</span>).style.opacity = <span class=\"number\">1</span>;</span><br><span class=\"line\">            loading.remove();</span><br><span class=\"line\">        }, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    } <span class=\"keyword\">catch</span>(e) {</span><br><span class=\"line\">        <span class=\"comment\">// 有报错 直接跳转</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.warn(e);</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.location.href = path;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><p>如果使用 <code>window.location.href</code> 修改，那么页面就会刷新。<br>为了实现无刷新跳转，必须要使用 <code>pushState()</code> 更改。</p>\n<p>执行 JavaScript 方面使用 <code>eval()</code> 函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组合 state</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> state = { <span class=\"attr\">title</span>: <span class=\"string\">''</span>, <span class=\"attr\">url</span>: <span class=\"built_in\">window</span>.location.href.split(<span class=\"string\">\"?\"</span>)[<span class=\"number\">0</span>] };</span><br><span class=\"line\"><span class=\"comment\">// 利用 history.pushState() 修改地址栏而不跳转</span></span><br><span class=\"line\">history.pushState(state, <span class=\"string\">''</span>, path);</span><br><span class=\"line\"><span class=\"comment\">// 修改页面标题</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.title = pageData.title;</span><br><span class=\"line\"><span class=\"comment\">// 滚动到页面顶部</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.scrollTo({<span class=\"attr\">top</span>: <span class=\"number\">0</span>, <span class=\"attr\">behavior</span>: <span class=\"string\">\"smooth\"</span>});</span><br><span class=\"line\"><span class=\"comment\">// 写入 HTML</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"page-main\"</span>).innerHTML = pageData.page;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onscroll = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> pageData.extraJS) {</span><br><span class=\"line\">  <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    <span class=\"comment\">// eval() 执行 JS</span></span><br><span class=\"line\">    <span class=\"built_in\">eval</span>(pageData.extraJS[i]);</span><br><span class=\"line\">  } <span class=\"keyword\">catch</span>(e) {}</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><h3>\n<a href=\"https://blog.yfun.top/#Prefetch-amp-Refetch\" class=\"headerlink\" title=\"Prefetch &amp; Refetch\"></a>Prefetch &amp; Refetch</h3>\n<p>此处借鉴乐特关于 Prefetch Page 的源码，当用户打开节流模式或为低速网络时就不要 Prefetch.</p>\n<p>Prefetch 可以提前缓存部分数据。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> $pjax_prefetch = <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 节流和低速网络不要 Prefetch</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> nav = navigator;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> { saveData, effectiveType } = nav.connection || nav.mozConnection || nav.webkitConnection || {};</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (saveData || <span class=\"regexp\">/2g/</span>.test(effectiveType)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 此处是 Blog 的一些常见链接</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> posts_list = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\".index-header a\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> posts_list) {</span><br><span class=\"line\">        <span class=\"comment\">// 全路径</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> thisLink = $pjax_fullpath(posts_list[i].href);</span><br><span class=\"line\">        <span class=\"comment\">// Session Storage 没有才 Fetch</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!sessionStorage.getItem(thisLink)) {</span><br><span class=\"line\">            fetch(thisLink + <span class=\"string\">\".page.json\"</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.text()).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">                sessionStorage.setItem(thisLink,res);</span><br><span class=\"line\">            });</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><p>Refetch 用于刷新已有的缓存（虽然 <code>SessionStorage</code> 关闭页面就没了）</p>\n<p>其原理也很简单，<code>SessionStorage</code> 中所有的 Pjax 缓存重新获取就完事了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> $pjax_refetch = <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sst = sessionStorage;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> sst) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i.startsWith(<span class=\"string\">\"http://\"</span>) || i.startsWith(<span class=\"string\">\"https://\"</span>)) {</span><br><span class=\"line\">            fetch(i + <span class=\"string\">\".page.json\"</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.text()).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">                sessionStorage.setItem(i, res);</span><br><span class=\"line\">            });</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><h3>\n<a href=\"https://blog.yfun.top/#%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96\" class=\"headerlink\" title=\"一些优化\"></a>一些优化</h3>\n<h4>\n<a href=\"https://blog.yfun.top/#Prefetch-CSS-%E6%96%87%E4%BB%B6\" class=\"headerlink\" title=\"Prefetch CSS 文件\"></a>Prefetch CSS 文件</h4>\n<p>既然 CSS 文件需要补齐，那么打开页面 5s 后自动 Prefetch 可以提升速度。</p>\n<blockquote><p>5s 后再获取是为了防止阻塞页面。</p></blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"comment\">// Prefetch CSS 文件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"search_css\"</span>)) {</span><br><span class=\"line\">        fetch(<span class=\"string\">\"/css/search.css\"</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.text()).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">            <span class=\"keyword\">let</span> ele = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"style\"</span>)</span><br><span class=\"line\">            ele.innerHTML = res;</span><br><span class=\"line\">            ele.id = <span class=\"string\">\"search_css\"</span>;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.body.appendChild(ele);</span><br><span class=\"line\">        });</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"page_css\"</span>)) {</span><br><span class=\"line\">        fetch(<span class=\"string\">\"/css/page.css\"</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.text()).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">            <span class=\"keyword\">let</span> ele = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"style\"</span>)</span><br><span class=\"line\">            ele.innerHTML = res;</span><br><span class=\"line\">            ele.id = <span class=\"string\">\"page_css\"</span>;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.body.appendChild(ele);</span><br><span class=\"line\">        });</span><br><span class=\"line\">    }    </span><br><span class=\"line\">}, <span class=\"number\">5000</span>);</span><br></pre></td></tr></table></figure><h4>\n<a href=\"https://blog.yfun.top/#%E5%85%B3%E4%BA%8E-Robots\" class=\"headerlink\" title=\"关于 Robots\"></a>关于 Robots</h4>\n<p>当你运行 <code>$pjax_convertAllLinks();</code> 后，你肯定会发现所有的链接都变成了 <code>javascript:$pjax_jump('/xxx');</code>。这对机器人来说很不友好。</p>\n<p>所以，我们需要排除这些机器人。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> runningOnBrowser = <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">\"undefined\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> isBot = runningOnBrowser &amp;&amp; !(<span class=\"string\">\"onscroll\"</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>) || <span class=\"keyword\">typeof</span> navigator !== <span class=\"string\">\"undefined\"</span> &amp;&amp; <span class=\"regexp\">/(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i</span>.test(navigator.userAgent);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (runningOnBrowser &amp;&amp; !isBot) {</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"keyword\">try</span>{$pjax_prefetch();}<span class=\"keyword\">catch</span>(e){}</span><br><span class=\"line\">        $pjax_convertAllLinks();</span><br><span class=\"line\">    }, <span class=\"number\">100</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><h2>\n<a href=\"https://blog.yfun.top/#%E6%9C%80%E5%90%8E\" class=\"headerlink\" title=\"最后\"></a>最后</h2>\n<p>在启用 Pjax 后，YFun's Blog 传输大小理论上最高缩小 3/4，性能速度均有提升。</p>\n<p>如果你也在使用 Pjax，不妨试试看。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E8%BF%98%E6%9C%89%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF\" class=\"headerlink\" title=\"还有一些错误\"></a>还有一些错误</h2>\n<p>如果你定义了 <code>onload</code> 等事件，页面没有刷新即代表没有变化，你需要在 <code>$pjax_jump()</code> 中简单清除一下这些信息。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%B9%BF%E5%91%8A%E6%97%B6%E9%97%B4\" class=\"headerlink\" title=\"广告时间\"></a>广告时间</h2>\n<p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a href=\"https://cloud.tencent.com/developer/support-plan?invite_code=16qkaef2qdvzm\">https://cloud.tencent.com/developer/support-plan?invite_code=16qkaef2qdvzm</a></p>\n","link":"https://blog.yfun.top/posts/2022/pjax/"},{"title":"无服务器动态博客系统Dolan：从设想到现实","date":"2022-12-06 05:40:58","description":"\n<h1>起因</h1>\n<p>本站最早于 2020 年建立。当时正值网课时期，我就想着搭建一个博客记录一下自己的编程 / 学习过程。一路磕磕绊绊，尝试了多种不同的博客系统：</p>\n<ol>\n<li>免费的 WordPress 部署平台（三蛋host），不过其国内访问速度实在不尽人意，<del>承诺SLA为0%</del>，同时还在网站中强制添加广告，这换谁不跑路啊；</li>\n<li>Hexo，一个静态博客生成器，目前使用人数十分庞大，同时有丰富的插件，是一个比较理想的博客系统。但是Hexo的坑实在是太多了，经常碰到因为Node版本过高 / 过低引起的问题<del>虽然用一个fnm就能解决</del>，同时生成速度在插件多了之后直线下滑，完全无法接受，遂弃用；</li>\n<li>Gridea，一个国人做的带GUI静态博客系统，好用，但是可拓展性不高，主题也不是很丰富，用了一段时间后也抛弃了；</li>\n<li>Hugo，一个用Go编写的静态网站生成器，生成速度很快，同时也具有插件系统与强大的自定义功能，是我使用时间最长的博客系统。</li>\n</ol>\n<p>使用Hugo搭建的博客是存活时间最长的。我一共尝试了两个主题：<a href=\"https://github.com/reuixiy/hugo-theme-meme\">MemE</a>，以及自己移植的<a href=\"https://github.com/ThemeTony/hugo-theme-tony\">Tony</a>。这套配置的易用性极高，同时高度可定制化，生成速度也十分令人满意。但是<del>人心不足蛇吞象</del>，有了一个能用的博客，没地方折腾了，怎么办呢？首先想到的一个优化点就是在线编辑文章。在本地 / 云端编辑固然好，还能实时预览，但难免受到开发环境的影响。</p>\n<p>有一个轻量级的解决方案是以<a href=\"https://github.com/HexoPlusPlus/HexoPlusPlus\">HexoPlusPlus</a>、<a href=\"https://github.com/Wexagonal/Wexagonal\">Wexagonal</a>、<a href=\"https://github.com/Qexo/Qexo\">Qexo</a>等为代表的在线编辑器（不是开发环境）。这一类项目的特点是<strong>基于Github API</strong>、<strong>无服务器</strong>，通过前端的富文本预览，然后再利用Github API上传博客源文件，从而模拟出一个在线编辑文章的环境，配合上集成部署实时生成网页，能够满足极大部分下的使用场景。不过，它们的适配对象都是Hexo，Hugo怎么办呢？？理论上，在这些项目上添加支持也不难，但CYF和Abudu写的代码确实<del>屎山</del>质量不高，难不成自己再造一个轮子？？？</p>\n<p><strong>好吧，确实去造轮子了（）</strong> 既然造了轮子，那我们就造个大的，直接造个博客系统罢！</p>\n<h1>选型</h1>\n<p>由于我们要做的是一个无服务器的博客系统，由于运行环境的限制（诸如性能、FS），我们无法做到上传主题、实时更改主题、从模板渲染等操作。同时，我们最好做到前后端分离，让每个部分各司其职，发挥最高的效能：比如后台就没必要和API捆绑在一起，可以独立部署；前端也如此。那我们的项目大体结构如下：</p>\n<ol>\n<li>API，提供数据支持。部署在Serverless上。</li>\n<li>后台，提供管理页面。静态网页，部署在哪都行。</li>\n<li>前端，用户访问界面。理论上可以是一个SPA，也可以进行服务端渲染，这个看自己有没有SEO需求了。</li>\n</ol>\n<p>API最初的技术栈是Node（Koa），打算部署在Vercel上。但是Vercel的Node运行时速度实在感人，常常超时，遂放弃。</p>\n<p>后面我了解到Deno背后的公司<a href=\"https://deno.com/\">Deno Land Inc.</a>推出了一个在线部署服务，叫做Deno Deploy，可以将Deno项目部署到云端，同时节点众多，访问速度理想；其又针对Deno进行了大量的优化，性能极高。于是，API的技术栈就定为了Deno（Oak）。</p>\n<blockquote>\n<p>这里插一个题外话，Oak是一个受到Koa启发而创建的Deno HTTP框架，二者API基本相同，可以毫不费力地把Koa项目迁移过去。</p>\n</blockquote>\n<p>随后是后台。后台的开发过程稍显曲折，最开始的技术栈是Vue3 + Quasar，但是Quasar的API稍显不足，许多功能都需要自己手动实现。后面看到抖音开源了一个<a href=\"https://github.com/DouyinFE/semi-design\">SemiUI</a>，说实话，挺漂亮的，于是捣鼓了很久，把完成了一半的后台迁移到了React。技术栈为：React + SemiUI + UnoCSS。</p>\n<p>最后，是前端。写前端我的第一反应是使用一个SSR框架，即Nuxt / Next，但Next貌似支持的Serverless平台并不丰富，同时Nuxt3声称基于Nitro原生支持多平台（其中就包括Deno Deploy）。卧槽这不得给他冲爆，技术栈为Nuxt3，移植了一个<a href=\"https://github.com/reuixiy/hugo-theme-meme\">hugo-theme-meme</a>。</p>\n<p>当然，前端并非只能使用我做的这个<a href=\"https://github.com/so1ve/dolan-client-meme\">dolan-client-meme</a>。由于其本质只是从API获取数据并渲染（这也是为什么它叫做client而不是theme的原因），因此任何人都能够做自己的client。</p>\n<blockquote>\n<p>再插个嘴：目前Nuxt3和Nitro对Deno Deploy的支持并没有在文档中体现出来，不过Nitro已经有了对它的初步支持。我发起了一个<a href=\"https://github.com/unjs/nitro/pull/694\">PR</a>（目前已经合并）来修复一些bug，但目前包含这个Commit的版本还没发布，因此我自己先发布了一个包（<a href=\"https://www.npmjs.com/package/@so1ve/nitropack\">@so1ve/nitropack</a>）暂时用着，同时做了一些黑魔法，见<a href=\"https://github.com/so1ve/dolan-client-meme/blob/main/src/rollup-plugins/deno-fix.ts\">dolan-client-meme/deno-fix.ts</a>。</p>\n</blockquote>\n<h1>开发</h1>\n<h2>API</h2>\n<p>众所周知，开发初期搭建项目结构是最搞人心态的一件事了……不过好在Deno所需的配置并不多，最多就是<code>import_map.json</code>、<code>deno.jsonc</code>两个配置文件。同时Oak也是一个很轻量级的框架，因此主要的目录结构如下：</p>\n<pre><code>│   .env\n│   .gitignore\n│   config.ts\n│   deno.jsonc\n│   deno.lock\n│   import_map.json\n│   LICENSE\n│   README.md\n├───.vscode\n├───src\n│   ├───protected_routes.ts\n│   ├───server.ts\n│   └───unprotected_routes.ts\n│\n└───────controller\n    ├───lib\n    │   └───init_values\n    ├───middleware\n    ├───types\n    └───utils\n</code></pre>\n<p>其中两个<code>*_routes.ts</code>结尾的文件是路由文件，分为需要登录 / 不需要登录的两组路由。</p>\n<h2>后台</h2>\n<p>后台的UI前面已经说过选择了SemiUI，迎面而来的还有另一个问题：Markdown编辑器选什么呢？我考虑了以下几个编辑器：</p>\n<ul>\n<li><a href=\"https://milkdown.dev/\">Milkdown</a></li>\n<li><a href=\"https://bytemd.js.org/\">ByteMD</a></li>\n<li><a href=\"https://github.com/kkfor/for-editor\">for-editor</a></li>\n<li><a href=\"https://github.com/uiwjs/react-markdown-editor\">react-markdown-editor</a></li>\n</ul>\n<p>后面两个首先出局，for-editor界面古早而且很久没更新，react-markdown-editor倒是挺活跃，不过它的功能不多而且不能通过插件扩展功能，于是放弃。</p>\n<p>为什么最后选择了Milkdown而不是ByteMD呢？<del>嗯我也不太清楚为什么，到后面想重构一下换成ByteMD发现工作量挺大的，于是搁置了（）</del> 主要原因是ByteMD默认会对HTML内容进行序列化，无法在文章中直接插入HTML，但是Milkdown@7则支持插入HTML。</p>\n<p>然后是配置编辑器 / MD第二编辑器，Monaco Editor，这个没啥好说的</p>\n<h2>前端</h2>\n<blockquote>\n<p>TODO</p>\n</blockquote>\n<h1>如何使用呢？</h1>\n<p>目前文档在<a href=\"https://dolan.js.org/\">https://dolan.js.org</a>，大家可以先看看</p>\n<blockquote>\n<p>TODO</p>\n</blockquote>\n","link":"https://blog.mk1.io/posts/hey-dolan"},{"title":"使用Scoop + 版本管理器科学地管理你的开发环境！","date":"2022-12-05 04:50:24","description":"\n<blockquote>\n<p>提示：这篇文章中有个小小的彩蛋（）</p>\n</blockquote>\n<p>管理开发环境是一门学问。你是否有过这样的经历：</p>\n<pre><code class=\"language-console\">$ node\nnode: The term 'node' is not recognized as a name of a cmdlet, function, script file, or executable program.\nCheck the spelling of the name, or if a path was included, verify that the path is correct and try again.\n</code></pre>\n<p><img src=\"https://static.mk1.io/img/202212191552965.jpg\" alt=\"\"></p>\n<p>很令人抓狂，对不对？这种问题一般是由不规范的PATH环境变量引起的，或是未添加，或是语法不对=v=</p>\n<p>这种问题可以被称之为“开发环境污染”，这时候你可能会听从别人的建议重装应用（甚至重装电脑），但是无济于事，于是放弃折腾了（）</p>\n<p>不过，今天我会告诉你，重装不是唯一的方法，也不是最有效的。这种问题的最终解决办法都是使用包管理器，包括Linux上的apt和yum ，MacOS上的<a href=\"https://brew.sh/\">Brew</a>，或者是Windows上的<a href=\"https://chocolatey.org/\">Chocolatey</a>和<a href=\"https://github.com/microsoft/winget-cli\">WinGet</a>，还有今天我们要介绍的主角：<a href=\"https://scoop.sh/\">Scoop</a>。</p>\n<h1>对比</h1>\n<p>上面写到，Win上的包管理器除了Scoop外还有Chocolatey和Winget，其中Chocolatey是老牌项目了，WinGet则是微软亲生的包管理器。</p>\n<p>奇怪，为什么放着老牌包管理器和官方包管理器不用，而去用Scoop呢？我们来对比一下：</p>\n<table>\n<thead><tr>\n<th align=\"center\"></th>\n<th align=\"center\">Winget</th>\n<th align=\"center\">Chocolatey</th>\n<th align=\"center\">Scoop</th>\n</tr></thead>\n<tbody>\n<tr>\n<td align=\"center\">是否为中心化</td>\n<td align=\"center\">是（Microsoft Store）</td>\n<td align=\"center\"><a href=\"https://chocolatey.org/\">是</a></td>\n<td align=\"center\">否</td>\n</tr>\n<tr>\n<td align=\"center\">是否有付费功能</td>\n<td align=\"center\">无</td>\n<td align=\"center\"><a href=\"https://chocolatey.org/pricing\">有</a></td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">包数量（截止2022/12/19）</td>\n<td align=\"center\">3966（通过<code>winget search \"\"</code>并统计行数得出）</td>\n<td align=\"center\">9521</td>\n<td align=\"center\">37793（官方 + 第三方源，可能有重复）</td>\n</tr>\n<tr>\n<td align=\"center\">发布方式</td>\n<td align=\"center\">编写Manifest并手动提交</td>\n<td align=\"center\">编写Manifest并手动提交</td>\n<td align=\"center\">编写Manifest并从bucket中获取，无需手动提交</td>\n</tr>\n<tr>\n<td align=\"center\">如何更新自己的包</td>\n<td align=\"center\">手动更新</td>\n<td align=\"center\">有GitHub Actions自动更新</td>\n<td align=\"center\">有GitHub Actions自动更新</td>\n</tr>\n<tr>\n<td align=\"center\">能否自定义运行安装脚本</td>\n<td align=\"center\">可以</td>\n<td align=\"center\">可以</td>\n<td align=\"center\">可以</td>\n</tr>\n</tbody>\n</table>\n<p>当然，以上的结果是带有我个人偏见的（大嘘）。Scoop完全开源，发布自己包的方式也最为简单（加一个json文件提交到GitHub上就行），可拓展性也是三者中最高的（有诸如<code>post_install</code>等钩子函数可在安装的前后运行脚本）。因此，我选择了Scoop，而不是Chocolatey，或者Winget。</p>\n<h1>安装</h1>\n<p>好了BB了那么多我们也应该进入正题力（）如何安装Scoop呢？<a href=\"https://scoop.sh/\">官网</a>给出了安装命令（先别急着运行）：</p>\n<pre><code class=\"language-powershell\">&gt; Set-ExecutionPolicy RemoteSigned -Scope CurrentUser\n&gt; irm get.scoop.sh | iex\n</code></pre>\n<p>Oh这里注意一下，安装脚本会从GitHub上拉取Scoop的最新版源代码，这就意味着我们可能会受到长城的制裁而无法正常安装（）相信大家都有办法解决对吧</p>\n<p>虽然这么安装Scoop很快也很省事，但是如果你的C盘并不充裕，我不推荐你使用上面的命令进行安装。为啥呢，因为默认的程序安装目录在C盘啊（悲）以下的脚本可以让你自定义安装目录：</p>\n<pre><code class=\"language-powershell\">&gt; irm get.scoop.sh -outfile 'install.ps1'\n&gt; .\\install.ps1 -ScoopDir 'D:/.scoop' -ScoopGlobalDir 'D:/.scoop-global'\n</code></pre>\n<p>其中<code>ScoopDir</code>和<code>ScoopGlobalDir</code>可以随便替换成两个不相同的目录。</p>\n<p>等待脚本执行完后，在终端里打个<code>scoop</code>看看吧：</p>\n<p><img src=\"https://static.mk1.io/img/202212191911358.png\" alt=\"\"></p>\n<p>如果你看到了以上内容，那么恭喜你，成功力（）先别急着装软件，我们再来了解些基本概念</p>\n<h1 title=\"只因本概念\">基本概念</h1>\n<p>Scoop中程序的信息是怎么被获取的呢？这就涉及到Manifest和Bucket这两个重要概念。</p>\n<p>其实理解起来也很简单，Bucket相当于是一个Manifest的合集，而Manifest则包含了一个软件的一些信息，比如安装包的URL啊，名称啊，版本、简介等等。默认情况下Scoop会把Main这个官方维护的Bucket拉取到本地（你也可以去拉一些别的Bucket，这个之后会说），其中包括了大量的开源软件。我们在运行<code>scoop install foo</code>的时候，Scoop都会去这些Bucket中寻找名称一致的Manifest，并从中获取软件安装包的链接，下载到本地进行安装。</p>\n<h1>使用</h1>\n<p>终于要到使用环节了吗，感动（）</p>\n<h2>Node</h2>\n<p>我们先来搭一个Node环境吧，这里我们会使用版本管理器<a href=\"https://github.com/Schniz/fnm\">fnm</a>。为什么不是n / nvm / nvs？fnm的一个重要特点就是模糊搜索，只需要给一个大版本号就能安装，同时其也是一个很新的项目，充满活力</p>\n<pre><code class=\"language-powershell\">&gt; scoop install fnm\n\nInstalling 'fnm' (1.31.1) [64bit] from main bucket\nfnm-x86_64-pc-windows-msvc.zip (4.5 MB) [==================================================================] 100%\nChecking hash of fnm-x86_64-pc-windows-msvc.zip ... ok.\nExtracting fnm-x86_64-pc-windows-msvc.zip ... done.\nLinking D:.scoop\\apps\\fnm\\current =&gt; D:.scoop\\apps\\fnm\\1.31.1\nCreating shim for 'fnm'.\n'fnm' (1.31.1) was installed successfully!\n\n&gt; fnm install --lts # 安装LTS版本的Node\nInstalling Node v18.12.1 (x64)\n\n&gt; fnm default 18 # 使用最新版\n</code></pre>\n<p>注意啦，安装了之后还不能直接使用。打开Powershell，执行：</p>\n<pre><code class=\"language-powershell\">&gt; notepad $PROFILE\n</code></pre>\n<p>在打开的记事本中添加：</p>\n<pre><code class=\"language-powershell\">fnm env --use-on-cd | Out-String | Invoke-Expression\n</code></pre>\n<p>这样子Node环境就搭好力（）</p>\n<h2>Rust</h2>\n<p>Rust的环境搭建也很简单啊：</p>\n<pre><code class=\"language-powershell\">&gt; scoop install rustup-msvc\n</code></pre>\n<p>就一行命令（）</p>\n<h2>Go</h2>\n<p>不废话，上代码</p>\n<pre><code class=\"language-powershell\">&gt; scoop install go\n</code></pre>\n<h2>别的工具……</h2>\n<p>有时自己需要的工具并不在Main Bucket中，这时候你试图执行<code>scoop install osulazer</code>时就会提醒你<code>Couldn't find manifest for 'osulazer'.</code>。怎么办呢？好办，去搜索下：</p>\n<p><img src=\"https://static.mk1.io/img/202212191939567.png\" alt=\"\"></p>\n<p>可以看到osulazer在Games这个Bucket里头。</p>\n<p>那么我们执行：</p>\n<pre><code class=\"language-powershell\">&gt; scoop bucket add games\n&gt; scoop install osulazer\n</code></pre>\n<p>就可以啦~</p>\n<p>搜索结果中给出的两条命令分别是添加Bucket以及安装软件的命令，先执行上面那条，后执行下面那条。</p>\n<h2>字体</h2>\n<p>没想到吧，Scoop还能装字体（）</p>\n<p>Scoop的字体都在nerd-fonts这个包中，执行<code>scoop bucket add nerd-fonts</code>即可。</p>\n<blockquote>\n<p>注意：安装字体请务必全局安装，如<code>scoop install FiraCode-NF -g</code>，原因<a href=\"https://github.com/matthewjberger/scoop-nerd-fonts/issues/198\">见此</a></p>\n</blockquote>\n<h1>实用工具合集</h1>\n<p>最后附上我用的软件：</p>\n<pre><code class=\"language-console\">&gt;  scoop bucket list\n\nName       Source                                             Updated             Manifests\n----       ------                                             -------             ---------\ndestiny    https://github.com/so1ve/destiny.git               2022/12/14 4:29:35          6\ndorado     https://github.com/chawyehsu/dorado.git            2022/12/19 8:11:45        227\nextras     https://github.com/ScoopInstaller/Extras           2022/12/19 16:27:47      1752\ngames      https://github.com/Calinou/scoop-games             2022/12/19 16:28:28       247\njava       https://github.com/ScoopInstaller/Java             2022/12/17 16:18:12       253\nmain       https://github.com/ScoopInstaller/Main             2022/12/19 16:28:35      1129\nnerd-fonts https://github.com/matthewjberger/scoop-nerd-fonts 2022/12/14 5:12:47        209\nsiku       https://github.com/amorphobia/siku.git             2022/12/17 0:39:11         57\nversions   https://github.com/ScoopInstaller/Versions         2022/12/19 16:35:38       400\n\n&gt; scoop list\n\nInstalled apps:\n\nName               Version          Source     Updated             Info\n----               -------          ------     -------             ----\n7zip               22.01            main       2022-11-05 12:02:09\nadb                33.0.3           main       2022-11-05 12:02:11\nag                 2.2.5            main       2022-11-05 12:02:16\naria2              1.36.0-1         main       2022-11-05 12:13:39\nbat                0.22.1           main       2022-11-05 12:13:41\nbazel              5.3.2            main       2022-11-05 12:17:02\nbottom             0.6.8            main       2022-11-05 12:17:12\nbroot              1.16.2           main       2022-11-05 12:19:34\nbusybox            4784-g5507c8744  main       2022-11-14 10:04:28\ncheat              4.4.0            main       2022-11-14 10:04:41\nclink              1.4.0            main       2022-11-14 10:04:43\ncloc               1.94             main       2022-11-05 12:22:03\ncloudflared        2022.10.3        main       2022-11-05 12:41:57\ncmake              3.24.3           main       2022-11-05 12:49:00\ncurlie             1.6.9            main       2022-11-05 12:49:38\ndark               3.11.2           main       2022-11-05 12:53:24\ndelta              0.14.0           main       2022-11-05 12:53:27\ndeta               1.3.3-beta       main       2022-11-05 13:06:14\ndocker             20.10.21         main       2022-11-05 13:06:28\ndocker-compose     2.12.2           main       2022-11-05 13:12:24\ndockercompletion   1.2010.1.211002  extras     2022-11-05 13:06:32\nduf                0.8.1            main       2022-11-05 13:12:40\ndust               0.8.3            main       2022-11-05 13:12:58\ndvm                1.8.6            destiny    2022-11-05 12:53:39\nfd                 8.5.2            main       2022-11-05 13:13:10\nffmpeg             5.1.2            main       2022-11-05 13:55:42\nFiraCode-NF        2.2.2            nerd-fonts 2022-11-05 13:59:22\nfnm                1.31.1           main       2022-11-05 14:00:09\nfzf                0.35.0           main       2022-11-14 10:04:45\ngh                 2.20.0           main       2022-11-14 10:04:49\ngitui              0.21.0           main       2022-11-15 21:05:10\ngo                 1.19.3           main       2022-11-05 14:03:45\ngow                0.8.0            main       2022-11-05 14:08:06\ngpg                2.3.8            main       2022-11-05 14:10:58\ngping              1.4.0            main       2022-11-05 14:11:04\ngradle             7.5.1            main       2022-11-05 14:14:25\ngsudo              2.0.2            main       2022-11-14 10:05:01\nhelix              22.08.1          main       2022-11-05 14:18:02\nhexyl              0.10.0           main       2022-11-05 14:18:10\nhub                2.14.2           main       2022-11-05 14:19:08\nhugo-extended      0.105.0          main       2022-11-05 14:21:41\nhyperfine          1.15.0           main       2022-11-05 14:22:08\njid                0.7.6            main       2022-11-05 14:22:30\njq                 1.6              main       2022-11-05 14:23:32\njust               1.8.0            main       2022-11-05 14:23:46\nlazygit            0.36.0           extras     2022-11-15 21:05:21\nllvm               15.0.4           main       2022-11-05 16:31:03\nlsd                0.23.1           main       2022-11-05 16:31:08\nmake               4.4              main       2022-11-05 16:31:19\nmingit             2.38.1.windows.1 main       2022-11-05 11:46:47\nmingw-nuwen        18.0             main       2022-11-05 16:36:36\nmsys2              2022-09-04       main       2022-11-05 16:37:24\nneofetch           7.1.0            main       2022-11-05 16:37:26\nneovide            0.10.3           extras     2022-11-14 10:05:06\nneovim             0.8.0            main       2022-11-05 16:37:50\nopenssh            8.9.1.0p1        main       2022-11-05 11:48:09\noraclejdk17        17.0.3.1         destiny    2022-11-05 16:53:24\noraclejdk8         8u321            destiny    2022-11-05 16:54:46\nposh-cargo         0.1.2.0          siku       2022-11-05 16:54:48\nposh-docker        0.7.0            extras     2022-11-05 16:54:50\nposh-git           1.1.0            extras     2022-11-05 16:54:52\npowershell-preview 7.3.0-rc.1       destiny    2022-11-05 13:05:41\nprocs              0.13.3           main       2022-11-05 16:54:59\npsreadline         2.2.6            extras     2022-11-05 16:55:00\nrefreshenv         2022.06.30       main       2022-11-05 16:55:39\nripgrep            13.0.0           main       2022-11-05 16:55:47\nrustup-msvc        1.25.1           main       2022-11-05 17:14:00\nscoop-completion   0.2.4            extras     2022-11-05 16:56:55\nstarship           1.11.0           main       2022-11-05 16:56:59\ntdm-gcc            10.3.0           versions   2022-11-05 16:57:47\ntinygo             0.26.0           main       2022-11-05 17:06:16\nttyd               1.7.2            main       2022-11-06 12:55:25\nvcpkg              2022.10.19       main       2022-11-05 17:06:52\nvcredist2010       10.0.40219.473   extras     2022-11-05 17:07:37\nvcredist2022       14.34.31931.0    extras     2022-11-14 10:06:49\nvhs                0.1.1            main       2022-11-06 12:55:30\nvim                9.0              main       2022-11-05 17:10:32\nvimtutor           0.2018.07.25     main       2022-11-05 17:10:33\nwrangler           1.20.0           main       2022-11-05 17:10:38\nyoutube-dl         2021.12.17       main       2022-11-05 17:10:52\nzig                0.10.0           main       2022-11-05 17:11:40\nzoxide             0.8.3            main       2022-11-05 17:11:44\nfiracode-nf        2.2.2            nerd-fonts 2022-11-05 18:35:27 Global install\nNoto-NF            2.2.2            nerd-fonts 2022-12-17 20:05:33 Global install\nsmiley-sans        1.0.0            nerd-fonts 2022-12-11 12:11:51 Global install\n</code></pre>\n","link":"https://blog.mk1.io/posts/hey-managers"},{"title":"抛弃静态博客的缺点，用 ESHexoN 在线编辑！","date":"2022-12-04 16:00:00","description":"\n<h2>\n<a href=\"https://blog.yfun.top/#%E4%BB%80%E4%B9%88%E6%98%AF-ESHexoN\" class=\"headerlink\" title=\"什么是 ESHexoN?\"></a>什么是 ESHexoN?</h2>\n<blockquote><p>ESHexoN 是一款简洁、强大的 Hexo 在线编辑器。</p></blockquote>\n<p>其灵感来自于 <a href=\"https://github.com/HexoPlusPlus/HexoPlusPlus\">HexoPlusPlus/HexoPlusPlus</a> (基于 Cloudflare Workers 的无服务器 Hexo 后端)</p>\n<p>但是，遗憾的是 HPP 突然停止维护，只留下一个 <a href=\"https://github.com/Wexagonal/Wexagonal\">Wexagonal</a>。</p>\n<blockquote><p>However, 这更新速度也太慢了啊喂~</p></blockquote>\n<p><a href=\"https://github.com/Qexo/Qexo\">Qexo</a> 也是一个很不错的项目，但是它基于 Python + MongoDB，不属于我擅长的技术栈，有点劝退。</p>\n<p>于是，ESHexoN 诞生了。它致力于使用 JavaScript Edge Function 构建 Hexo「后端」，实现普通静态博客所不具备的功能，解决大部分静态博客的痛点。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ESHexoN\" class=\"headerlink\" title=\"如何使用 ESHexoN?\"></a>如何使用 ESHexoN?</h2>\n<blockquote><p>ESHexoN 的使用说明可以参见文档 --&gt; <a href=\"https://eshexon-docs.netlify.app/\">文档链接</a></p></blockquote>\n<h2>\n<a href=\"https://blog.yfun.top/#ESHexoN-%E4%BB%A3%E7%A0%81-amp-%E5%8E%9F%E7%90%86\" class=\"headerlink\" title=\"ESHexoN 代码 &amp; 原理\"></a>ESHexoN 代码 &amp; 原理</h2>\n<h3>\n<a href=\"https://blog.yfun.top/#%E4%BB%A3%E7%A0%81%E7%9B%AE%E5%BD%95\" class=\"headerlink\" title=\"代码目录\"></a>代码目录</h3>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.17/rawimg/20221205115647.png\"></p>\n<p><code>dist</code> 目录存放构建的文件，<code>src</code> 目录为源码，<code>tools</code> 是一些工具，<code>index.js</code> 则为入口文件。</p>\n<h3>\n<a href=\"https://blog.yfun.top/#%E5%90%8E%E7%AB%AF%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%87%E4%BB%B6\" class=\"headerlink\" title=\"后端的主要文件\"></a>后端的主要文件</h3>\n<h4>\n<a href=\"https://blog.yfun.top/#src-res-js\" class=\"headerlink\" title=\"src/res.js\"></a><code>src/res.js</code>\n</h4>\n<p><code>res.js</code> 主要负责 HTTP 响应输出，统一输出格式。</p>\n<p>故 ESHexoN API 主要返回格式为:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"attr\">\"statusCode\"</span>: <span class=\"string\">\"...\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"statusInfo\"</span>: <span class=\"string\">\"...\"</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><p><a href=\"https://github.com/ESHexoN/ESHexoN/blob/master/src/res.js\">[Source Code]</a></p>\n<h4>\n<a href=\"https://blog.yfun.top/#src-check-token-js\" class=\"headerlink\" title=\"src/check_token.js\"></a><code>src/check_token.js</code>\n</h4>\n<p><code>check_token.js</code> 主要负责 API 请求的鉴权，所有的鉴权 API 都需要携带 <code>token</code> 发送。</p>\n<p>生成代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> token = md5(userdata[<span class=\"number\">0</span>].username + userdata[<span class=\"number\">0</span>].password + <span class=\"string\">`<span class=\"subst\">${<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"built_in\">Date</span>.now()).getFullYear()}</span><span class=\"subst\">${<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"built_in\">Date</span>.now()).getMonth()+<span class=\"number\">1</span>}</span>`</span>);</span><br></pre></td></tr></table></figure><p>故 ESHexoN Token 格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">md5(USERNAME+PASSWORD+YEAR+MONTH);</span><br></pre></td></tr></table></figure><p>过期时间为一个月。</p>\n<h4>\n<a href=\"https://blog.yfun.top/#src-env-js\" class=\"headerlink\" title=\"src/env.js\"></a><code>src/env.js</code>\n</h4>\n<p>ESHexoN 除了依靠 <a href=\"https://github.com/yfun-lab/gh-worker-kv\">yfun-lab/gh-worker-kv</a> 存储主要数据库文件外，还使用环境变量存储基本的 Token、仓库等。</p>\n<p>ESHexoN 自设计之初就预备支持 Cloudflare Workers, Deno 等平台。</p>\n<p>事实上，这两个平台获取环境变量的方式根本不一样。为了在一个代码下同时支持两个平台，<code>env.js</code> 简单的写了个判断。</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.17/rawimg/20221205120944.png\"></p>\n<h4>\n<a href=\"https://blog.yfun.top/#%E6%98%AF%E4%B8%8D%E6%98%AF%E7%9B%AE%E5%BD%95%EF%BC%9F%E6%96%87%E4%BB%B6%E9%81%8D%E5%8E%86\" class=\"headerlink\" title=\"是不是目录？文件遍历\"></a>是不是目录？文件遍历</h4>\n<p>GitHub API 会返回当前目录下的文件和文件夹，但有人的 <code>source/_posts</code> 目录下还有文件夹。根据观察发现，文件夹的 <code>type</code> 为 <code>dir</code>，而普通文件为 <code>file</code>，那么只需要一个简单的判断，就可以返回单个目录下所有文件。</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.17/rawimg/20221205121416.png\"></p>\n<h4>\n<a href=\"https://blog.yfun.top/#%E5%86%99%E6%96%87%E4%BB%B6\" class=\"headerlink\" title=\"写文件\"></a>写文件</h4>\n<p>在写文件之前，我们需要先获取该文件的 <code>sha</code> 值。</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.17/rawimg/20221205121728.png\"></p>\n<blockquote><p>这是因为 GitHub 规定修改文件必须在 <code>body</code> 中携带源文件 <code>sha</code>.</p></blockquote>\n<p>同时，文件还必须接受 Base64 编码。这个问题很好解决，ESHexoN 的仓库依赖中已经包含。当然，我更倾向于在前端编码文本，在后端直接 PUT。</p>\n<h3>\n<a href=\"https://blog.yfun.top/#%E9%82%A3%E5%89%8D%E7%AB%AF%E5%91%A2%EF%BC%9F\" class=\"headerlink\" title=\"那前端呢？\"></a>那前端呢？</h3>\n<p>以上是后端的主要代码。因为 ESHexoN 是前后端分离项目，并且开放跨域，所以我们构建了一个官方前端。只需要输入你的用户名、密码和后端地址就可以开始使用。</p>\n<p>前端的代码也是开源的，基于 Vue + Vuetify 构建，<a href=\"https://github.com/ESHexoN/eshexon-frontend\">在 GitHub 上查看它</a></p>\n<h4>\n<a href=\"https://blog.yfun.top/#%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%BB%86%E8%8A%82\" class=\"headerlink\" title=\"一些小细节\"></a>一些小细节</h4>\n<p>早在 HexoPlusPlus <code>dev</code> 阶段的时候，ChenYFan 就在群内讨论如何解决 Markdown 编辑器的问题。在当时，EditorMD 的兼容性很差。于是，HPP 上采取的解决方案是：<code>textarea</code> + <code>marked.js</code>。</p>\n<p>然后，HPP 编辑器就是这样的：</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.17/rawimg/20221205122539.png\"></p>\n<p>这并不是一个很好的主意。</p>\n<p>于是在 ESHexoN 上，我们为 Hexo 特性定制了一款简单的编辑器。</p>\n<p>首先，它是由 <a href=\"https://yfun.top/lab/markdown/\">https://yfun.top/lab/markdown/</a> 修改而来的，在部分特性上与其类似。</p>\n<p>但是受限于页面尺寸和小屏幕优化，ESHexoN 的编辑器在大屏上是这样显示的：</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.17/rawimg/20221205122828.png\"></p>\n<p>双栏布局，实时预览。</p>\n<p>为了保证在小屏幕的体验，在小屏幕上将自动收起预览，改为全屏模式。</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.17/rawimg/20221205122955.png\"></p>\n<p>如果需要预览，可以点击「预览」按键。</p>\n<p>同时 ESHexoN 的编辑器有自动保存功能，即使写到一半刷新页面或是浏览器崩溃也不用怕，页面内容已经存储到 <code>localStorage</code> 内了。（我也不知道会不会撑炸</p>\n<p>一些基本的搜索功能都得以保留（与 HPP 是十分甚至九分的类似</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.17/rawimg/20221205123316.png\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.17/rawimg/20221205123356.png\"></p>\n<p>不仅仅局限于文章，配置文件、代码都可以修改：</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.17/rawimg/20221205123427.png\"></p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%9C%A8%E6%9C%AA%E6%9D%A5\" class=\"headerlink\" title=\"在未来\"></a>在未来</h2>\n<p>目前 ESHexoN 还处于 Beta 阶段，部分功能还没有开发完成。</p>\n<p>关于说说、评论等也都在等待开发（最近可能不会有）</p>\n<p>如果在使用中出现了任何的问题，欢迎提 Issue 反馈。</p>\n","link":"https://blog.yfun.top/posts/2022/eshexon/"},{"title":"恢复更新","date":"2022-11-16 03:11:27","description":"\n<p>如你所见，本博客已经搬迁到了新博客系统 + 新主题（也就是外观啦）！</p>\n<p>由于学业问题以及开发博客系统的进度所迫，我前前后后咕了一年半（好像？bushi</p>\n<p>总之，本博客从今日起复活啦！</p>\n","link":"https://blog.mk1.io/posts/resume-update"},{"title":"详解JWT","date":"2022-11-15 07:29:04","description":"\n<blockquote>\n<p>这可能是旧博客的最后一篇文章了，之后会使用新博客系统。</p>\n<p><a href=\"https://7hmakers.com/\">创客七户社</a>征文。</p>\n<p>阅读这篇文章前，我们假定你对HTTP稍有一些了解。</p>\n</blockquote>\n<h1>JWT……和为什么要用JWT</h1>\n<p>JWT，即JSON Web Tokens。顾名思义，其为用于Web授权认证的一种令牌。它最为显著的特征为安全和“无状态”。</p>\n<p>我们先来看看过去的几种认证方式。</p>\n<h2>HTTP Basic Auth </h2>\n<p>在Web授权认证这一方面，我们最先使用的是<code>HTTP Basic Auth</code>。这种方式优缺点都很明显，优点是简单易用，基本上所有流行的网页浏览器都支持，开发者只需要在服务器的响应中加上一行形如<code>WWW-Authenticate: Basic realm=\"Secure Area\"</code>的响应头即可。但这种认证方式只对用户密码进行了近乎裸奔的Base64编码，且易被获取造成信息泄露，甚至可以发起中间人攻击，因此极少在生产环境中使用。</p>\n<h2>Cookie/Session</h2>\n<p><code>Cookie/Session</code>认证机制是一种较为安全的Web授权认证机制，其分为两大组成部分，即存储在客户端的Cookie和服务端的Session。它的运行方式也十分简单，客户端发出一个登录请求，服务端记录下用户信息(即Session)，并在响应中要求客户端记录下Cookie。在用户发起请求时，Cookie会一同发出，服务端便可基于此进行用户认证。</p>\n<p>这种方式看似是一种完美的解决方式，但其实仍有不足之处。</p>\n<p>首先，Session存储于服务端，这就必然导致服务器资源的占用。倘若有大量用户或攻击者同一时间大量发起登录请求，服务器便要大量存储Session，容易导致内存不足，甚至崩溃。同时，如果在Session中置入了较大的对象，也会产生较大的性能负担。Session的服务端开发对于程序员来说也不是一件美事，过度使用Session会导致代码不可读而且不好维护。</p>\n<h2>JWT来啦</h2>\n<p>既然Basic不安全，Session又会给服务器造成大量负担，那该怎么办呢？</p>\n<p>首先我们需要一个安全的认证方式，这个好办。我们只需要一个只存在于服务器的密钥对敏感信息进行加密就可以了。</p>\n<p>其次是不能给服务器造成性能负担，那我们势必将登录信息存储于客户端。</p>\n<p>由此，JWT就诞生了。</p>\n<h1>JWT的组成</h1>\n<blockquote>\n<p>部分内容来自<a href=\"https://javaguide.cn/system-design/security/jwt-intro.html\">https://javaguide.cn/system-design/security/jwt-intro.html</a></p>\n</blockquote>\n<p>我们可以在<a href=\"https://jwt.io/\">jwt.io</a>上直观感受JWT。JWT是一种形如<code>xxxxx.yyyyy.zzzzz</code>的由服务器返回的字符串，其中<code>xxxxx</code>为Header(描述JWT的元数据，定义了生成签名的算法以及 Token 的类型)、<code>yyyyy</code>为Payload(用来存放实际需要传递的数据)，<code>zzzzz</code>为Signature(签名)(服务器通过Payload、Header和一个密钥(Secret)使用Header里面指定的签名算法(默认是HMAC SHA256)生成)。</p>\n<p>可以看出，JWT本质上就是一组字符串，通过<code>.</code>切分成三个经过Base64编码的部分。</p>\n<p>例如：</p>\n<pre><code>eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoic28xdmUiLCJwYXNzd29yZCI6bnVsbH0.zPEzTi2VzXpMTndG0k04QVddxaQ2Ermgw21skfyl1XWqdF5mdPoT6goQsk8XsAh40Twux-IHFl1RSYUeLuyCGQ\n</code></pre>\n<p>你可以在<a href=\"https://jwt.io/#debugger-io?token=eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoic28xdmUiLCJwYXNzd29yZCI6bnVsbH0.zPEzTi2VzXpMTndG0k04QVddxaQ2Ermgw21skfyl1XWqdF5mdPoT6goQsk8XsAh40Twux-IHFl1RSYUeLuyCGQ\">这里</a>对它进行解码，可以得出其中包含的Header、Payload和Signature。</p>\n<h2>Header</h2>\n<p>Header 通常由两部分组成：</p>\n<ul>\n<li>\n<code>typ</code> (type): 令牌类型，也就是JWT。</li>\n<li>\n<code>alg</code> (algorithm): 签名算法，比如HS512。</li>\n</ul>\n<p>示例：</p>\n<pre><code class=\"language-json\">{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n</code></pre>\n<p>JSON形式的Header被转换成Base64编码，成为JWT的第一部分。</p>\n<h2>Payload</h2>\n<p>随后是Payload。Payload也是JSON格式数据，包含了Claims(声明，包含JWT的相关信息)。在这里可以包含一些用户相关的信息，但请注意，默认情况下该部分并未进行加密，请不要存储隐私信息。</p>\n<p>例如：</p>\n<pre><code class=\"language-json\">{\n  \"name\": \"so1ve\",\n  \"password\": null\n}\n</code></pre>\n<p>这是一个很简单的例子，除了这些自定义的内容，我们还可以放置如下数据：</p>\n<ul>\n<li>\n<code>iss</code> (issuer)：JWT 签发方。</li>\n<li>\n<code>iat</code> (issued at time)：JWT 签发时间。</li>\n<li>\n<code>sub</code> (subject)：JWT 主题。</li>\n<li>\n<code>aud</code> (audience)：JWT 接收方。</li>\n<li>\n<code>exp</code> (expiration time)：JWT 的过期时间。</li>\n<li>\n<code>nbf</code> (not before time)：JWT 生效时间，早于该定义的时间的 JWT 不能被接受处理。</li>\n<li>\n<code>jti</code> (JWT ID)：JWT 唯一标识。</li>\n</ul>\n<p>JSON形式的Payload被转换成Base64编码，成为JWT的第二部分。</p>\n<h2>Signature</h2>\n<p>Signature 部分是对前两部分的签名，作用是防止JWT(主要是payload)被篡改。</p>\n<p>这个签名的生成需要用到：</p>\n<ul>\n<li>Header + Payload。</li>\n<li>存放在服务端的密钥(一定不要泄露出去)。</li>\n<li>签名算法。</li>\n</ul>\n<p>签名的计算公式如下：</p>\n<p>HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret)</p>\n<p>算出签名以后，把Header、Payload、Signature三个部分拼成一个字符串，每个部分之间用<code>.</code>分隔，这个字符串就是<code>JWT</code>。</p>\n<h1>如何认证</h1>\n<p>使用JWT进行认证，大致可以简化为如下步骤：</p>\n<ol>\n<li>客户端向服务器发起登录请求(用户名、密码，或许还有验证码？)，服务器后返回一个包含用户信息(Payload中)的JWT令牌。</li>\n<li>客户端将这个JWT存放在自己的localStorage(本地存储)中，并且在每次需要用户信息的请求中在请求头中携带上该令牌。<code>Authorization: Bearer &lt;JWT&gt;</code>\n</li>\n<li>服务器接收到JWT，并进行解密，利用自己的密钥检验Signature，对用户权限进行判断。如果用户拥有访问该页面的权限，则返回相应内容。</li>\n<li>客户端接收到响应内容。</li>\n</ol>\n<p>可以看出，全程服务器乐的清闲，不需要本地存储用户信息，而是将工作交给浏览器。</p>\n<h1>关于安全性</h1>\n<p>前面我们提到，JWT的弊病之一是Payload只经过Base64加密(≈裸奔了)，因此不能存储隐私信息。在一般情况下，客户端无需用户的隐私信息，如果必要，我们可以采用对JWT进行对称加密，用时再解密的方式来增加安全性。</p>\n<p>另外，由于JWT被JavaScript存储在localStorage中，由于JavaScript的同源策略，网站下所有的JavaScript代码都可以访问同一个localStorage，从而获取到JWT，这就会带来注入的风险。</p>\n<p>最后，网站一定要使用HTTPS。如果只使用HTTP，Token在网络中明文传输还是存在泄露的风险。</p>\n<h1>总结</h1>\n<p>此外，Web授权认证还有OAuth等方式，在此不再多说。总而言之，JWT是目前最流行也最优秀的Web授权认证方案。</p>\n<h1>题外话</h1>\n<p>开学就上高中了，之后更新的频率可能会降低不少，请见谅。</p>\n","link":"https://blog.mk1.io/posts/about-jwt"},{"title":"让阅读无缝衔接 —— JS 获取用户阅读进度","date":"2022-11-11 16:40:00","description":"\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%89%8D%E8%A8%80\" class=\"headerlink\" title=\"前言\"></a>前言</h2>\n<p>很多博客中最常见的问题就是：文章很长，但是读者很忙。下次阅读的时候，可能要花一些时间才能恢复到先前的阅读位置。</p>\n<p>如果可以设备间，识别二维码或是一个链接就可以让阅读无缝衔接，直接跳转到相应位置，那么阅读体验就会变得更加优秀。</p>\n<p>那么，开始吧！</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%AE%9E%E8%B7%B5\" class=\"headerlink\" title=\"实践\"></a>实践</h2>\n<p>要知道阅读位置，那么就要知道当前页面的坐标。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getScrollPosition = <span class=\"function\">(<span class=\"params\">el = <span class=\"built_in\">window</span></span>) =&gt;</span> ({</span><br><span class=\"line\">    x: el.pageXOffset !== <span class=\"literal\">undefined</span> ? el.pageXOffset : el.scrollLeft,</span><br><span class=\"line\">    y: el.pageYOffset !== <span class=\"literal\">undefined</span> ? el.pageYOffset : el.scrollTop</span><br><span class=\"line\">});</span><br><span class=\"line\"><span class=\"comment\">// getScollPosition().x =&gt; 页面横坐标; getScrollPosition().y =&gt; 页面纵坐标;</span></span><br></pre></td></tr></table></figure><p>大部分情况下，我们只用关注纵坐标。横坐标大概率为 <code>0</code>。</p>\n<p>我们还需要一个页面滚动的事件，用于记录当前坐标，并储存在临时存储中。</p>\n<p>至于为什么是 <code>sessionStorage</code> 而不是 <code>localStorage</code>，则是因为 <code>localStorage</code> 除手动清除外，不会自动过期。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此处的 750 是「页面元素的最大宽度」</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wx = <span class=\"built_in\">window</span>.innerWidth &gt;= <span class=\"number\">750</span> ? <span class=\"number\">750</span> : <span class=\"built_in\">window</span>.innerWidth;</span><br><span class=\"line\"><span class=\"keyword\">var</span> wy = <span class=\"built_in\">window</span>.innerHeight;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">windowScroll</span>(<span class=\"params\"></span>) </span>{</span><br><span class=\"line\">    <span class=\"comment\">// 反复修改 确保页面尺寸不改变</span></span><br><span class=\"line\">    wx = <span class=\"built_in\">window</span>.innerWidth &gt;= <span class=\"number\">750</span> ? <span class=\"number\">750</span> : <span class=\"built_in\">window</span>.innerWidth;</span><br><span class=\"line\">    wy = <span class=\"built_in\">window</span>.innerHeight;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> y = <span class=\"built_in\">Math</span>.round(getScrollPosition().y);</span><br><span class=\"line\">    <span class=\"comment\">// 组合字符串，同时记录页面坐标，页面宽度和高度</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"string\">`<span class=\"subst\">${y}</span>:<span class=\"subst\">${wx}</span>:<span class=\"subst\">${wy}</span>`</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 写入到 sessionStorage 中</span></span><br><span class=\"line\">    sessionStorage.setItem(<span class=\"string\">\"read_y\"</span>, p);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onscroll = windowScroll;</span><br></pre></td></tr></table></figure><p>你可能发现了，此处的变量 <code>p</code>，并不仅仅是「页面纵坐标」，而是「页面高度」与「纵坐标」的组合字符串。</p>\n<p>事实上，如果单纯是纵坐标判断位置，那么在不同高度，不同宽度的设备上，就会出现错位的情况。而同时记录三个信息，就可以还原真实坐标。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// URL 中是否包含传递的坐标信息</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (location.hash.split(<span class=\"string\">\"#read=\"</span>).length &gt; <span class=\"number\">1</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 分离字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> read_y = location.hash.split(<span class=\"string\">\"#read=\"</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">    read_y = read_y.split(<span class=\"string\">\":\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 组合乘积，顺滑移动至坐标</span></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.scrollTo({<span class=\"attr\">top</span>: <span class=\"built_in\">Math</span>.round(<span class=\"built_in\">Number</span>(read_y[<span class=\"number\">0</span>]) * <span class=\"built_in\">Number</span>(read_y[<span class=\"number\">1</span>] * <span class=\"built_in\">Number</span>(read_y[<span class=\"number\">2</span>] / wx / wy))), <span class=\"attr\">behavior</span>: <span class=\"string\">\"smooth\"</span>});</span><br><span class=\"line\">} <span class=\"keyword\">else</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 从 sessionStorage 中获取</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> read_y = sessionStorage.getItem(<span class=\"string\">\"read_y\"</span>) || <span class=\"string\">\"0:0:0\"</span>;</span><br><span class=\"line\">    read_y = read_y.split(<span class=\"string\">\":\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.scrollTo({<span class=\"attr\">top</span>: <span class=\"built_in\">Math</span>.round(<span class=\"built_in\">Number</span>(read_y[<span class=\"number\">0</span>]) * <span class=\"built_in\">Number</span>(read_y[<span class=\"number\">1</span>] * <span class=\"built_in\">Number</span>(read_y[<span class=\"number\">2</span>] / wx / wy))), <span class=\"attr\">behavior</span>: <span class=\"string\">\"smooth\"</span>});</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><p>到现在，我们已经完成了 URL 的解析和基本生成。</p>\n<p>那么，URL 即为:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`<span class=\"subst\">${location.protocol}</span>//<span class=\"subst\">${location.hostname}</span><span class=\"subst\">${location.port ? <span class=\"string\">\":\"</span>+location.port:location.port}</span><span class=\"subst\">${location.pathname}</span>#read=<span class=\"subst\">${sessionStorage.getItem(<span class=\"string\">\"read_y\"</span>)}</span>`</span>;</span><br></pre></td></tr></table></figure><h2>\n<a href=\"https://blog.yfun.top/#%E6%9C%80%E5%90%8E\" class=\"headerlink\" title=\"最后\"></a>最后</h2>\n<p>搭配生成二维码等插件效果更佳。</p>\n<blockquote><p>Miracle 主题将在下个版本中更新该功能。</p></blockquote>\n","link":"https://blog.yfun.top/posts/2022/js-get-users-reading-progress/"},{"title":"React 为什么重新渲染","date":"2022-09-06 08:29:00","description":"\n<p>更新（重新渲染）是 React 的重要特性 —— 当用户与应用交互的时候，React 需要重新渲染、更新 UI，以响应用户的输入。但是，React 为什么会重新渲染呢？如果不知道 React 为什么会重新渲染，我们如何才能避免额外的重新渲染呢？</p>\n<img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/186432/20/28325/37613/631725bbEf2ff226e/66b99021df66578b.png\"><br><p>请前往 <a href=\"https://blog.skk.moe/post/react-re-renders-101/\">https://blog.skk.moe/post/react-re-renders-101/</a> 阅读全文</p>\n","link":"https://blog.skk.moe/post/react-re-renders-101/"},{"title":"为什么你不应该在 React 中直接使用 useEffect 从 API 获取数据","date":"2022-08-19 08:53:00","description":"\n<p>React 是一个由 Facebook 开源的、可以在任意平台上构建 UI 的 JavaScript 库。在 React 中，一个常见的 Pattern 是使用 <code>useEffect</code> 搭配 <code>useState</code> 发送请求、将状态从 API（React 外部）同步到 React 内部、用于渲染 UI，这篇文章恰恰在向你介绍为什么你不应该直接这么做。</p>\n<img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/180676/37/27394/27265/62ff57f2E600b3725/cff75c5fca39bbcc.png\"><br><p>请前往 <a href=\"https://blog.skk.moe/post/why-you-should-not-fetch-data-directly-in-use-effect/\">https://blog.skk.moe/post/why-you-should-not-fetch-data-directly-in-use-effect/</a> 阅读全文</p>\n","link":"https://blog.skk.moe/post/why-you-should-not-fetch-data-directly-in-use-effect/"},{"title":"NPM 自动更新版本号","date":"2022-08-04 05:00:00","description":"\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%89%8D%E8%A8%80\" class=\"headerlink\" title=\"前言\"></a>前言</h2>\n<p>ChenYFan 大佬的文章：<a href=\"https://blog.cyfan.top/p/d3c51290.html\">SpeedUp!使用黑科技为你的网站提速</a> 有提到过将 Hexo 博客的全部静态文件上传至 NPM 达到加速效果。</p>\n<p>但是 NPM 版本号不能重复，而且为了精准命中缓存和防止边缘 <code>@latest</code> 缓存过长，就必须指定版本号。</p>\n<p>本人在 <a href=\"https://blog.yfun.top/posts/2876015612/\">我的图床解决方案</a> 一文中使用的方法是 <code>npm version patch</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.16/rawimg/20220804133426.png\"></p>\n<p>但这个方法也有一些弊端，比如 <code>patch</code> 只会更新 <code>z</code> 位数的版本号，而且并不会上传至仓库，很可能会出现版本号冲突导致上传失败。这就是为什么最后还需要重新推送 Git 提交。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E8%AF%95%E8%AF%95%E7%9C%8B\" class=\"headerlink\" title=\"试试看\"></a>试试看</h2>\n<p>NPM 版本号遵循 <code>semver</code> 规范，格式为 <code>major.minor.patch</code>。</p>\n<p>为了在获取最新版本号的时候不发生混乱，我选择先获取最新的版本号。</p>\n<blockquote><p>记得把 <code>cky-blog-static</code> 改成自己的项目名。</p></blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getVersion = <span class=\"keyword\">async</span>() =&gt; {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> latestVersion = <span class=\"keyword\">await</span> fetch(<span class=\"string\">\"https://registry.npmjs.org/cky-blog-static/latest\"</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.json()).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.version;</span><br><span class=\"line\">    })</span><br><span class=\"line\">    <span class=\"keyword\">return</span> latestVersion;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><p>获取到最新版本号后，就可以对版本号进行分析。</p>\n<p>以 <code>1.4.7-b541af2ea284a39da0bbf63b88fdb65c</code> 为例，先按 <code>major.minor.patch</code> 分离。当然，也需要考虑版本号后还有 <code>build metadata</code> 的情况。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> version = <span class=\"keyword\">await</span> getVersion();</span><br><span class=\"line\"><span class=\"keyword\">var</span> verArray = version.split(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">verArray[<span class=\"number\">2</span>] = verArray[<span class=\"number\">2</span>].split(<span class=\"string\">\"-\"</span>)[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure><p><del>为了版本号好看些</del>，可以通过判断实现满十进一。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (verArray[<span class=\"number\">2</span>] &lt; <span class=\"number\">9</span>) {</span><br><span class=\"line\"><span class=\"comment\">// z 位小于 9，直接 +1</span></span><br><span class=\"line\">verArray[<span class=\"number\">2</span>] = <span class=\"built_in\">String</span>(<span class=\"built_in\">Number</span>(verArray[<span class=\"number\">2</span>])+<span class=\"number\">1</span>);</span><br><span class=\"line\">} <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (verArray[<span class=\"number\">1</span>] &lt; <span class=\"number\">9</span>) {</span><br><span class=\"line\"><span class=\"comment\">// z 位大于等于 9，y 位小于 9，y+1, z=0</span></span><br><span class=\"line\">verArray[<span class=\"number\">1</span>] = <span class=\"built_in\">String</span>(<span class=\"built_in\">Number</span>(verArray[<span class=\"number\">1</span>])+<span class=\"number\">1</span>);</span><br><span class=\"line\">verArray[<span class=\"number\">2</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">} <span class=\"keyword\">else</span> {</span><br><span class=\"line\"><span class=\"comment\">// z 大于等于 9，y 大于等于 9，x+1,y=0,z=0</span></span><br><span class=\"line\">verArray[<span class=\"number\">0</span>] = <span class=\"built_in\">String</span>(<span class=\"built_in\">Number</span>(verArray[<span class=\"number\">0</span>])+<span class=\"number\">1</span>);</span><br><span class=\"line\">verArray[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">verArray[<span class=\"number\">2</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure><p>最后，重新拼接版本号。如果担心服务器缓存版本号导致冲突，还可以加上一些随机字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newVersion = <span class=\"string\">`<span class=\"subst\">${verArray[<span class=\"number\">0</span>]}</span>.<span class=\"subst\">${verArray[<span class=\"number\">1</span>]}</span>.<span class=\"subst\">${verArray[<span class=\"number\">2</span>]}</span>`</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newVersion = newVersion + <span class=\"string\">\"-\"</span> + md5(<span class=\"string\">`<span class=\"subst\">${<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime()}</span><span class=\"subst\">${newVersion}</span>`</span>);</span><br></pre></td></tr></table></figure><p>将最新的版本号信息重新写入 <code>package.json</code> 文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> packageJson = fs.readFileSync(<span class=\"string\">\"./package.json\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> packageJson = <span class=\"built_in\">JSON</span>.parse(packageJson);</span><br><span class=\"line\">packageJson.version = newVersion;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newPackage = <span class=\"built_in\">JSON</span>.stringify(packageJson);</span><br><span class=\"line\">fs.writeFileSync(<span class=\"string\">\"./package.json\"</span>, newPackage);</span><br></pre></td></tr></table></figure><h2>\n<a href=\"https://blog.yfun.top/#%E4%BB%A3%E7%A0%81\" class=\"headerlink\" title=\"代码\"></a>代码</h2>\n<p><del>直接 CV 代码！</del></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 更新 package.json 版本号</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fetch = <span class=\"built_in\">require</span>(<span class=\"string\">\"node-fetch\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> md5 = <span class=\"built_in\">require</span>(<span class=\"string\">\"js-md5\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getVersion = <span class=\"keyword\">async</span>() =&gt; {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> latestVersion = <span class=\"keyword\">await</span> fetch(<span class=\"string\">\"https://registry.npmjs.org/cky-blog-static/latest\"</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.json()).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.version;</span><br><span class=\"line\">    })</span><br><span class=\"line\">    <span class=\"keyword\">return</span> latestVersion;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> update = <span class=\"keyword\">async</span>() =&gt; {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> version = <span class=\"keyword\">await</span> getVersion();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> verArray = version.split(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">    verArray[<span class=\"number\">2</span>] = verArray[<span class=\"number\">2</span>].split(<span class=\"string\">\"-\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (verArray[<span class=\"number\">2</span>] &lt; <span class=\"number\">9</span>) {</span><br><span class=\"line\">        verArray[<span class=\"number\">2</span>] = <span class=\"built_in\">String</span>(<span class=\"built_in\">Number</span>(verArray[<span class=\"number\">2</span>])+<span class=\"number\">1</span>);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (verArray[<span class=\"number\">1</span>] &lt; <span class=\"number\">9</span>) {</span><br><span class=\"line\">        verArray[<span class=\"number\">1</span>] = <span class=\"built_in\">String</span>(<span class=\"built_in\">Number</span>(verArray[<span class=\"number\">1</span>])+<span class=\"number\">1</span>);</span><br><span class=\"line\">        verArray[<span class=\"number\">2</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        verArray[<span class=\"number\">0</span>] = <span class=\"built_in\">String</span>(<span class=\"built_in\">Number</span>(verArray[<span class=\"number\">0</span>])+<span class=\"number\">1</span>);</span><br><span class=\"line\">        verArray[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        verArray[<span class=\"number\">2</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newVersion = <span class=\"string\">`<span class=\"subst\">${verArray[<span class=\"number\">0</span>]}</span>.<span class=\"subst\">${verArray[<span class=\"number\">1</span>]}</span>.<span class=\"subst\">${verArray[<span class=\"number\">2</span>]}</span>`</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> newVersion = newVersion + <span class=\"string\">\"-\"</span> + md5(<span class=\"string\">`<span class=\"subst\">${<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime()}</span><span class=\"subst\">${newVersion}</span>`</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(newVersion);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> packageJson = fs.readFileSync(<span class=\"string\">\"./package.json\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> packageJson = <span class=\"built_in\">JSON</span>.parse(packageJson);</span><br><span class=\"line\">    packageJson.version = newVersion;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newPackage = <span class=\"built_in\">JSON</span>.stringify(packageJson);</span><br><span class=\"line\">    fs.writeFileSync(<span class=\"string\">\"./package.json\"</span>, newPackage);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Complete!!\"</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">update();</span><br></pre></td></tr></table></figure><h2>\n<a href=\"https://blog.yfun.top/#%E6%9C%80%E5%90%8E\" class=\"headerlink\" title=\"最后\"></a>最后</h2>\n<p>如果是 Hexo 文件部署，就可以直接把文件直接丢在项目根目录，Action 集成部署加上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">node update.js</span><br></pre></td></tr></table></figure><p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.16/rawimg/20220804135818.png\"></p>\n<p><del>Blog 半年没更新，除除草 --(....</del></p>\n","link":"https://blog.yfun.top/posts/2022/auto-update-npm-version/"},{"title":"我有特别的 DNS 配置和使用技巧","date":"2022-07-28 15:31:00","description":"\n<p>众所周知，DNS 的作用与电话簿类似，将人类可读的域名映射到机器可读 IP 地址、使人更方便地访问互联网。DNS 是非常重要的互联网基础设施，对于改善上网冲浪的体验中的重要程度不容小觑。</p>\n<img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/96381/31/31172/23930/62e2ab5bE554d388b/37027f4a03351b9e.png\"><br><p>请前往 <a href=\"https://blog.skk.moe/post/i-have-my-unique-dns-setup/\">https://blog.skk.moe/post/i-have-my-unique-dns-setup/</a> 阅读全文</p>\n","link":"https://blog.skk.moe/post/i-have-my-unique-dns-setup/"},{"title":"优化博客的累计布局偏移（CLS）问题","date":"2022-06-07 17:24:00","description":"\n<p>距离上一篇文章发布已有四个月了，是时候写几篇文章给博客除草了。上一次我介绍了我如何迁移、重构了我的博客的架构，这次我想来谈谈我在重构中优化和打磨访客体验时解决的一个问题。我的博客优化之旅 图片 lazyload 的学问和在 Hexo 上的最佳实践 我的博客有多快？ 天下武功，唯快不破 —— 我是这样优化博客的 ...</p>\n<img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/206311/26/14625/38940/629f7f81Eb11312de/b1e67f07b1cc9bc7.png\"><br><p>请前往 <a href=\"https://blog.skk.moe/post/fix-blog-cls/\">https://blog.skk.moe/post/fix-blog-cls/</a> 阅读全文</p>\n","link":"https://blog.skk.moe/post/fix-blog-cls/"},{"title":"SpeedUp!使用黑科技为你的网站提速","date":"2022-06-07 02:28:12","description":"\n<p>实战，利用黑科技ServiceWorker提速你的网站。</p>\n<a></a><blockquote><p>本文所标记的内容，大多是直接复制粘贴即可实现的。但依然会存在这和您的服务存在冲突这一情况。请阅读上一篇基础文章<a href=\"https://blog.cyfan.top/p/c0af86bb.html\">欲善其事，必利其器 - 论如何善用ServiceWorker</a>进行合理的修改。</p></blockquote>\n<p>我们简单的列一下表，这是我们加速清单：</p>\n<ul>\n<li><a href=\"https://blog.cyfan.top/#%E5%89%8D%E7%AB%AF%E7%AB%9E%E9%80%9FCDN\">分离资源，静态加速</a></li>\n<li><a href=\"https://blog.cyfan.top/#%E5%85%A8%E7%AB%99NPM%E9%9D%99%E6%80%81%E5%8C%96\">加速主网页</a></li>\n<li><a href=\"https://blog.cyfan.top/#%E8%B0%83%E5%89%82%E5%93%8D%E5%BA%94\">调剂响应</a></li>\n<li><a href=\"https://blog.cyfan.top/#%E4%BC%98%E5%8C%96%E9%A6%96%E5%B1%8F\">首屏加速</a></li>\n</ul>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E5%89%8D%E7%AB%AF%E7%AB%9E%E9%80%9FCDN\" class=\"headerlink\" title=\"前端竞速CDN\"></a>前端竞速CDN</h1>\n<p>最传统的网页加载，其静态资源一旦独立是直接放在同域服务器下的。</p>\n<p>不过后来，为了减少主服务器开销，我们通常将静态资分离至其他面向用户加载比较快的节点，以减少主服务器开销，提升网页加载速度。</p>\n<p>现在，各种公益cdn服务蓬勃生长，其节点通常是全球部署，并且对各个国家/地区做了优化，使用公益cdn，他的质量和可用性是远远大于自己部署的。</p>\n<p>在一个网页加载中，主网页只提供一个html（你所看的网页其大小约<code>15kb</code>），而流量开销巨头是静态资源（只论js，本页大约<code>800kb</code>）。我们对一个网站的加速，第一步就应当从静态加速做起。</p>\n<p>对于加速存储的选择，通常市面上有三种主流加速<code>cdnjs</code>/<code>npm</code>/<code>gh</code>。而在这其中，对于个人而言，我还是推崇<code>npm</code>，这在接下来对于竞速节点的选择就多了起来。</p>\n<p>对于加速节点的选择，从mainland角度来讲，首先你要遵循一个普世结论：<code>不要用跨国节点</code>。本身China国度就有个奇葩规定，没有ICP备案许可就不得在mainland开展网站服务。这使得大部分本应该分散在边缘末端的流量全压到了国际出口的汇聚层。你再引导他们去海外拉资源，凑过去挤热闹，其稳定性和速率完全无法保证，这在生产环境使用无异于自杀。这里提一嘴jsdelivr，备案掉了，节点迁出中国了，那你面向国内的网站早就可以切了。使用fastly，联通和电信晚上ntt几乎堵到妈都不认识，能连上就是奇迹。除非你真的不在意加速，也不在意资源能不能正常加载，在面向mainland的生产环境里还坚持jsd就是愚不可及的行为。</p>\n<p>当然，在这里我还是推崇黑科技<code>ServiceWorker</code>，它可以利用<code>Promise.any</code>，并发数个请求至不同的cdn节点，提升前端资源加载。而借助于强大的js引擎，其在本地处理的效率奇高，性能折损几乎不计。</p>\n<p>在这之前，我们定义一个<code>lfetch</code>，它的作用是对<code>urls</code>这个数组里的所有网址发起并发请求，并且在任意一个节点返回正常值时<strong>打断</strong>其余请求，避免流量浪费。</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> lfetch = <span class=\"hljs-keyword\">async</span> (urls, url) =&gt; {    <span class=\"hljs-keyword\">let</span> controller = <span class=\"hljs-keyword\">new</span> AbortController(); <span class=\"hljs-comment\">//针对此次请求新建一个AbortController,用于打断并发的其余请求</span>    <span class=\"hljs-keyword\">const</span> PauseProgress = <span class=\"hljs-keyword\">async</span> (res) =&gt; {        <span class=\"hljs-comment\">//这个函数的作用时阻塞响应,直到主体被完整下载,避免被提前打断</span>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Response(<span class=\"hljs-keyword\">await</span> (res).arrayBuffer(), { <span class=\"hljs-attr\">status</span>: res.status, <span class=\"hljs-attr\">headers</span>: res.headers });    };    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">Promise</span>.any) { <span class=\"hljs-comment\">//Polyfill,避免Promise.any不存在,无需关注</span>        <span class=\"hljs-built_in\">Promise</span>.any = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">promises</span>) </span>{            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {                promises = <span class=\"hljs-built_in\">Array</span>.isArray(promises) ? promises : []                <span class=\"hljs-keyword\">let</span> len = promises.length                <span class=\"hljs-keyword\">let</span> errs = []                <span class=\"hljs-keyword\">if</span> (len === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> reject(<span class=\"hljs-keyword\">new</span> AggregateError(<span class=\"hljs-string\">'All promises were rejected'</span>))                promises.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> {                    promise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> {                        resolve(value)                    }, err =&gt; {                        len--                        errs.push(err)                        <span class=\"hljs-keyword\">if</span> (len === <span class=\"hljs-number\">0</span>) {                            reject(<span class=\"hljs-keyword\">new</span> AggregateError(errs))                        }                    })                })            })        }    }    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.any(urls.map(<span class=\"hljs-function\"><span class=\"hljs-params\">urls</span> =&gt;</span> {<span class=\"hljs-comment\">//并发请求</span>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {            fetch(urls, {                <span class=\"hljs-attr\">signal</span>: controller.signal<span class=\"hljs-comment\">//设置打断点</span>            })                .then(PauseProgress)<span class=\"hljs-comment\">//阻塞当前响应直到下载完成</span>                .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {                    <span class=\"hljs-keyword\">if</span> (res.status == <span class=\"hljs-number\">200</span>) {                        controller.abort()<span class=\"hljs-comment\">//打断其余响应(同时也打断了自己的,但本身自己已下载完成,打断无效)</span>                        resolve(res)<span class=\"hljs-comment\">//返回</span>                    } <span class=\"hljs-keyword\">else</span> {                        reject(res)                    }                })        })    }))}</code></pre></div>\n<p>在这其中，有一个难点：<code>fetch</code>返回的时状态而非内容。<br>即当<code>fetch</code>的<code>Promise resolve</code>时，它是已经获得了响应，但此时内容还没下载，提前打断会导致无法返回。这是<code>PauseProgress</code>作用。</p>\n<p>之后我们考虑静态资源加速。这时候用npm的好处就体现出来了，不仅镜像多，其格式也还算固定。</p>\n<blockquote><p>注意，此方法是以流量换速度的方式进行的，虽然在任何一个节点返回正确内容后会打断其余请求，但依然会造成不可避免的流量消耗(+~20%)。如果你面向的是手机流量用户，请三思而后行！</p></blockquote>\n<blockquote><p>此代码与<a href=\"https://github.com/EtherDream/freecdn-js\" target=\"_blank\" rel=\"noopener\">freecdn-js</a>核心功能相似，但实现方法并不同，并且完全支持动态网页。</p></blockquote>\n<p>例如jquery，你可以这样加速：</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">原始地址:<span class=\"hljs-symbol\">https:</span>//cdn.jsdelivr.net/npm/jquery<span class=\"hljs-subst\">@3</span><span class=\"hljs-number\">.6</span><span class=\"hljs-number\">.0</span>各类镜像：<span class=\"hljs-symbol\">https:</span>//fastly.jsdelivr.net/npm/jquery<span class=\"hljs-subst\">@3</span><span class=\"hljs-number\">.6</span><span class=\"hljs-number\">.0</span><span class=\"hljs-symbol\">https:</span>//gcore.jsdelivr.net/npm/jquery<span class=\"hljs-subst\">@3</span><span class=\"hljs-number\">.6</span><span class=\"hljs-number\">.0</span><span class=\"hljs-symbol\">https:</span>//unpkg.com/jquery<span class=\"hljs-subst\">@3</span><span class=\"hljs-number\">.6</span><span class=\"hljs-number\">.0</span><span class=\"hljs-symbol\">https:</span>//unpkg.zhimg.com/jquery<span class=\"hljs-subst\">@3</span><span class=\"hljs-number\">.6</span><span class=\"hljs-number\">.0</span> <span class=\"hljs-meta\">#回源有问题</span><span class=\"hljs-symbol\">https:</span>//unpkg.com/jquery<span class=\"hljs-subst\">@3</span><span class=\"hljs-number\">.6</span><span class=\"hljs-number\">.0</span><span class=\"hljs-symbol\">https:</span>//npm.elemecdn.com/jquery<span class=\"hljs-subst\">@3</span><span class=\"hljs-number\">.6</span><span class=\"hljs-number\">.0</span><span class=\"hljs-symbol\">https:</span>//npm.sourcegcdn.com/jquery<span class=\"hljs-subst\">@3</span><span class=\"hljs-number\">.6</span><span class=\"hljs-number\">.0</span> <span class=\"hljs-meta\">#滥用封仓库</span><span class=\"hljs-symbol\">https:</span>//cdn1.tianli0.top/jquery<span class=\"hljs-subst\">@3</span><span class=\"hljs-number\">.6</span><span class=\"hljs-number\">.0</span> <span class=\"hljs-meta\">#滥用封仓库</span></code></pre></div>\n<p>我们可以简单搓一个sw小脚本完成前端加速：</p>\n<details><summary>ServiceWorker完整代码：</summary><details><summary>我已经很详细的看了上面的阐述，并且我不会直接照搬</summary><div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> CACHE_NAME = <span class=\"hljs-string\">'ICDNCache'</span>;<span class=\"hljs-keyword\">let</span> cachelist = [];self.addEventListener(<span class=\"hljs-string\">'install'</span>, <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">installEvent</span>) </span>{    self.skipWaiting();    installEvent.waitUntil(        caches.open(CACHE_NAME)            .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">cache</span>) </span>{                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Opened cache'</span>);                <span class=\"hljs-keyword\">return</span> cache.addAll(cachelist);            })    );});self.addEventListener(<span class=\"hljs-string\">'fetch'</span>, <span class=\"hljs-keyword\">async</span> event =&gt; {    <span class=\"hljs-keyword\">try</span> {        event.respondWith(handle(event.request))    } <span class=\"hljs-keyword\">catch</span> (msg) {        event.respondWith(handleerr(event.request, msg))    }});<span class=\"hljs-keyword\">const</span> handleerr = <span class=\"hljs-keyword\">async</span> (req, msg) =&gt; {    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Response(<span class=\"hljs-string\">`&lt;h1&gt;CDN分流器遇到了致命错误&lt;/h1&gt;    &lt;b&gt;<span class=\"hljs-subst\">${msg}</span>&lt;/b&gt;`</span>, { <span class=\"hljs-attr\">headers</span>: { <span class=\"hljs-string\">\"content-type\"</span>: <span class=\"hljs-string\">\"text/html; charset=utf-8\"</span> } })}<span class=\"hljs-keyword\">let</span> cdn = {<span class=\"hljs-comment\">//镜像列表</span>    <span class=\"hljs-string\">\"gh\"</span>: {        <span class=\"hljs-attr\">jsdelivr</span>: {            <span class=\"hljs-string\">\"url\"</span>: <span class=\"hljs-string\">\"https://cdn.jsdelivr.net/gh\"</span>        },        <span class=\"hljs-attr\">jsdelivr_fastly</span>: {            <span class=\"hljs-string\">\"url\"</span>: <span class=\"hljs-string\">\"https://fastly.jsdelivr.net/gh\"</span>        },        <span class=\"hljs-attr\">jsdelivr_gcore</span>: {            <span class=\"hljs-string\">\"url\"</span>: <span class=\"hljs-string\">\"https://gcore.jsdelivr.net/gh\"</span>        }    },    <span class=\"hljs-string\">\"combine\"</span>: {        <span class=\"hljs-attr\">jsdelivr</span>: {            <span class=\"hljs-string\">\"url\"</span>: <span class=\"hljs-string\">\"https://cdn.jsdelivr.net/combine\"</span>        },        <span class=\"hljs-attr\">jsdelivr_fastly</span>: {            <span class=\"hljs-string\">\"url\"</span>: <span class=\"hljs-string\">\"https://fastly.jsdelivr.net/combine\"</span>        },        <span class=\"hljs-attr\">jsdelivr_gcore</span>: {            <span class=\"hljs-string\">\"url\"</span>: <span class=\"hljs-string\">\"https://gcore.jsdelivr.net/combine\"</span>        }    },    <span class=\"hljs-string\">\"npm\"</span>: {        <span class=\"hljs-attr\">eleme</span>: {            <span class=\"hljs-string\">\"url\"</span>: <span class=\"hljs-string\">\"https://npm.elemecdn.com\"</span>        },        <span class=\"hljs-attr\">jsdelivr</span>: {            <span class=\"hljs-string\">\"url\"</span>: <span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm\"</span>        },        <span class=\"hljs-attr\">zhimg</span>: {            <span class=\"hljs-string\">\"url\"</span>: <span class=\"hljs-string\">\"https://unpkg.zhimg.com\"</span>        },        <span class=\"hljs-attr\">unpkg</span>: {            <span class=\"hljs-string\">\"url\"</span>: <span class=\"hljs-string\">\"https://unpkg.com\"</span>        },        <span class=\"hljs-attr\">bdstatic</span>: {            <span class=\"hljs-string\">\"url\"</span>: <span class=\"hljs-string\">\"https://code.bdstatic.com/npm\"</span>        },        <span class=\"hljs-attr\">tianli</span>: {            <span class=\"hljs-string\">\"url\"</span>: <span class=\"hljs-string\">\"https://cdn1.tianli0.top/npm\"</span>        },        <span class=\"hljs-attr\">sourcegcdn</span>: {            <span class=\"hljs-string\">\"url\"</span>: <span class=\"hljs-string\">\"https://npm.sourcegcdn.com/npm\"</span>        }    }}<span class=\"hljs-comment\">//主控函数</span><span class=\"hljs-keyword\">const</span> handle = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">req</span>) </span>{    <span class=\"hljs-keyword\">const</span> urlStr = req.url    <span class=\"hljs-keyword\">const</span> domain = (urlStr.split(<span class=\"hljs-string\">'/'</span>))[<span class=\"hljs-number\">2</span>]    <span class=\"hljs-keyword\">let</span> urls = []    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">in</span> cdn) {        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j <span class=\"hljs-keyword\">in</span> cdn[i]) {            <span class=\"hljs-keyword\">if</span> (domain == cdn[i][j].url.split(<span class=\"hljs-string\">'https://'</span>)[<span class=\"hljs-number\">1</span>].split(<span class=\"hljs-string\">'/'</span>)[<span class=\"hljs-number\">0</span>] &amp;&amp; urlStr.match(cdn[i][j].url)) {                urls = []                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> k <span class=\"hljs-keyword\">in</span> cdn[i]) {                    urls.push(urlStr.replace(cdn[i][j].url, cdn[i][k].url))                }                <span class=\"hljs-keyword\">if</span> (urlStr.indexOf(<span class=\"hljs-string\">'@latest/'</span>) &gt; <span class=\"hljs-number\">-1</span>) {                    <span class=\"hljs-keyword\">return</span> lfetch(urls, urlStr)                } <span class=\"hljs-keyword\">else</span> {                    <span class=\"hljs-keyword\">return</span> caches.match(req).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resp</span>) </span>{                        <span class=\"hljs-keyword\">return</span> resp || lfetch(urls, urlStr).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">res</span>) </span>{                            <span class=\"hljs-keyword\">return</span> caches.open(CACHE_NAME).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">cache</span>) </span>{                                cache.put(req, res.clone());                                <span class=\"hljs-keyword\">return</span> res;                            });                        });                    })                }            }        }    }    <span class=\"hljs-keyword\">return</span> fetch(req)}<span class=\"hljs-keyword\">const</span> lfetch = <span class=\"hljs-keyword\">async</span> (urls, url) =&gt; {    <span class=\"hljs-keyword\">let</span> controller = <span class=\"hljs-keyword\">new</span> AbortController();    <span class=\"hljs-keyword\">const</span> PauseProgress = <span class=\"hljs-keyword\">async</span> (res) =&gt; {        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Response(<span class=\"hljs-keyword\">await</span> (res).arrayBuffer(), { <span class=\"hljs-attr\">status</span>: res.status, <span class=\"hljs-attr\">headers</span>: res.headers });    };    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">Promise</span>.any) {        <span class=\"hljs-built_in\">Promise</span>.any = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">promises</span>) </span>{            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {                promises = <span class=\"hljs-built_in\">Array</span>.isArray(promises) ? promises : []                <span class=\"hljs-keyword\">let</span> len = promises.length                <span class=\"hljs-keyword\">let</span> errs = []                <span class=\"hljs-keyword\">if</span> (len === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> reject(<span class=\"hljs-keyword\">new</span> AggregateError(<span class=\"hljs-string\">'All promises were rejected'</span>))                promises.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> {                    promise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> {                        resolve(value)                    }, err =&gt; {                        len--                        errs.push(err)                        <span class=\"hljs-keyword\">if</span> (len === <span class=\"hljs-number\">0</span>) {                            reject(<span class=\"hljs-keyword\">new</span> AggregateError(errs))                        }                    })                })            })        }    }    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.any(urls.map(<span class=\"hljs-function\"><span class=\"hljs-params\">urls</span> =&gt;</span> {        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {            fetch(urls, {                <span class=\"hljs-attr\">signal</span>: controller.signal            })                .then(PauseProgress)                .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {                    <span class=\"hljs-keyword\">if</span> (res.status == <span class=\"hljs-number\">200</span>) {                        controller.abort();                        resolve(res)                    } <span class=\"hljs-keyword\">else</span> {                        reject(res)                    }                })        })    }))}</code></pre></div></details></details><h1>\n<a href=\"https://blog.cyfan.top/#%E5%85%A8%E7%AB%99NPM%E9%9D%99%E6%80%81%E5%8C%96\" class=\"headerlink\" title=\"全站NPM静态化\"></a>全站NPM静态化</h1>\n<blockquote><p>此法chen独创，是一种比较野路子的手法，但加速效果显著。<br>通常建议用于Hexo等静态博客，WordPress等需要做好伪静态，并且要配置好动态接口。</p></blockquote>\n<p>hexo作为静态博客有什么好处，那当然是纯静态啦。生成的静态文件随便搬到一个web服务器都能用。</p>\n<p>自然就有了接下的骚操作，用npm托管博客，然后在请求的时候用sw劫持并引流到npm镜像，效果就如同本博客所示，加载速度（抛开首屏不谈）接近于闪开。</p>\n<p>首先我博客的CI是用GithubAction的，在部署的过程中顺便把html上传到npm是最简单不过的事情，只要在生成代码块后面再加一块：</p>\n<div class=\"hljs\"><pre><code class=\"hljs yml\"><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">JS-DevTools/npm-publish@v1</span>  <span class=\"hljs-attr\">with:</span>    <span class=\"hljs-attr\">token:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.NPM</span> <span class=\"hljs-string\">}}</span></code></pre></div>\n<p>配置<code>NPM</code>环境变量，之后需要更新的时候叠一个新版本就行。</p>\n<p>然后接下来我们就要解决ServiceWorker获取问题。我们先设立一个监听器：</p>\n<div class=\"hljs\"><pre><code class=\"hljs javascript\">self.addEventListener(<span class=\"hljs-string\">'fetch'</span>, <span class=\"hljs-keyword\">async</span> event =&gt; {    event.respondWith(handle(event.request))});<span class=\"hljs-keyword\">const</span> handle = <span class=\"hljs-keyword\">async</span>(req)=&gt;{    <span class=\"hljs-keyword\">const</span> urlStr = req.url    <span class=\"hljs-keyword\">const</span> urlObj = <span class=\"hljs-keyword\">new</span> URL(urlStr);    <span class=\"hljs-keyword\">const</span> urlPath = urlObj.pathname;    <span class=\"hljs-keyword\">const</span> domain = urlObj.hostname;    <span class=\"hljs-comment\">//从这里开始</span>}</code></pre></div>\n<p>首先我们要判断一下这个域名是不是博客主域名,不然瞎拦截到其他地方可不好:</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">if</span>(domain === <span class=\"hljs-string\">\"blog.cyfan.top\"</span>){<span class=\"hljs-comment\">//这里写你需要拦截的域名</span>    <span class=\"hljs-comment\">//从这里开始处理</span>}</code></pre></div>\n<p>我们还要记得给url进行提前处理，剥离出路径，去除参数。在这其中尤其要注意的是默认路由的处理。</p>\n<p>通常情况下我们访问一个网址，web服务器会在后面添加<code>.html</code>后缀。对于一个默认路径则是<code>index.html</code>。</p>\n<p>还要注意的是剥离<code>#</code>，不然又会获取失败。</p>\n<p>定义一个<code>fullpath</code>函数，用于预处理和剥离路径：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> fullpath = <span class=\"hljs-function\">(<span class=\"hljs-params\">path</span>) =&gt;</span> {    path = path.split(<span class=\"hljs-string\">'?'</span>)[<span class=\"hljs-number\">0</span>].split(<span class=\"hljs-string\">'#'</span>)[<span class=\"hljs-number\">0</span>]    <span class=\"hljs-keyword\">if</span> (path.match(<span class=\"hljs-regexp\">/\\/$/</span>)) {        path += <span class=\"hljs-string\">'index'</span>    }    <span class=\"hljs-keyword\">if</span> (!path.match(<span class=\"hljs-regexp\">/\\.[a-zA-Z]+$/</span>)) {        path += <span class=\"hljs-string\">'.html'</span>    }    <span class=\"hljs-keyword\">return</span> path}</code></pre></div>\n<p>结果类似于：</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">&gt; fullpath('/')'/index.html'&gt; fullpath('/p/1')'/p/1.html'&gt; fullpath('/p/1?q=<span class=\"hljs-number\">1234</span>')'/p/1.html'&gt; fullpath('/p/1.html#QWERT')'/p/1.html'</code></pre></div>\n<p>然后再定义一个镜像并发函数，用于生成待获取的网址：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> generate_blog_urls = <span class=\"hljs-function\">(<span class=\"hljs-params\">packagename, blogversion, path</span>) =&gt;</span> {    <span class=\"hljs-keyword\">const</span> npmmirror = [        <span class=\"hljs-string\">`https://unpkg.com/<span class=\"hljs-subst\">${packagename}</span>@<span class=\"hljs-subst\">${blogversion}</span>/public`</span>,        <span class=\"hljs-string\">`https://npm.elemecdn.com/<span class=\"hljs-subst\">${packagename}</span>@<span class=\"hljs-subst\">${blogversion}</span>/public`</span>,        <span class=\"hljs-string\">`https://cdn.jsdelivr.net/npm/<span class=\"hljs-subst\">${packagename}</span>@<span class=\"hljs-subst\">${blogversion}</span>/public`</span>,        <span class=\"hljs-string\">`https://npm.sourcegcdn.com/npm/<span class=\"hljs-subst\">${packagename}</span>@<span class=\"hljs-subst\">${blogversion}</span>/public`</span>,        <span class=\"hljs-string\">`https://cdn1.tianli0.top/npm/<span class=\"hljs-subst\">${packagename}</span>@<span class=\"hljs-subst\">${blogversion}</span>/public`</span>    ]    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">in</span> npmmirror) {        npmmirror[i] += path    }    <span class=\"hljs-keyword\">return</span> npmmirror}</code></pre></div>\n<p>接下来我们将其填入主路由中:</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">if</span>(domain === <span class=\"hljs-string\">\"blog.cyfan.top\"</span>){<span class=\"hljs-comment\">//这里写你需要拦截的域名</span>    <span class=\"hljs-keyword\">return</span> lfetch(generate_blog_urls(<span class=\"hljs-string\">'chenyfan-blog'</span>,<span class=\"hljs-string\">'1.1.4'</span>,fullpath(urlPath)))}</code></pre></div>\n<p>然而谨记,npm返回的文件格式通常是text而非html，所以我们还要进一步处理header。处理也简单，连环then下去就行：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">if</span>(domain === <span class=\"hljs-string\">\"blog.cyfan.top\"</span>){    <span class=\"hljs-keyword\">return</span> lfetch(generate_blog_urls(<span class=\"hljs-string\">'chenyfan-blog'</span>,<span class=\"hljs-string\">'1.1.4'</span>,fullpath(urlPath)))    .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span>res.arrayBuffer())<span class=\"hljs-comment\">//arrayBuffer最科学也是最快的返回</span>    .then(<span class=\"hljs-function\"><span class=\"hljs-params\">buffer</span>=&gt;</span><span class=\"hljs-keyword\">new</span> Response(buffer,{<span class=\"hljs-attr\">headers</span>:{<span class=\"hljs-string\">\"Content-Type\"</span>:<span class=\"hljs-string\">\"text/html;charset=utf-8\"</span>}}))<span class=\"hljs-comment\">//重新定义header</span>}</code></pre></div>\n<p>那么接下来，除了首屏以外，你的网站相当于托管在全球(包括中国)各个主流cdn服务器中，提速效果无与伦比.如果你将原网站托管在cf，那么你将获得一个打不死，国内加载速度超快(首屏除外)的网站。</p>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E8%A7%A3%E6%94%BE%E5%8F%8C%E6%89%8B-npm%E7%89%88%E6%9C%AC%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9B%B4%E6%96%B0\" class=\"headerlink\" title=\"解放双手 - npm版本自定义更新\"></a>解放双手 - npm版本自定义更新</h2>\n<p>有人会问了，我为什么不能直接用latest来获取最新版本，还要手动指定？</p>\n<p>简单地说，在生产环境中用@latest指定最新版本是一个很不合理、且非常愚蠢的操作。你永远都不知道对面的缓存什么时候清除，获取到的可能是一年前的版本。</p>\n<p>为了节约成本，避免回源，cdn服务商通常会缓存资源，尤其是那些静态资源。以jsd为例，其latest缓存为7天，不过可以手动刷新。unpkg cf边缘2星期，eleme已经将近6个月没更新了。至于那些自建的。你根本搞不懂他什么时候更新，使用latest会导致随机获取到版本，接近无法正常使用。</p>\n<p>而指定版本的，cdn通常会永久缓存。毕竟版本定死了东西是不会变的，而请求指定版本的cdn也可以或多或少提升访问速度，因为文件时永久缓存的，HIT的热度比较高。</p>\n<h3>\n<a href=\"https://blog.cyfan.top/#sw%E7%AB%AF\" class=\"headerlink\" title=\"sw端\"></a>sw端</h3>\n<p>利用npm registry获取最新版本，其官方endpoint如下：</p>\n<div class=\"hljs\"><pre><code class=\"hljs url\">https://registry.npmjs.org/chenyfan-blog/latest</code></pre></div>\n<p>其version字段即最新版本。</p>\n<p>npm registry的镜像也不少，以腾讯/阿里为例：</p>\n<div class=\"hljs\"><pre><code class=\"hljs url\">https://registry.npmmirror.com/chenyfan/latest #阿里，可手动同步https://mirrors.cloud.tencent.com/npm/chenyfan/latest #腾讯，每日凌晨同步</code></pre></div>\n<p>获取最新版本也不难:</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> mirror = [        <span class=\"hljs-string\">`https://registry.npmmirror.com/chenyfan-blog/latest`</span>,        <span class=\"hljs-string\">`https://registry.npmjs.org/chenyfan-blog/latest`</span>,        <span class=\"hljs-string\">`https://mirrors.cloud.tencent.com/npm/chenyfan-blog/latest`</span>]<span class=\"hljs-keyword\">const</span> get_newest_version = <span class=\"hljs-keyword\">async</span> (mirror) =&gt; {    <span class=\"hljs-keyword\">return</span> lfetch(mirror, mirror[<span class=\"hljs-number\">0</span>])        .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> res.json())        .then(res.version)}</code></pre></div>\n<p>在这里还有一个坑点：ServiceWorker的全局变量会在所有页面关闭后销毁。下次启动时会优先响应handle，其定义变量要在handle响应后才会执行。因此，对于最新版本的存储，不能直接定义变量，需要持久化，这里另辟蹊径，采用CacheStorage存储：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\">self.db = { <span class=\"hljs-comment\">//全局定义db,只要read和write,看不懂可以略过</span>    <span class=\"hljs-attr\">read</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">key, config</span>) =&gt;</span> {        <span class=\"hljs-keyword\">if</span> (!config) { config = { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"text\"</span> } }        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {            caches.open(CACHE_NAME).then(<span class=\"hljs-function\"><span class=\"hljs-params\">cache</span> =&gt;</span> {                cache.match(<span class=\"hljs-keyword\">new</span> Request(<span class=\"hljs-string\">`https://LOCALCACHE/<span class=\"hljs-subst\">${<span class=\"hljs-built_in\">encodeURIComponent</span>(key)}</span>`</span>)).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">res</span>) </span>{                    <span class=\"hljs-keyword\">if</span> (!res) resolve(<span class=\"hljs-literal\">null</span>)                    res.text().then(<span class=\"hljs-function\"><span class=\"hljs-params\">text</span> =&gt;</span> resolve(text))                }).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {                    resolve(<span class=\"hljs-literal\">null</span>)                })            })        })    },    <span class=\"hljs-attr\">write</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">key, value</span>) =&gt;</span> {        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {            caches.open(CACHE_NAME).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">cache</span>) </span>{                cache.put(<span class=\"hljs-keyword\">new</span> Request(<span class=\"hljs-string\">`https://LOCALCACHE/<span class=\"hljs-subst\">${<span class=\"hljs-built_in\">encodeURIComponent</span>(key)}</span>`</span>), <span class=\"hljs-keyword\">new</span> Response(value));                resolve()            }).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {                reject()            })        })    }}<span class=\"hljs-keyword\">const</span> set_newest_version = <span class=\"hljs-keyword\">async</span> (mirror) =&gt; { <span class=\"hljs-comment\">//改为最新版本写入数据库</span>    <span class=\"hljs-keyword\">return</span> lfetch(mirror, mirror[<span class=\"hljs-number\">0</span>])        .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> res.json()) <span class=\"hljs-comment\">//JSON Parse</span>        .then(<span class=\"hljs-keyword\">async</span> res =&gt; {            <span class=\"hljs-keyword\">await</span> db.write(<span class=\"hljs-string\">'blog_version'</span>, res.version) <span class=\"hljs-comment\">//写入</span>            <span class=\"hljs-keyword\">return</span>;        })}setInterval(<span class=\"hljs-keyword\">async</span>() =&gt; {    <span class=\"hljs-keyword\">await</span> set_newest_version(mirror) <span class=\"hljs-comment\">//定时更新,一分钟一次</span>}, <span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">1000</span>);setTimeout(<span class=\"hljs-keyword\">async</span>() =&gt; {     <span class=\"hljs-keyword\">await</span> set_newest_version(mirror)<span class=\"hljs-comment\">//打开五秒后更新,避免堵塞</span>},<span class=\"hljs-number\">5000</span>)</code></pre></div>\n<p>再将上面的生成urls从:</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\">generate_blog_urls(<span class=\"hljs-string\">'chenyfan-blog'</span>,<span class=\"hljs-string\">'1.1.4'</span>,fullpath(urlPath))</code></pre></div>\n<p>改为</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//若第一次没有,则使用初始版本1.1.4,或者你也可以改成latest(不推荐)</span>generate_blog_urls(<span class=\"hljs-string\">'chenyfan-blog'</span>,<span class=\"hljs-keyword\">await</span> db.read(<span class=\"hljs-string\">'blog_version'</span>) || <span class=\"hljs-string\">'1.1.4'</span>,fullpath(urlPath))</code></pre></div>\n<p>此后用户加载时，会尽可能的获取最新版本，无需手动更新。</p>\n<h3>\n<a href=\"https://blog.cyfan.top/#ci%E7%AB%AF\" class=\"headerlink\" title=\"ci端\"></a>ci端</h3>\n<p>有了前端自动更新，我们在上传包的时候还要手动更新<code>package.json</code>中的version字段。其实这里也可以直接交给ci处理。</p>\n<p>然而需要注意，<code>npm version patch</code> 虽然能更新z位数版本，但其更新不会上传到仓库。换句话说，这只能上传一次。因此这个地方我干脆建议用随机数，反正通过api获得的latest都是最新的上传。</p>\n<p>案例代码这里不展示，实际上这一步做起来也不难。</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E8%B0%83%E5%89%82%E5%93%8D%E5%BA%94\" class=\"headerlink\" title=\"调剂响应\"></a>调剂响应</h1>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E7%BC%93%E5%AD%98-%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8A%E4%B8%80%E4%BC%9F%E5%A4%A7%E5%8F%91%E6%98%8E\" class=\"headerlink\" title=\"缓存 - 互联网上一伟大发明\"></a>缓存 - 互联网上一伟大发明</h2>\n<blockquote><p>虽然我也不清楚有一小部分人对那么丁点CacheStorage缓存占用那么敏感，但至少，缓存对网站加载速度的提升有极大的帮助。</p></blockquote>\n<p>通常，有大量的资源是访问一个网站重复需要的，对于这些东西，浏览器会自带MemoryCache或DiskCache，但这一类缓存不是持久的，在下一次打开网站的时候缓存不一定生效。而CacheStorage是浏览器自带的缓存桶（Key/Value），这种桶是持久存储，长期有效，而sw是能控制这桶。</p>\n<p>而不同的网域资源所应当采取的缓存策略也是不一样的。对于确定版本的静态资源，直接终生缓存；对于有时限的静态资源，应当不缓存或只缓存一小段时间。</p>\n<p>CacheStorage不是sw专属的，你可以在前端和sw中同时控制它，这是几分样例代码：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> CACHE_NAME = <span class=\"hljs-string\">'cache-v1'</span>; <span class=\"hljs-comment\">//定义缓存桶名称</span>caches.open(CACHE_NAME).then(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">cache</span>) </span>{    <span class=\"hljs-keyword\">const</span> KEYNAME = <span class=\"hljs-keyword\">new</span> Request(<span class=\"hljs-string\">'https://example.com/1.xxx'</span>) <span class=\"hljs-comment\">//定义KEY，[Object Request]</span>    <span class=\"hljs-keyword\">await</span> cache.put(KEYNAME, <span class=\"hljs-keyword\">new</span> Response(<span class=\"hljs-string\">'Hello World'</span>)); <span class=\"hljs-comment\">//自定义填入</span>    <span class=\"hljs-keyword\">await</span> cache.match(KEYNAME).then(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">response</span>) </span>{        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">await</span> response.text()); <span class=\"hljs-comment\">//匹配并输出</span>    })    <span class=\"hljs-keyword\">await</span> cache.put(KEYNAME, <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">'https://example.com/2.xxx'</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span>res.arrayBuffer())); <span class=\"hljs-comment\">//使用fetch填入缓存</span>    <span class=\"hljs-keyword\">await</span> cache.matchAll().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">responses</span>) </span>{ <span class=\"hljs-comment\">//列出所有（也可以根据内容列出指定的项</span>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> response <span class=\"hljs-keyword\">of</span> responses) {            <span class=\"hljs-built_in\">console</span>.log(response.url);        }    })    <span class=\"hljs-keyword\">await</span> cache.delete(KEYNAME) <span class=\"hljs-comment\">//删除指定项</span>});</code></pre></div>\n<h2>\n<a href=\"https://blog.cyfan.top/#SetTimeout-%E6%AF%AB%E7%A7%92%E7%BA%A7%E8%B0%83%E6%8E%A7%E5%93%8D%E5%BA%94\" class=\"headerlink\" title=\"SetTimeout - 毫秒级调控响应\"></a>SetTimeout - 毫秒级调控响应</h2>\n<p>对于同一个网页，你需要合理的对他执行决策树，这是目前我的博客[网页]采取的决策树:</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r18/1.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>js里有两个对时间控制的古老函数：<code>SetTimeout</code>和<code>SetInterval</code>.在这里我采用<code>SetTimeout</code>,同时并行执行任务.</p>\n<p>这里采用代码片段比较容易解释:</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">if</span> (请求的网址是博客) {    <span class=\"hljs-comment\">//这里一定要用Promise,这样在之后settimeout就不需要回调,直接Resolve</span>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>{        setTimeout(<span class=\"hljs-keyword\">async</span> () =&gt; {            <span class=\"hljs-keyword\">if</span> (存在缓存) {                setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {                    resolve(获取当前页面缓存(请求))                }, <span class=\"hljs-number\">200</span>);<span class=\"hljs-comment\">//200ms表示下面的拉取失败后直接返回缓存,但下面的拉取不会被踢出,更新会在后台执行,会填入缓存,但也不会返回</span>                setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {                    resolve(                        拉取最新版本的网页(请求)                            .then(填入缓存并返回内容)<span class=\"hljs-comment\">//返回缓存</span>                    )                }, <span class=\"hljs-number\">0</span>);<span class=\"hljs-comment\">//表示立刻执行,优先级最高</span>            } <span class=\"hljs-keyword\">else</span> {                setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {                    resolve(                        拉取最新版本的网页(请求)                            .then(填入缓存并返回内容)<span class=\"hljs-comment\">//返回缓存</span>                    )                }, <span class=\"hljs-number\">0</span>);<span class=\"hljs-comment\">//表示立刻执行,优先级最高</span>                setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {                    resolve(返回错误提示())                }, <span class=\"hljs-number\">5000</span>)<span class=\"hljs-comment\">//5000ms后如果没有返回最新内容就直接返回错误提示,如果成功了此次返回是无效的</span>            }        }, <span class=\"hljs-number\">0</span>)<span class=\"hljs-comment\">//这里需要一个大settimeout包裹以便于踢出主线程,否则无法并行处理</span>    })}</code></pre></div>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E4%BC%98%E5%8C%96%E9%A6%96%E5%B1%8F\" class=\"headerlink\" title=\"优化首屏\"></a>优化首屏</h1>\n<h2>\n<a href=\"https://blog.cyfan.top/#window-stop-%E4%B8%8E%E6%AD%BB%E7%A5%9E%E6%93%A6%E8%82%A9%E8%80%8C%E8%BF%87\" class=\"headerlink\" title=\"window.stop - 与死神擦肩而过\"></a>window.stop - 与死神擦肩而过</h2>\n<p>事实上，ServiceWorker最显著的缺点是要在第一次加载网页安装后，刷新一次才能激活。即访客第一次访问是不受sw控制的。换句话说，访客首屏不受加速，其加载速度与你的服务器有直接联系 <del>[虽然安装完成后就起飞了,但安装前就是屑]</del>。</p>\n<p>而本人未成年，浙江的规定又是未成年不得备案，在加上之后备案主题切换异常的麻烦。我的决定是至少高考前都不会备案。那这后果就很直接，我并不能使用国内的cdn节点。再加上我又没这个经济实力用香港CN2或拉iplc专线，对首屏服务器这一块优化其实能做的很少。</p>\n<p>更加令人抓狂的是，在首屏加载时，静态资源会被直接获取，并且不缓存，而sw激活后又会强制第二次获取，拉跨速度。</p>\n<p>不过我们可以尽可能弱化这一劣势。我们可以用js打断所有的请求，以确保首屏只加载一个html和一个sw.js，其余资源都不会加载，降低首屏加载延迟。</p>\n<p>我们尽可能将打断代码提到<code>&lt;head&gt;</code> 以确保不被其他资源堵塞，对于hexo来说打开主题的<code>head.ejs</code>，在<code>&lt;head&gt;</code>标签靠前的位置中加入：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\">(<span class=\"hljs-keyword\">async</span> () =&gt; {<span class=\"hljs-comment\">//使用匿名函数确保body已载入</span>    <span class=\"hljs-comment\">/*    ChenBlogHelper_Set 存储在LocalStorage中,用于指示sw安装状态    0 或不存在 未安装    1 已打断    2 已安装    3 已激活,并且已缓存必要的文件(此处未写出,无需理会)    */</span>    <span class=\"hljs-keyword\">const</span> $ = <span class=\"hljs-built_in\">document</span>.querySelector.bind(<span class=\"hljs-built_in\">document</span>);<span class=\"hljs-comment\">//语法糖</span>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'serviceWorker'</span> <span class=\"hljs-keyword\">in</span> navigator) { <span class=\"hljs-comment\">//如果支持sw</span>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-built_in\">window</span>.localStorage.getItem(<span class=\"hljs-string\">'ChenBlogHelper_Set'</span>)) &lt; <span class=\"hljs-number\">1</span>) {            <span class=\"hljs-built_in\">window</span>.localStorage.setItem(<span class=\"hljs-string\">'ChenBlogHelper_Set'</span>, <span class=\"hljs-number\">1</span>)            <span class=\"hljs-built_in\">window</span>.stop()            <span class=\"hljs-built_in\">document</span>.write(<span class=\"hljs-string\">'Wait'</span>)        }        navigator.serviceWorker.register(<span class=\"hljs-string\">`/sw.js?time=<span class=\"hljs-subst\">${ranN(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">88888888888888888888</span>)}</span>`</span>)<span class=\"hljs-comment\">//随机数,强制更新</span>            .then(<span class=\"hljs-keyword\">async</span> () =&gt; {                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-built_in\">window</span>.localStorage.getItem(<span class=\"hljs-string\">'ChenBlogHelper_Set'</span>)) &lt; <span class=\"hljs-number\">2</span>) {                    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {                        <span class=\"hljs-built_in\">window</span>.localStorage.setItem(<span class=\"hljs-string\">'ChenBlogHelper_Set'</span>, <span class=\"hljs-number\">2</span>)                        <span class=\"hljs-comment\">//window.location.search = `?time=${ranN(1, 88888888888888888888)}` //已弃用,在等待500ms安装成功后直接刷新没有问题</span>                        <span class=\"hljs-built_in\">window</span>.location.reload()<span class=\"hljs-comment\">//刷新,以载入sw</span>                    }, <span class=\"hljs-number\">500</span>)<span class=\"hljs-comment\">//安装后等待500ms使其激活</span>                }            })            .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">`ChenBlogHelperError:<span class=\"hljs-subst\">${err}</span>`</span>))    }})()</code></pre></div>\n<p>当然了，这回导致白屏500ms，如果你觉得不好看，也可以和我一样载入一个等待界面，将<code>document.write()</code>改为:</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">document</span>.body.innerHTML = <span class=\"hljs-keyword\">await</span> (<span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">'https://npm.elemecdn.com/chenyfan-blog@1.0.13/public/notice.html'</span>)).text()</code></pre></div>\n<p>即可</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r18/2.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96-%E7%BB%9D%E6%9C%9B%E4%B8%AD%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E6%A0%B9%E7%A8%BB%E8%8D%89\" class=\"headerlink\" title=\"主服务器优化 - 绝望中的最后一根稻草\"></a>主服务器优化 - 绝望中的最后一根稻草</h2>\n<p>实际上我一直以为，主服务器的优化在整个网站中是最必要的，也是最不重要的。必要的原因是它关系到最初的加载速度，也是访客中最主要的一环；不重要的是相对于静态资源的记载、页面的渲染和脚本的编译，首屏的加载对整体效果太小了。</p>\n<p>尤其是在sw托管后，之后的所有访问，除了sw的更新（以及所有镜像源全炸后），基本与主服务器脱离了关系，正常访问与其没有关系。加速源站实则没有必要。</p>\n<p>当然，你说有用吗，那肯定还有点用处，至少首次加载不至于卡人心态。我的要求很简单，能在600ms内完成首次html下载的基本就没问题了。<br>最优的无非是香港CN2，不过我们没这个能力。退而求其次，普通的香港服务器我们也能接受。不过依旧是白嫖至上的念头，我才用了Vercel。Vercel也是可以自选节点（主要是亚马逊和谷歌）的，我稍加测试【主要注重可连接性，其次是延迟。丢包和速度作为建站（尤其只有一个10kb的网页）最次】，决定使用一下策略：</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">电信 <span class=\"hljs-number\">104.199</span><span class=\"hljs-number\">.217</span><span class=\"hljs-number\">.228</span> 【台北 谷歌Cloud】 <span class=\"hljs-number\">70</span>ms （绕新加坡 但是是质量最好的）联通 <span class=\"hljs-number\">18.178</span><span class=\"hljs-number\">.194</span><span class=\"hljs-number\">.147</span> 【日本 亚马逊】 <span class=\"hljs-number\">45</span>ms （<span class=\"hljs-number\">4837</span>和aws在tyo互联）移动 <span class=\"hljs-number\">18.162</span><span class=\"hljs-number\">.37</span><span class=\"hljs-number\">.140</span> 【香港 谷歌Cloud】 <span class=\"hljs-number\">60</span>ms （移动去香港总是最好的选择）</code></pre></div>\n<p>在这里，不推荐其他地区的理由是：</p>\n<p>电信：基本上除了台北，去GoogleCloud的都是走日本ntt × ； 亚马逊这一块有大部分绕美，去日本延迟异常的大。<br>联通：去香港的绕美了，去日本这一条存在这直接的互联点，负载比较小，延迟也不错。<br>移动：没什么好说的，移动互联除了去亚太的都是垃圾。</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E5%90%8E%E8%AE%B0\" class=\"headerlink\" title=\"后记\"></a>后记</h1>\n<p>一张思维导图总结全文，你学废了吗？</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r18/3.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n","link":"https://blog.cyfan.top/p/d3c51290.html"},{"title":"使用 Next.js + Hexo 重构我的博客","date":"2022-03-17 16:24:00","description":"\n<p>在咕咕了一整年、只发布了三篇文章（其中两篇还是译文）之后，我决定还是稍微花一点时间好好折腾一下自己的博客，以 React 作为抓手，通过 Next.js 和 Hexo 深度共建，对标 Gatsby，打通静态 HTML 与用户交互之间的垂直领域屏障，实现多维矩阵闭环，为个人博客赋能（咳咳咳），然后水出 2022 年第一篇文章（逃）技术选型：Gatsby vs Next.js我使用 Hexo 驱动博客已经三年之久了，之前写过一个 开源的 Hexo 主题，后来还成为了 Hexo 的 Core Team Member、为 Hexo 贡献了不少代码。Hexo 是一个诞生于 2012......</p>\n<img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/218492/18/14257/25439/6227858fE1517791d/63119f6e39dc9389.png\"><br><p>请前往 <a href=\"https://blog.skk.moe/post/use-nextjs-and-hexo-to-rebuild-my-blog/\">https://blog.skk.moe/post/use-nextjs-and-hexo-to-rebuild-my-blog/</a> 阅读全文</p>\n","link":"https://blog.skk.moe/post/use-nextjs-and-hexo-to-rebuild-my-blog/"},{"title":"关于枫糖博客事件的正面回应","date":"2022-02-03 04:57:45","description":"\n<p>如果你能看到这篇文章,那真的很抱歉,说明枫糖这人又开始作妖了.</p>\n<a></a><p>首先我们把事情捋一遍.</p>\n<blockquote><p>由于其博客已被其主动关闭,所有证据均是从我能收集到的部分截图的,包括网页快照和WayBackMachine</p></blockquote>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E4%BB%96%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88\" class=\"headerlink\" title=\"他干了什么\"></a>他干了什么</h1>\n<p>首先,这人在<a href=\"https://blog.maplesugar.top/valine-prank/\" target=\"_blank\" rel=\"noopener\">对valine评论系统的恶作剧</a>一文中详细阐述了自己刷Valine的经过.原文可能打不开,你可以通过<a href=\"https://webcache.googleusercontent.com/search?q=cache:x-4Jwl2NkGUJ:https://blog.maplesugar.top/valine-prank/+&amp;cd=1&amp;hl=zh-CN&amp;ct=clnk\" target=\"_blank\" rel=\"noopener\">谷歌快照</a>或<a href=\"https://web.archive.org/web/20211211161854/https://blog.maplesugar.top/valine-prank/\" target=\"_blank\" rel=\"noopener\">网页时光机</a>阅读原文.</p>\n<p>在这篇文章中,他以高调的形式,讲述自己如何利用Valine的XSS漏洞给他人网页植入恶意js脚本:</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/1.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>并且认为很好玩:</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/1.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>就这一点就可以看出他的态度极其不端正,以恶作剧别人来取乐自己.</p>\n<p>经过别人提醒,他暂时隐藏了脚本:</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/2.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>但仍保持无所谓态度,并且强加因果,以<code>因为我攻击了Valie</code>推出<code>我帮Valine修复了漏洞</code></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/2.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>并且<a href=\"https://webcache.googleusercontent.com/search?q=cache:LI2ze-Z6N3cJ:https://blog.maplesugar.top/valine-prank-think/+&amp;cd=2&amp;hl=zh-CN&amp;ct=clnk\" target=\"_blank\" rel=\"noopener\">依旧偏执保持着自己的观点(GoogleCache)</a></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/3.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p><a href=\"https://blog.maplesugar.top/valine-prank-statistic/\" target=\"_blank\" rel=\"noopener\">仍然继续发文炫耀(源站,目前是关闭的)</a>:</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/3.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>对Valine的恶意攻击其实不在少数,据我所知,<a href=\"https://xiaokang.top/\" target=\"_blank\" rel=\"noopener\">小康</a>也写过用python脚本恶意刷Valine的脚本.</p>\n<p>然后关于我,我并不是受害者.我在看到群里头群友一直在辱骂他,顺便点进去看了看,然后立刻就被这奇葩的三观震惊到了.最后,我在他博客上留言:</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/4.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>首先我承认你的ctf技术比大多数人好，包括我，但利用漏洞攻击别人，赢得所谓的虚荣心，这就是你所说的技艺高超？你的行为已经严重影响到了别人的正常使用，即使你对valine不满，或对其他人的博客心存嫉妒，大可自己努力学习，写出更好的评论系统或文章，从正面碾压别人，赢得大家掌声，让人家心服口服，而不是恶心别人，做那君子行为，万世流芳。</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%A5%E5%A4%8D\" class=\"headerlink\" title=\"我为什么要报复\"></a>我为什么要报复</h1>\n<p>首先,他是这么回复的:</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/4.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>纯粹是<strong>纯粹是为了玩一下哦</strong>,<strong>就几个评论，删除就完了，也不会对博主造成什么困扰啊？</strong>,能说出这种言论的,绝大多数都是反社会人格,偏激,自我主义,丝毫不顾忌他人感受.如果你是开玩笑,那么玩笑是建立在<strong>对方也觉得好笑</strong>的时候才能成立,否则这只能成为单方面的攻击,那么就没有理由在对方反击你的时候狡辩.</p>\n<p><strong>我恶作剧一两天，valine就发布了新版本，valine可是十多个月没有修复了，我怎么说也算有点贡献吧？</strong> 首先,Valine是个个人维护的开源项目,如果你发现了漏洞,应当是直接提出issue并等待修复,这才是一个正确的解决方法路径.即使你认为Valine开发者懒,不敲打就不会更新,那你也更不应该滥用此漏洞攻击无辜之人,从而满足自己的扭曲的虚荣心和变态的恶作剧心理.</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/5.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p><strong>手持利刃,刀口不应指向无辜之人</strong></p>\n<p><span class=\"heimu\">更何况,这还是把钝刀</span></p>\n<p>留完言后,我就简单的看了一下他的回答,摇头叹息,这人怎么说道理都没用,三观已经腐化了.然后我就没有继续关注这件事情.</p>\n<p>当然,我也在Valine群和其他水群中继续听闻了这件事情,但一直都没有怎么放在心上.</p>\n<p>直到大过年翻邮件的时候看到了新的回复:</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/5.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p><code>懵</code>字都不会写,小学生确认完毕,三年级不能再多了.</p>\n<p>这令我感到气愤而难过,如此欠揍又油盐不进,然后我赶到他的博客底下翻了翻</p>\n<p>有人只是解析出了其博客CloudFlareCDN节点的ip,被他嘲讽了一波.</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/7.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>以及他还挺欢迎别人搞他博客的?</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/8.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>于是我直接找到了他的源站地址,并小小的威胁了他一下:</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/6.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>但是他是这么回复的:</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/6.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>我并不是那种<strong>锱铢必较</strong>的人,但他这份言论侮辱了我的人格和我的父母,既然找到了他的源ip,那我就对其小小的报复了一下.</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E6%8A%A5%E5%A4%8D%E7%9A%84%E7%BB%93%E6%9E%9C\" class=\"headerlink\" title=\"报复的结果\"></a>报复的结果</h1>\n<p>CC攻击流量150GB持续两小时,UDPFlood流量600GB持续半小时,CC数据库高频查询200线程持续一小时</p>\n<p>UDP攻击似乎大部分被DigitalOcean防火墙吃了,于是简单打了一下就主用CC</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/9.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/10.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E8%AF%81%E6%8D%AE%E6%88%AA%E5%9B%BE\" class=\"headerlink\" title=\"证据截图\"></a>证据截图</h1>\n<h2>\n<a href=\"https://blog.cyfan.top/#2-2-10-24pm\" class=\"headerlink\" title=\"2-2 10:24pm\"></a>2-2 10:24pm</h2>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/11.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h2>\n<a href=\"https://blog.cyfan.top/#2-2-10-39pm\" class=\"headerlink\" title=\"2-2 10:39pm\"></a>2-2 10:39pm</h2>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/7.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h2>\n<a href=\"https://blog.cyfan.top/#2-2-10-53pm\" class=\"headerlink\" title=\"2-2 10:53pm\"></a>2-2 10:53pm</h2>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/8.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h2>\n<a href=\"https://blog.cyfan.top/#2-2-10-57pm\" class=\"headerlink\" title=\"2-2 10:57pm\"></a>2-2 10:57pm</h2>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/13.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h2>\n<a href=\"https://blog.cyfan.top/#2-2-11-03pm\" class=\"headerlink\" title=\"2-2 11:03pm\"></a>2-2 11:03pm</h2>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/8.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h2>\n<a href=\"https://blog.cyfan.top/#2-2-11-06pm\" class=\"headerlink\" title=\"2-2 11:06pm\"></a>2-2 11:06pm</h2>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/13.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h2>\n<a href=\"https://blog.cyfan.top/#2-2-11-23pm\" class=\"headerlink\" title=\"2-2 11:23pm\"></a>2-2 11:23pm</h2>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/14.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h2>\n<a href=\"https://blog.cyfan.top/#2-2-11-33pm\" class=\"headerlink\" title=\"2-2 11:33pm\"></a>2-2 11:33pm</h2>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/15.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h2>\n<a href=\"https://blog.cyfan.top/#2-3-00-01pm\" class=\"headerlink\" title=\"2-3 00:01pm\"></a>2-3 00:01pm</h2>\n<blockquote><p>此时对面博客已经打垮了,这是在我的博客上留言的</p></blockquote>\n<blockquote><p>注意时间是在上文睡觉后发的</p></blockquote>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/16.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h2>\n<a href=\"https://blog.cyfan.top/#2-3-00-02pm\" class=\"headerlink\" title=\"2-3 00:02pm\"></a>2-3 00:02pm</h2>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/17.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h2>\n<a href=\"https://blog.cyfan.top/#2-3-00-03pm\" class=\"headerlink\" title=\"2-3 00:03pm\"></a>2-3 00:03pm</h2>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/18.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h2>\n<a href=\"https://blog.cyfan.top/#2-3-00-05pm\" class=\"headerlink\" title=\"2-3 00:05pm\"></a>2-3 00:05pm</h2>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/19.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/20.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E6%88%91%E7%9A%84%E6%AD%A3%E9%9D%A2%E5%9B%9E%E5%BA%94\" class=\"headerlink\" title=\"我的正面回应\"></a>我的正面回应</h1>\n<p>首先总结一下骂人规律:以妈为中心,亲戚关系为半径,以性侮辱性关系为立体维度,画个球,然后在这个集合里面一个一个骂过去,主用你妈的,次用我是你爹,夹带白莲花 大头鬼等高端词语,尝试用强加伦理关系压制,并且搞不过就创造一个子虚乌有的高级朋.最后尝试各种侮辱性脏字堵住别人的嘴.</p>\n<p>这种行为极其类似鲁迅笔下的阿Q,试图强加一个单方面的伦理关系自我满足,妥妥的一个可怜的小人行为，以这种姿态还想妄称为别人的爹，简直就是小丑行为。</p>\n<p>以及各种奇葩言论，前叫嚣<strong>特别期待</strong>,后面又试图搬出一个朋友威胁我不要攻击;宣称自己有很多流量,被刷的时候又破口大骂;以及用自己扭曲的价值观来妄图矫正我的观点.</p>\n<p>所有的言论更像是出于一种宣泄情绪的存在,没有共情能力,满口脏字却词汇贫乏,丝毫不见理性.</p>\n<p>关于攻击理由，我并不是无缘无故就照着你的博客开始打，大部分人应该能看出其恶意。你攻击别人的行为只是处于一种恶趣味，尝试通过入侵的方式满足自己扭曲的傲气。并且你攻击别人的方式甚至不是自己研究出来的，而是照抄issue里面的样例代码实行攻击。而我攻击的原因是你侮辱了我，并且你自身完全没有意识到自己的错误，依旧偏执地认为自己只是开个玩笑无伤大雅。</p>\n<p><strong>这几把小学生的脾气，调侃一句就受不了了？</strong>如果你认为我是小学生脾气,并且你认为你的行为是调侃,那我并不承认.你的各种言语已经严重侵犯了我的人格,并且,在说我脾气不好的时候,请你自己看看你是为什么攻击别人的呢?</p>\n<p><a href=\"https://webcache.googleusercontent.com/search?q=cache:LI2ze-Z6N3cJ:https://blog.maplesugar.top/valine-prank-think/+&amp;cd=2&amp;hl=zh-CN&amp;ct=clnk\" target=\"_blank\" rel=\"noopener\">valine恶作剧回忆录(GoogleCache)</a></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r12/12.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>只是<code>那就别用</code>,并没有主动挑衅,一句简单的拒绝的话语连基本情感语句都读不出,还多次踩点报复.你这又是何德称我为<code>小学生</code>呢.</p>\n<p>既然你认为我要早点搞死你,那我就真的这么做了.</p>\n<p>如果你只是认为关站只是看不起我,那抱歉,在互联网中,这种攻击行为无论是<strong>君子游戏</strong>还是<strong>恶意打击</strong>,只要你防御不住，关站了，就意味着投降，无论是基于什么原因。</p>\n<p>你认为我的攻击方式很low,只要你是选择了投降,就意味着你是个loser.然而loser是完全没有资格在君子游戏后还继续嘲讽。</p>\n<p>无论我使用什么技术，你关站了，就意味着认输，你也就失去了对我挑衅的资格。</p>\n<p>更可笑的是，在防御不住的时候还要搬出子虚乌有的朋友，声称上面有重要文件。你应该在高调宣称自己就是攻击者的时候就要做好防御措施，而不是发一份无能狂怒的威胁信。</p>\n<p>如果你继续把你的行为称之为高尚，我只能说包括我在内，大部分人都不会附和。这完全是一种强加意愿，不顾他人的三观腐败行为，妥妥的九年义务教育没读完的那种。</p>\n<p>你这种行为已经欺辱到我的人格，你可以不赞同我说的话，但你不能对我人身攻击。我不是那种锱铢必较的人，更非虚与委蛇，你对我造成了侮辱，我必定会报复。</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#End\" class=\"headerlink\" title=\"End\"></a>End</h1>\n<p>可能会有人认为我报复的手段可能过于残忍，但对于我来说已经是最快捷的报复方式了，并且对于这种人来说，以牙还牙最为简便。</p>\n<p>至于枫糖，你如果还想对线请只在这篇文章下骂，并且麻烦不要带脏字。我甚至可以给你搞一个置顶，只要你不担心别人把你喷死就行。</p>\n","link":"https://blog.cyfan.top/p/c0af8fff.html"},{"title":"欲善其事，必利其器 - 论如何善用ServiceWorker","date":"2022-01-16 13:57:45","description":"\n<p>ServiceWorker作为前端革命领袖，毫不夸张地被誉为前端黑科技，此文将阐述如何巧妙的使用它来实现一些看起来匪夷所思的事情。</p>\n<a></a><blockquote><p><strong>Warning</strong><br>此文为最基本的SW使用基础,如果你只是想来白嫖代码的建议退出选择下一篇实操文章.</p></blockquote>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E8%B5%B7%E5%9B%A0-%E5%B7%A8%E5%8E%A6%E5%9D%8D%E5%A1%8C\" class=\"headerlink\" title=\"起因 - 巨厦坍塌\"></a>起因 - 巨厦坍塌</h1>\n<p>2021/12/20日，赶在旧年的末尾，一则<code>JSdelivrSSL证书错误</code>缓缓上了v2ex论坛热点。</p>\n<p>此前JSD由于各种原因,曾经不正常了一段时间,所以大家并未对此感冒.正当人们以为这只是JSdelivr每年一度的<code>年经</code>阵痛,发个issue,过一段时间就好了的时候.官方直接爆出大料:<strong>JSDelivr had lost their ICP license</strong></p>\n<p>由此可见,过去的几年里,当人们发现JSD对个人面向国内加速拥有者无与伦比的效果时,各种滥用方式层出不穷:图床曾一阵流行,国内搜索引擎JSdelivr十有八九都是作为图床的,连PicGo插件都出了Github+JSdelivr图床;猛一点的,直接做视频床,甚至为了突破单文件20M限制开发了一套ts切片m3u8一条龙服务;作妖的,托管了不少突破网络审查的脚本和规则集;寻死的,添加了大量的政治宗教敏感,有些甚至不配称为宗教,直接上来就是骗钱的.</p>\n<p>jsd并不是没有发布许可条款，但这并不能阻止白嫖大军的进程。在羊毛大军中，只要是你是免费的、公益的，你就要做好被薅爆的结果。但是薅羊毛的前提是羊还活着，倘若羊被薅死了，哪来的羊毛给诸君所薅？</p>\n<p>总之，不管怎样，JSDelivr在决定将节点设置为<code>NearChina</code>，可以肯定的是，在最近很长一段时间内，我们都无法享受国内外双料同时加速的快感，换句话说，jsd在中国就被永久地打入了冷宫。</p>\n<p>视线转向国内，jsd的替代品并不少。早在我写<a href=\"https://blog.cyfan.top/p/eb490c73.html\">图床的千层套路</a>我就试着假想jsd不可用时，我们该用什么。最终我给出的一份较为完美的答案-npm图床，优点无非就是镜像多速度快，许可条款较为宽松，缺点也很明显，需要安装node，用专门的客户端上传。</p>\n<p>那事情就逐渐变得扑朔迷离起来了，我们应当如何选择合理的CDN加速器呢。</p>\n<p>这时候，我想起了前端黑科技Serviceworker。是的，这种情况下使用SW最为巧妙不过，它可以在后台自动优选最佳的CDN，甚至可以用黑中黑<code>Promise.any</code>打出一套漂亮的并行拳。经过两天的完善，我终于写出了一套具有离线可达、绕备、优选CDN、跟踪统计合一的SW脚本。<a href=\"https://blog.cyfan.top/sw.js\">此博客使用的SW</a></p>\n<p>接下来我将从头开始讲述ServiceWorker的妙用。</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#Before-Start\" class=\"headerlink\" title=\"Before Start\"></a>Before Start</h1>\n<h2>\n<a href=\"https://blog.cyfan.top/#What-Is-The-ServiceWorker\" class=\"headerlink\" title=\"What Is The ServiceWorker\"></a>What Is The ServiceWorker</h2>\n<p>网上对于SW的解释比较模糊，在这里，我将其定义为<code>用户浏览器里的服务器</code>，功能强大到令人发指。是的，接下来的两张图你应该能显著的看到这一差距：</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r5/1.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt=\"没有ServiceWorker中继，平淡无奇\"></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r5/2.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt=\"ServiceWorker中继，刺激拉满\"></p>\n<p>在第一张图中，用户和服务器的关系直的就像电线杆，用户想要什么，服务器就还给他什么。</p>\n<p>第二张图中，用户在被ServiceWorker控制的页面中，无论向哪个服务器发起请求，其过程都会被SW捕获，SW可以仿佛不存在一般单纯地请求服务器，返回原本应该返回的内容【透明代理】；也可以对当前服务器返回的内容进行随意的捏造、修改【请求修改结果】；甚至可以将请求指向完全另一台服务器，返回不是此服务器应该返回的内容【移花接木】；当然，SW也可以直接返回已经存储在本地的文件，甚至离线的时候也能返回【离线访问可达性】。</p>\n<p>由于SW对于用户页面的操纵实在过于强大，因此，它被设计成<code>不可跨域请求</code>、<code>SW脚本必须在同一域名下</code>、<code>必须在HTTPS条件下运行</code>、<code>不可操纵DOM和BOM</code>，同样的，为了避免阻塞和延迟，SW也被特意设计成<code>完全异步的</code>。这些点将会在后面一一讲述。</p>\n<blockquote><p>当然，开发者至上，为了方便本地调试，本机地址<code>localhost</code>和<code>127.0.0.1</code>被浏览器所信任，允许以<code>非HTTPS</code>方式运行serviceworker。</p></blockquote>\n<h2>\n<a href=\"https://blog.cyfan.top/#What-Relationship-Between-ServiceWorker-and-PWA\" class=\"headerlink\" title=\"What Relationship Between ServiceWorker and PWA\"></a>What Relationship Between ServiceWorker and PWA</h2>\n<p>很多人看到sw，第一反应是PWA，即渐进式Web应用。实际上，SW确实是PWA的核心与灵魂，但SW在PWA中起的主要作用是缓存文件，提供给离线访问。并没有完整地发挥出SW的巧妙用法。</p>\n<p>SW可以完全脱离PWA存在，当然，PWA可离不开SW ：）</p>\n<h2>\n<a href=\"https://blog.cyfan.top/#And-WorkBox\" class=\"headerlink\" title=\"And WorkBox ?\"></a>And WorkBox ?</h2>\n<p>WorkBox是谷歌开发的一款基于SW的缓存控制器，其主要目的是方便维护PWA。核心依旧是SW，但还是没有SW原本的自定义程度高（</p>\n<h2>\n<a href=\"https://blog.cyfan.top/#Why-Not-WorkBox\" class=\"headerlink\" title=\"Why Not WorkBox ?\"></a>Why Not WorkBox ?</h2>\n<p>首先，博客呢，是没有必要用PWA，有SW做中间件足矣。同时，WorkBox只能简单的缓存数据，并不能做到拦截篡改请求的功能，尤其不能精准把握每一个资源的缓存情况，自定义程度并不高。</p>\n<p><del>自己编写SW，格局就打开了</del></p>\n<h1>\n<a href=\"https://blog.cyfan.top/#Start-From-Zero\" class=\"headerlink\" title=\"Start From Zero\"></a>Start From Zero</h1>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E5%AE%89%E8%A3%85-Install\" class=\"headerlink\" title=\"安装 / Install\"></a>安装 / Install</h2>\n<p>首先，SW的本质是JS脚本，要安装它必须要经过一个html。毕竟，只有拿到了html，JS才能运行于DOM上下文。</p>\n<p>剥离层层加成，安装的代码只有一行</p>\n<div class=\"hljs\"><pre><code class=\"hljs JavaScript\">navigator.serviceWorker.register(<span class=\"hljs-string\">'/sw.js'</span>)</code></pre></div>\n<p>其中，<code>/sw.js</code>即为ServiceWorker脚本所在，由于安全性，你不能加载跨域的SW。</p>\n<p>例如，当前网页为<code>https://blog.cyfan.top</code>，以下加载位置是允许的</p>\n<div class=\"hljs\"><pre><code class=\"hljs url\">/sw.jshttps://blog.cyfan.top/sw.js</code></pre></div>\n<p>以下加载是不允许的:</p>\n<div class=\"hljs\"><pre><code class=\"hljs url\">http://blog.cyfan.top/sw.js#非HTTPShttps://cyfan.top/sw.js#非同一域名，视为跨域https://119.91.80.151:59996/sw.js#虽然为同一文件,但非同一域名，视为跨域./sw.js#容易造成SW脚本获取路径不一致</code></pre></div>\n<p>在加载前，我们最好判断一下dom是否加载完了，不然安装sw可能会卡dom</p>\n<p>加载完成后，register函数将返回一个<code>Promise</code>，由于前端大多不适用于<code>异步</code>，我们通常以<code>同步</code>的方式<code>.then()</code>和<code>.catch()</code>来获取是否加载成功。</p>\n<p>为了方便判断脚本是否能够加载，我们还要判断navigator里有无sw这一属性<code>'serviceWorker' in navigator</code>。</p>\n<p>由于SW安装后，页面需要刷新后才能交给SW所宰割，同时为了避免浏览器缓存的影响，我通常采用修改<code>search</code>的方式强刷新，而不是通过<code>reload</code>函数。同样的，为了避免刚安装完就刷新的尴尬感，建议用<code>setTimeout</code>延迟一秒刷新。</p>\n<p>简易的完整安装代码如下:</p>\n<div class=\"hljs\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'load'</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {    navigator.serviceWorker.register(<span class=\"hljs-string\">`/sw.js?time=<span class=\"hljs-subst\">${<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime()}</span>`</span>)        .then(<span class=\"hljs-keyword\">async</span> reg =&gt; {            <span class=\"hljs-comment\">//安装成功，建议此处强刷新以立刻执行SW</span>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">window</span>.localStorage.getItem(<span class=\"hljs-string\">'install'</span>) != <span class=\"hljs-string\">'true'</span>) {                <span class=\"hljs-built_in\">window</span>.localStorage.setItem(<span class=\"hljs-string\">'install'</span>, <span class=\"hljs-string\">'true'</span>);                setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {                    <span class=\"hljs-built_in\">window</span>.location.search = <span class=\"hljs-string\">`?time=<span class=\"hljs-subst\">${<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime()}</span>`</span>                }, <span class=\"hljs-number\">1000</span>)            }        }).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {            <span class=\"hljs-comment\">//安装失败，错误信息会由err传参</span>        })});</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre></div>\n<p>一刷新，世界就变成了ServiceWorker的瓮中之鳖，接下来，该是SW脚本正式登场的时候了。</p>\n<h2>\n<a href=\"https://blog.cyfan.top/#SW%E5%AE%89%E8%A3%85%E5%88%9D%E5%A7%8B%E5%8C%96-Installations\" class=\"headerlink\" title=\"SW安装初始化 / Installations\"></a>SW安装初始化 / Installations</h2>\n<p>首先，先尴尬的开一个空缓存列表：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> CACHE_NAME = <span class=\"hljs-string\">'ICDNCache'</span>;<span class=\"hljs-comment\">//可以为Cache版本号，但这样可能会导致缓存冗余累积</span><span class=\"hljs-keyword\">let</span> cachelist = [];</code></pre></div>\n<p><code>cachelist</code>里面填写的是预缓存网址，例如在离线时返回的错误页面。此处不宜添加过多网址，此处点名@一下Akilar。</p>\n<p>此处我建议只缓存离线页面展示的内容:</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> cachelist = [    <span class=\"hljs-string\">'/offline.html'</span>,    <span class=\"hljs-string\">'https://npm.elemecdn.com/chenyfan-os@0.0.0-r6'</span>];</code></pre></div>\n<p>同时监听sw安装时开启此缓存空间：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\">self.addEventListener(<span class=\"hljs-string\">'install'</span>, <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">installEvent</span>) </span>{    self.skipWaiting();    installEvent.waitUntil(        caches.open(CACHE_NAME)            .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">cache</span>) </span>{                <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Opened cache'</span>);                <span class=\"hljs-keyword\">return</span> cache.addAll(cachelist);            })    );});</code></pre></div>\n<p>由于SW完全没有办法访问DOM，因此对于全局变量，不应当用<code>window</code>，而是<code>self</code>指代自己。</p>\n<p><code>addEventListener</code>这一监听器将监听<code>install</code>,也就是这一段代码只会在脚本首次安装和更新时运行.</p>\n<p><code>skipWaiting</code>的作用是促进新版本sw跳过waiting这一阶段，直接active。</p>\n<blockquote><p>关于SW的状态（waiting，installing，activing）将在文后详细解释。</p></blockquote>\n<p><code>installEvent.waitUntil</code>的作用是直接结束安装过程的等待，待会在后台完成开启缓存空间这一操作。</p>\n<p><code>cache.addAll</code>将会直接获取<code>cachelist</code>里面所有的网址并直接缓存到CacheStorage。如果此处网址过多，将在页面加载时疯狂请求所有的url<del>(例如1k个)</del></p>\n<p>现在，SW初始化已经完成了。接下来，我将讲述SW如何捕获页面的请求。</p>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E6%8D%95%E8%8E%B7%E8%AF%B7%E6%B1%82-Fetch-Event\" class=\"headerlink\" title=\"捕获请求 / Fetch Event\"></a>捕获请求 / Fetch Event</h2>\n<h3>\n<a href=\"https://blog.cyfan.top/#%E6%B7%BB%E5%8A%A0%E7%9B%91%E5%90%AC%E5%99%A8-AddEventListener\" class=\"headerlink\" title=\"添加监听器 / AddEventListener\"></a>添加监听器 / AddEventListener</h3>\n<div class=\"hljs\"><pre><code class=\"hljs js\">self.addEventListener(<span class=\"hljs-string\">'fetch'</span>, <span class=\"hljs-keyword\">async</span> event =&gt; {    event.respondWith(handle(event.request))});<span class=\"hljs-keyword\">const</span> handle = <span class=\"hljs-keyword\">async</span>(req)=&gt;{    <span class=\"hljs-comment\">//do something</span>}</code></pre></div>\n<p>第一行很简单，绑定一个监听器，监听<code>fetch</code>事件，即网页向服务器获取请求，也就是相当于前端的<code>XMLHTTPRequest</code></p>\n<p><code>event.respondWith</code>即设定返回内容，交给<code>handle</code>主函数处理，传参<code>event.request</code>。这是一个<code>Request</code>对象，里面包含了请求的详细信息。</p>\n<p>接下来，我们开始实战吧。</p>\n<blockquote><p>以下所有内容均针对handle修改</p></blockquote>\n<h3>\n<a href=\"https://blog.cyfan.top/#%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86-Transparent-Proxy\" class=\"headerlink\" title=\"透明代理 / Transparent Proxy\"></a>透明代理 / Transparent Proxy</h3>\n<p>顾名思义，此实战脚本的作用是SW代理目前的所有流量但不进行修改，仿佛SW不存在一般。</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> handle = <span class=\"hljs-keyword\">async</span>(req)=&gt;{    <span class=\"hljs-keyword\">return</span> fetch(req)}</code></pre></div>\n<p><code>fetch</code>这个函数相当于前端的<code>ajax</code>或者<code>XMLHTTPRequest</code>，作用是发起一个请求，获得一个返回值。由于sw不可访问<code>window</code>，在sw中是无法使用<code>ajax</code>或<code>XMLHTTPRequest</code>。同时，<code>fetch</code>是一个异步函数，直接调用它会返回一个<code>Promise</code>。</p>\n<p><code>fetch</code>只能传递<code>Requset</code>对象,而<code>Requset</code>对象有两个参数<code>(url,[option])</code>,第一个参数是网址,第二个参数为<code>Request</code>的内容,例如<code>body</code>或<code>header</code>。</p>\n<p>此脚本适用于卸载<code>ServiceWorker</code>的替换脚本。因为sw在无法拉取新版本时不会主动卸载，依旧保持运行，填入一个透明代理sw即可。</p>\n<p>由于SW冷启动【即页面关闭后SW】处于暂停状态是从硬盘读取的，这会导致第一次请求有少许性能延迟[~10ms]。</p>\n<h3>\n<a href=\"https://blog.cyfan.top/#%E7%AF%A1%E6%94%B9%E8%AF%B7%E6%B1%82-Edit-Requset\" class=\"headerlink\" title=\"篡改请求 / Edit Requset\"></a>篡改请求 / Edit Requset</h3>\n<p>对于一张图片，有时候服务端会变态到让你必须用<code>POST</code>协议才能获得，此时用SW篡改最为方便。</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> handle = <span class=\"hljs-keyword\">async</span> (req) =&gt; {    <span class=\"hljs-keyword\">if</span> ((req.url.split(<span class=\"hljs-string\">'/'</span>))[<span class=\"hljs-number\">2</span>].match(<span class=\"hljs-string\">'xxx.com'</span>)) {        <span class=\"hljs-comment\">//xxx.com为图片所在域名</span>        <span class=\"hljs-keyword\">return</span> fetch(req.url, {            <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">\"POST\"</span>        })    }    <span class=\"hljs-keyword\">return</span> fetch(req)}</code></pre></div>\n<blockquote><p>注意，在ServiceWorker里面，header头是不能修改refferer和origin的，因此此方法无法绕开新浪图床反盗链</p></blockquote>\n<h3>\n<a href=\"https://blog.cyfan.top/#%E7%AF%A1%E6%94%B9%E5%93%8D%E5%BA%94-Edit-Response\" class=\"headerlink\" title=\"篡改响应 / Edit Response\"></a>篡改响应 / Edit Response</h3>\n<p>这个例子会检测返回内容，若为html，将把所有的”TEST”都替换成”SHIT”</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> handle = <span class=\"hljs-keyword\">async</span> (req) =&gt; {    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> fetch(req)    <span class=\"hljs-keyword\">const</span> resp = res.clone()    <span class=\"hljs-keyword\">if</span> (!!resp.headers.get(<span class=\"hljs-string\">'content-type'</span>)) {        <span class=\"hljs-keyword\">if</span> (resp.headers.get(<span class=\"hljs-string\">'content-type'</span>).includes(<span class=\"hljs-string\">'text/html'</span>)) {            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Response((<span class=\"hljs-keyword\">await</span> resp.text()).replace(<span class=\"hljs-regexp\">/TEST/g</span>, <span class=\"hljs-string\">'SHIT'</span>), {                <span class=\"hljs-attr\">headers</span>: resp.headers,                <span class=\"hljs-attr\">status</span>: resp.status            })        }    }    <span class=\"hljs-keyword\">return</span> resp}</code></pre></div>\n<p><code>const resp = res.clone()</code>由于<code>Response</code>的<code>body</code>一旦被读取，这个<code>body</code>就会被锁死，再也无法读取。<code>clone()</code>能够创造出响应的副本用于处理。</p>\n<p><code>resp.headers.get('content-type')</code>通过读取响应的头，判断是否包含<code>text/html</code>，如果是，将响应以<code>text()</code>异步流的方式读取，然后正则替换掉响应内容，并还原头和响应Code。</p>\n<p>返回的内容必须是<code>Response</code>对象，所以<code>new Response</code>构建一个新对象，并直接返回。不匹配html头将直接原封不动地透明代理。</p>\n<h3>\n<a href=\"https://blog.cyfan.top/#%E7%A7%BB%E8%8A%B1%E6%8E%A5%E6%9C%A8-Graft-Request-To-Another-Server\" class=\"headerlink\" title=\"移花接木 / Graft Request To Another Server\"></a>移花接木 / Graft Request To Another Server</h3>\n<p><code>unpkg.zhimg.com</code>是<code>unpkg.com</code>的镜像网站。此脚本将会把所有的<code>unpkg.com</code>流量直接拦截到<code>unpkg.zhimg.com</code>，用于中国大陆内CDN加速。</p>\n<p>由于npm镜像固定为GET请求方式并且没有其他鉴权需求，所以我们没有必要还原<code>Request</code>其他数据。</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> handle = <span class=\"hljs-keyword\">async</span> (req) =&gt; {    <span class=\"hljs-keyword\">const</span> domain = req.url.split(<span class=\"hljs-string\">'/'</span>)[<span class=\"hljs-number\">2</span>];    <span class=\"hljs-keyword\">if</span> (domain.match(<span class=\"hljs-string\">\"unpkg.com\"</span>)) {        <span class=\"hljs-keyword\">return</span> fetch(req.url.replace(<span class=\"hljs-string\">\"https://unpkg.com\"</span>, <span class=\"hljs-string\">\"https://zhimg.unpkg.com\"</span>));    }    <span class=\"hljs-keyword\">else</span> {        <span class=\"hljs-keyword\">return</span> fetch(req)    }}</code></pre></div>\n<p><code>domain.match</code>捕获请求中是否有待替换域名，检查出来后直接<code>replace</code>掉域名，如果没有匹配到，直接透明代理走掉。</p>\n<h3>\n<a href=\"https://blog.cyfan.top/#%E5%B9%B6%E8%A1%8C%E8%AF%B7%E6%B1%82-Request-Parallelly\" class=\"headerlink\" title=\"并行请求 / Request Parallelly\"></a>并行请求 / Request Parallelly</h3>\n<p>SW中又一大黑科技隆重登场=&gt;<code>Promise.any</code>，这个函数拥有另外两个衍生兄弟<code>Promise.all</code>&amp;<code>Promise.race</code>。下面我将简单介绍这三种方式</p>\n<h4>\n<a href=\"https://blog.cyfan.top/#Promose-all\" class=\"headerlink\" title=\"Promose.all\"></a>Promose.all</h4>\n<p>当列表中所有的<code>Promise</code>都<code>resolve</code>[即成功]后，这个函数才会返回<code>resolve</code>，只要有一个返回<code>reject</code>，整个函数都会<code>reject</code>。</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">Promise</span>.all([    fetch(<span class=\"hljs-string\">'https://unpkg.com/jquery'</span>),    fetch(<span class=\"hljs-string\">'https://cdn.jsdelivr.net/npm/jquery'</span>),    fetch(<span class=\"hljs-string\">'https://unpkg.zhimg.com/jquery'</span>)])</code></pre></div>\n<p>这个函数将会请求三个网址，当每一个网址都链接联通后，整个函数将会返回一个列表：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\">[Response1,Response2,Response3]</code></pre></div>\n<p>当任何一个<code>fetch</code>失败[即<code>reject</code>]后，整个<code>Promise.all</code>函数都会直接<code>reject</code>并报错。</p>\n<p>此函数可以检测网络连通性，由于采取并行处理，相比以前的循环效率要高不少。</p>\n<p>这是一段检测国内国外网络连通性的测试。</p>\n<p>没有采用<code>Promise.all</code>的代码和效果：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> test = <span class=\"hljs-keyword\">async</span> () =&gt; {    <span class=\"hljs-keyword\">const</span> url = [                <span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/jquery@3.6.0/package.json\"</span>,        <span class=\"hljs-string\">\"https://unpkg.com/jquery@3.6.0/package.json\"</span>,        <span class=\"hljs-string\">\"https://unpkg.zhimg.com/jquery@3.6.0/package.json\"</span>    ]    flag = <span class=\"hljs-literal\">true</span>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">in</span> url) {        <span class=\"hljs-keyword\">try</span> {            <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> fetch(url[i])            <span class=\"hljs-keyword\">if</span> (res.status !== <span class=\"hljs-number\">200</span>) {                flag = <span class=\"hljs-literal\">false</span>            }        }<span class=\"hljs-keyword\">catch</span>(n){            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>        }    }    <span class=\"hljs-keyword\">return</span> flag}</code></pre></div>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r7/1.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>采用循环，<code>await</code>会堵塞循环，直到这次请求完成后才能执行下一个。如果有任何一个url长时间无法联通，将会导致极长的检测时间浪费。</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> test = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {    <span class=\"hljs-keyword\">const</span> url = [        <span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/jquery@3.6.0/package.json\"</span>,        <span class=\"hljs-string\">\"https://unpkg.com/jquery@3.6.0/package.json\"</span>,        <span class=\"hljs-string\">\"https://unpkg.zhimg.com/jquery@3.6.0/package.json\"</span>    ]    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.all(url.map(<span class=\"hljs-function\"><span class=\"hljs-params\">url</span> =&gt;</span> {        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {            fetch(url)                .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {                    <span class=\"hljs-keyword\">if</span> (res.status == <span class=\"hljs-number\">200</span>) {                        resolve(<span class=\"hljs-literal\">true</span>)                    } <span class=\"hljs-keyword\">else</span> {                        reject(<span class=\"hljs-literal\">false</span>)                    }                })                .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {                    reject(<span class=\"hljs-literal\">false</span>)                })        })    }    )).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>    }).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>    })}</code></pre></div>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r7/2.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p><code>Promise.all</code>几乎在一瞬间请求所有的url，其请求时并行，每一个请求并不会堵塞其他请求，函数总耗时为最长请求耗时。</p>\n<h4>\n<a href=\"https://blog.cyfan.top/#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a>Promise.race</h4>\n<p>此函数也是并行执行，不过与all不同的是，只要有任何一个函数完成，就立刻返回，无论其是否<code>reject</code>或者<code>resolve</code>。</p>\n<p>这个函数比较适合用于同时请求一些不关心结果，只要访问达到了即可，例如统计、签到等应用场景。</p>\n<h4>\n<a href=\"https://blog.cyfan.top/#Promise-any\" class=\"headerlink\" title=\"Promise.any\"></a>Promise.any</h4>\n<p>这个函数非常的有用，其作用和<code>race</code>接近，不过与之不同的是，<code>any</code>会同时检测结果是否<code>resolve</code>。其并行处理后，只要有任何一个返回正确，就直接返回哪个最快的请求结果，返回错误的直接忽视，除非所有的请求都失败了，才会返回<code>reject</code></p>\n<p>这是一段同时请求<code>jquery</code>的<code>package.json</code>代码，它将从四个镜像同时请求：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> get_json = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {        <span class=\"hljs-keyword\">const</span> urllist = [            <span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/jquery@3.6.0/package.json\"</span>,            <span class=\"hljs-string\">\"https://unpkg.com/jquery@3.6.0/package.json\"</span>,            <span class=\"hljs-string\">\"https://unpkg.zhimg.com/jquery@3.6.0/package.json\"</span>,            <span class=\"hljs-string\">\"https://npm.elemecdn.com/jquery@3.6.0/package.json\"</span>        ]        <span class=\"hljs-built_in\">Promise</span>.any(urllist.map(<span class=\"hljs-function\"><span class=\"hljs-params\">url</span> =&gt;</span> {            fetch(url)                .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {                    <span class=\"hljs-keyword\">if</span> (res.status == <span class=\"hljs-number\">200</span>) {                        resolve(res)                    } <span class=\"hljs-keyword\">else</span> {                        reject()                    }                }).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {                    reject()                })        }))    })}<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">await</span>(<span class=\"hljs-keyword\">await</span> get_json()).text())</code></pre></div>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r7/3.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>函数将会在<code>21ms</code>上下返回json中的数据。</p>\n<p>此函数的好处在于可以在用户客户端判断哪一个镜像发挥速度最快，并保证用户每一次获取都能达到最大速度。同时，任何一个镜像站崩溃了都不会造成太大的影响，脚本将自动从其他源拉取信息。</p>\n<p>除非所有源都炸了，否则此请求不会失败。</p>\n<p>但是，我们会额外地发现，当知乎镜像返回最新版本后，其余的请求依旧在继续，只是没有被利用到而已。</p>\n<p>这会堵塞浏览器并发线程数，并且会造成额外的流量浪费。所以我们应该在其中任何一个请求完成后就打断其余请求。</p>\n<p><code>fetch</code>有一个<code>abort</code>对象，只要刚开始<code>new AbortController()</code>指定控制器，在<code>init</code>的里面指定控制器的<code>signal</code>即可将其标记为待打断函数，最后<code>controller.abort()</code>即可打断。</p>\n<p>那么，很多同学就会开始这么写了:</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> get_json = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {        <span class=\"hljs-keyword\">const</span> controller = <span class=\"hljs-keyword\">new</span> AbortController();        <span class=\"hljs-keyword\">const</span> urllist = [            <span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/jquery@3.6.0/package.json\"</span>,            <span class=\"hljs-string\">\"https://unpkg.com/jquery@3.6.0/package.json\"</span>,            <span class=\"hljs-string\">\"https://unpkg.zhimg.com/jquery@3.6.0/package.json\"</span>,            <span class=\"hljs-string\">\"https://npm.elemecdn.com/jquery@3.6.0/package.json\"</span>        ]        <span class=\"hljs-built_in\">Promise</span>.any(urllist.map(<span class=\"hljs-function\"><span class=\"hljs-params\">url</span> =&gt;</span> {            fetch(url,{                <span class=\"hljs-attr\">signal</span>: controller.signal            })                .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {                    <span class=\"hljs-keyword\">if</span> (res.status == <span class=\"hljs-number\">200</span>) {                        controller.abort();                        resolve(res)                    } <span class=\"hljs-keyword\">else</span> {                        reject()                    }                }).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {                    reject()                })        }))    })}<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">await</span>(<span class=\"hljs-keyword\">await</span> get_json()).text())</code></pre></div>\n<p>但很快，你就会发现它报错了：<code>Uncaught DOMException: The user aborted a request.</code>，并且没有任何数据输出。</p>\n<p>让我们看一下Network选项卡：</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r7/4.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>其中，知乎返回的最快，但他并没有完整的返回文件[源文件1.8KB，但他只返回了1.4KB]。这也直接导致了整个函数的<code>fail</code>。</p>\n<p>原因出在<code>fetch</code>上，这个函数在获得响应之后就立刻<code>resolve</code>了<code>Response</code>，但这个时候<code>body</code>并没有下载完成，即<code>fetch</code>的返回基于状态的而非基于响应内容，当其中<code>fetch</code>已经拿到了完整的状态代码，它就立刻把<code>Response</code>丢给了下一个管道函数，而此时<code>status</code>正确，<code>abort</code>打断了包括这一个<code>fetch</code>的所有请求，<code>fetch</code>就直接工作不正常。</p>\n<p>我个人采取的方式是读取<code>arrayBuffer</code>，阻塞<code>fetch</code>函数直到把整个文件下载下来。函数名为<code>PauseProgress</code></p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> get_json = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {        <span class=\"hljs-keyword\">const</span> controller = <span class=\"hljs-keyword\">new</span> AbortController();        <span class=\"hljs-keyword\">const</span> PauseProgress = <span class=\"hljs-keyword\">async</span> (res) =&gt; {            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Response(<span class=\"hljs-keyword\">await</span> (res).arrayBuffer(), { <span class=\"hljs-attr\">status</span>: res.status, <span class=\"hljs-attr\">headers</span>: res.headers });        };        <span class=\"hljs-keyword\">const</span> urllist = [            <span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/jquery@3.6.0/package.json\"</span>,            <span class=\"hljs-string\">\"https://unpkg.com/jquery@3.6.0/package.json\"</span>,            <span class=\"hljs-string\">\"https://unpkg.zhimg.com/jquery@3.6.0/package.json\"</span>,            <span class=\"hljs-string\">\"https://npm.elemecdn.com/jquery@3.6.0/package.json\"</span>        ]        <span class=\"hljs-built_in\">Promise</span>.any(urllist.map(<span class=\"hljs-function\"><span class=\"hljs-params\">url</span> =&gt;</span> {            fetch(url, {                <span class=\"hljs-attr\">signal</span>: controller.signal            })                .then(PauseProgress)                .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {                    <span class=\"hljs-keyword\">if</span> (res.status == <span class=\"hljs-number\">200</span>) {                        controller.abort();                        resolve(res)                    } <span class=\"hljs-keyword\">else</span> {                        reject()                    }                }).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {                    reject()                })        }))    })}<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">await</span>(<span class=\"hljs-keyword\">await</span> get_json()).text())</code></pre></div>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r7/5.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>在这其中通过<code>arrayBuffer()</code>方法异步读取<code>res</code>的<code>body</code>，将其读取为二进制文件，并新建一个新的<code>Response</code>，还原状态和头，然后丢给管道函数同步处理。</p>\n<p>在这里，我们就实现了暴力并发，以流量换速度的方式。同时也获得了一个高可用的SW负载均衡器。</p>\n<p>这一段函数可以这样写在SW中：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//...</span><span class=\"hljs-keyword\">const</span> lfetch = <span class=\"hljs-function\">(<span class=\"hljs-params\">urllist</span>) =&gt;</span> {    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {        <span class=\"hljs-keyword\">const</span> controller = <span class=\"hljs-keyword\">new</span> AbortController();        <span class=\"hljs-keyword\">const</span> PauseProgress = <span class=\"hljs-keyword\">async</span> (res) =&gt; {            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Response(<span class=\"hljs-keyword\">await</span> (res).arrayBuffer(), { <span class=\"hljs-attr\">status</span>: res.status, <span class=\"hljs-attr\">headers</span>: res.headers });        };        <span class=\"hljs-built_in\">Promise</span>.any(urllist.map(<span class=\"hljs-function\"><span class=\"hljs-params\">url</span> =&gt;</span> {            fetch(url, {                <span class=\"hljs-attr\">signal</span>: controller.signal            })                .then(PauseProgress)                .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> {                    <span class=\"hljs-keyword\">if</span> (res.status == <span class=\"hljs-number\">200</span>) {                        controller.abort();                        resolve(res)                    } <span class=\"hljs-keyword\">else</span> {                        reject()                    }                }).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {                    reject()                })        }))    })}<span class=\"hljs-keyword\">const</span> handle = <span class=\"hljs-keyword\">async</span> (req) =&gt; {    <span class=\"hljs-keyword\">const</span> npm_mirror = [        <span class=\"hljs-string\">'https://cdn.jsdelivr.net/npm/'</span>,        <span class=\"hljs-string\">'https://unpkg.com/'</span>,        <span class=\"hljs-string\">'https://npm.elemecdn.com/'</span>,        <span class=\"hljs-string\">'https://unpkg.zhimg.com/'</span>    ]    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> k <span class=\"hljs-keyword\">in</span> npm_mirror) {        <span class=\"hljs-keyword\">if</span> (req.url.match(npm_mirror[k]) &amp;&amp; req.url.replace(<span class=\"hljs-string\">'https://'</span>, <span class=\"hljs-string\">''</span>).split(<span class=\"hljs-string\">'/'</span>)[<span class=\"hljs-number\">0</span>] == npm_mirror[k].replace(<span class=\"hljs-string\">'https://'</span>, <span class=\"hljs-string\">''</span>).split(<span class=\"hljs-string\">'/'</span>)[<span class=\"hljs-number\">0</span>]) {            <span class=\"hljs-keyword\">return</span> lfetch(<span class=\"hljs-function\">(<span class=\"hljs-params\">(</span>) =&gt;</span> {                <span class=\"hljs-keyword\">let</span> l = []                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; npm_mirror.length; i++) {                    l.push(npm_mirror[i] + req.url.split(<span class=\"hljs-string\">'/'</span>)[<span class=\"hljs-number\">3</span>])                }                <span class=\"hljs-keyword\">return</span> l            })())        }    }    <span class=\"hljs-keyword\">return</span> fetch(req)}</code></pre></div>\n<p>另外,<code>Promise.any</code>,兼容性比较差:</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-os@0.0.0-r9/1.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>因此,我的解决办法是判断浏览器如果不支持,就提前polyfill一下:</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">Promise</span>.any) {        <span class=\"hljs-built_in\">Promise</span>.any = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">promises</span>) </span>{            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {                promises = <span class=\"hljs-built_in\">Array</span>.isArray(promises) ? promises : []                <span class=\"hljs-keyword\">let</span> len = promises.length                <span class=\"hljs-keyword\">let</span> errs = []                <span class=\"hljs-keyword\">if</span> (len === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> reject(<span class=\"hljs-keyword\">new</span> AggregateError(<span class=\"hljs-string\">'All promises were rejected'</span>))                promises.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> {                    promise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> {                        resolve(value)                    }, err =&gt; {                        len--                        errs.push(err)                        <span class=\"hljs-keyword\">if</span> (len === <span class=\"hljs-number\">0</span>) {                            reject(<span class=\"hljs-keyword\">new</span> AggregateError(errs))                        }                    })                })            })        }    }</code></pre></div>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6-Cache\" class=\"headerlink\" title=\"缓存控制 / Cache\"></a>缓存控制 / Cache</h2>\n<h3>\n<a href=\"https://blog.cyfan.top/#%E6%8C%81%E4%B9%85%E5%8C%96%E7%BC%93%E5%AD%98-Cache-Persistently\" class=\"headerlink\" title=\"持久化缓存 / Cache Persistently\"></a>持久化缓存 / Cache Persistently</h3>\n<p>对于来自CDN的流量，大部分是持久不变的，因此，如果我们将文件获得后直接填入缓存，之后访问也直接从本地缓存中读取，那将大大提升访问速度。</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> handle = <span class=\"hljs-keyword\">async</span> (req) =&gt; {    <span class=\"hljs-keyword\">const</span> cache_url_list = [        <span class=\"hljs-regexp\">/(http:\\/\\/|https:\\/\\/)cdn\\.jsdelivr\\.net/g</span>,        /(http:\\/\\/|https:\\/\\/)cdn\\.bootcss\\.com/g,        /(http:\\/\\/|https:\\/\\/)zhimg\\.unpkg\\.com/g,        /(http:\\/\\/|https:\\/\\/)unpkg\\.com/g    ]    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">in</span> cache_url_list) {        <span class=\"hljs-keyword\">if</span> (req.url.match(cache_url_list[i])) {            <span class=\"hljs-keyword\">return</span> caches.match(req).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resp</span>) </span>{                <span class=\"hljs-keyword\">return</span> resp || fetch(req).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">res</span>) </span>{                    <span class=\"hljs-keyword\">return</span> caches.open(CACHE_NAME).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">cache</span>) </span>{                        cache.put(req, res.clone());                        <span class=\"hljs-keyword\">return</span> res;                    });                });            })        }    }    <span class=\"hljs-keyword\">return</span> fetch(req)}</code></pre></div>\n<p><code>cache_url_list</code>列出所有待匹配的域名(包括http/https头是为了避免误杀其他url)，然后<code>for</code>开始遍历待列表，如果url中匹配到了，开始执行返回缓存操作。</p>\n<p>cache是一个近似于Key/Value(键名/键值)，只要有对应的<code>Request</code>(<code>KEY</code>)，就能匹配到响应的<code>Response</code>(<code>VALUE</code>)。</p>\n<p><code>caches.match(req)</code>将会试图在CacheStorage中匹配请求的url获取值，然后丢给管道同步函数<code>then</code>，传参<code>resp</code>为Cache匹配到的值。</p>\n<p>此时管道内将尝试返回resp，如果resp为<code>null</code>或<code>undefined</code>[即获取不到对应的缓存]，将执行fetch操作，fetch成功后将<code>open</code>打开CacheStorage，并<code>put</code>放入缓存。此时如果<code>fetch</code>失败将直接报错，不写入缓存。</p>\n<p>在下一次获取同一个URL的时候，缓存匹配到的将不再是空白值，此时<code>fetch</code>不执行，直接返回缓存，大大提升了速度。</p>\n<p>由于npm的cdn对于latest缓存并不是持久有效的，所以我们最好还是判断一下url版本中是否以@latest为结尾。</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> is_latest = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> {    <span class=\"hljs-keyword\">return</span> url.replace(<span class=\"hljs-string\">'https://'</span>, <span class=\"hljs-string\">''</span>).split(<span class=\"hljs-string\">'/'</span>)[<span class=\"hljs-number\">1</span>].split(<span class=\"hljs-string\">'@'</span>)[<span class=\"hljs-number\">1</span>] === <span class=\"hljs-string\">'latest'</span>}<span class=\"hljs-comment\">//...</span><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">in</span> cache_url_list) {    <span class=\"hljs-keyword\">if</span> (is_latest(req.url)) { <span class=\"hljs-keyword\">return</span> fetch(req) }    <span class=\"hljs-keyword\">if</span> (req.url.match(cache_url_list[i])) {        <span class=\"hljs-keyword\">return</span> caches.match(req).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resp</span>) </span>{            <span class=\"hljs-comment\">//...</span>        })    }}</code></pre></div>\n<h3>\n<a href=\"https://blog.cyfan.top/#%E7%A6%BB%E7%BA%BF%E5%8C%96%E7%BC%93%E5%AD%98-Cache-For-Offline\" class=\"headerlink\" title=\"离线化缓存 / Cache For Offline\"></a>离线化缓存 / Cache For Offline</h3>\n<p>对于博客来说，并不是所有内容都是一成不变的。传统PWA采用SW更新同时刷新缓存，这样不够灵活，同时刷新缓存的版本号管理也存在着很大的漏洞，长时间访问极易造成庞大的缓存冗余。因此，对于博客的缓存，我们要保证用户每次获取都是最新的版本，但也要保证用户在离线时能看到最后一个版本的内容。</p>\n<p>因此，针对博客来说，策略应该是先获取最新内容，然后更新本地缓存，最后返回最新内容；离线的时候，尝试访问最新内容会回退到缓存，如果缓存也没有，就回退到错误页面。</p>\n<p>即：</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">Online:发起Request =&gt; 发起fetch =&gt; 更新Cache =&gt; 返回ResponseOffline:发起Request =&gt; 获取Cache =&gt; 返回Response</code></pre></div>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> handle = <span class=\"hljs-keyword\">async</span> (req) =&gt; {    <span class=\"hljs-keyword\">return</span> fetch(req.url).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">res</span>) </span>{        <span class=\"hljs-keyword\">if</span> (!res) { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">'error'</span> } <span class=\"hljs-comment\">//1</span>        <span class=\"hljs-keyword\">return</span> caches.open(CACHE_NAME).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">cache</span>) </span>{            cache.delete(req);            cache.put(req, res.clone());            <span class=\"hljs-keyword\">return</span> res;        });    }).catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) </span>{        <span class=\"hljs-keyword\">return</span> caches.match(req).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resp</span>) </span>{            <span class=\"hljs-keyword\">return</span> resp || caches.match(<span class=\"hljs-keyword\">new</span> Request(<span class=\"hljs-string\">'/offline.html'</span>)) <span class=\"hljs-comment\">//2</span>        })    })}</code></pre></div>\n<p><code>if (!res) { throw 'error' }</code> 如果没有返回值，直接抛出错误，会被下面的Catch捕获，返回缓存或错误页面</p>\n<p><code>return resp || caches.match(new Request('/offline.html'))</code> 返回缓存获得的内容。如果没有，就返回从缓存中拿到的错误网页。此处offline.html应该在最开始的时候就缓存好</p>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8-Storage-Persistently\" class=\"headerlink\" title=\"持久化存储 / Storage Persistently\"></a>持久化存储 / Storage Persistently</h2>\n<p>由于sw中无<code>window</code>，我们不能使用<code>localStorage</code>和<code>sessionStorage</code>。SW脚本会在所有页面都关闭或重载的时候丢失原先的数据。因此，如果想要使用持久化存储，我们只能使用<code>CacheAPI</code>和<code>IndexdDB</code>。</p>\n<h3>\n<a href=\"https://blog.cyfan.top/#IndexdDB\" class=\"headerlink\" title=\"IndexdDB\"></a>IndexdDB</h3>\n<p>这货结构表类型类似于<code>SQL</code>，能够存储JSON对象和数据内容，但版本更新及其操作非常麻烦，因此本文不对此做过多解释。</p>\n<h3>\n<a href=\"https://blog.cyfan.top/#CacheAPI\" class=\"headerlink\" title=\"CacheAPI\"></a>CacheAPI</h3>\n<p>这东西原本是用来缓存响应，但其本身的特性我们可以将其改造成一个简易的Key/Value数据表，可以存储文本/二进制，可扩展性远远比IndexdDB要好。</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\">self.CACHE_NAME = <span class=\"hljs-string\">'SWHelperCache'</span>;self.db = {    <span class=\"hljs-attr\">read</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> {        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {            caches.match(<span class=\"hljs-keyword\">new</span> Request(<span class=\"hljs-string\">`https://LOCALCACHE/<span class=\"hljs-subst\">${<span class=\"hljs-built_in\">encodeURIComponent</span>(key)}</span>`</span>)).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">res</span>) </span>{                res.text().then(<span class=\"hljs-function\"><span class=\"hljs-params\">text</span> =&gt;</span> resolve(text))            }).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {                resolve(<span class=\"hljs-literal\">null</span>)            })        })    },    <span class=\"hljs-attr\">read_arrayBuffer</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> {        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {            caches.match(<span class=\"hljs-keyword\">new</span> Request(<span class=\"hljs-string\">`https://LOCALCACHE/<span class=\"hljs-subst\">${<span class=\"hljs-built_in\">encodeURIComponent</span>(key)}</span>`</span>)).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">res</span>) </span>{                res.arrayBuffer().then(<span class=\"hljs-function\"><span class=\"hljs-params\">aB</span> =&gt;</span> resolve(aB))            }).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {                resolve(<span class=\"hljs-literal\">null</span>)            })        })    },    <span class=\"hljs-attr\">write</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">key, value</span>) =&gt;</span> {        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {            caches.open(CACHE_NAME).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">cache</span>) </span>{                cache.put(<span class=\"hljs-keyword\">new</span> Request(<span class=\"hljs-string\">`https://LOCALCACHE/<span class=\"hljs-subst\">${<span class=\"hljs-built_in\">encodeURIComponent</span>(key)}</span>`</span>), <span class=\"hljs-keyword\">new</span> Response(value));                resolve()            }).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {                reject()            })        })    }}</code></pre></div>\n<p>使用操作：</p>\n<p>写入key，value:</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">await</span> db.wtite(key,value)</code></pre></div>\n<p>以文本方式读取key：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">await</span> db.read(key)</code></pre></div>\n<p>以二进制方式读取key：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">await</span> db.read_arrayBuffer(key)</code></pre></div>\n<p>其余的blob读取、delete操作此处不过多阐述。</p>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E9%A1%B5%E9%9D%A2%E4%B8%8ESW%E9%80%9A%E4%BF%A1-Build-Communication-with-Page-and-ServiceWorker\" class=\"headerlink\" title=\"页面与SW通信 / Build Communication with Page and ServiceWorker\"></a>页面与SW通信 / Build Communication with Page and ServiceWorker</h2>\n<h3>\n<a href=\"https://blog.cyfan.top/#%E5%8D%95%E5%90%91%E8%BF%9E%E6%8E%A5-Unidirectional-Connect\" class=\"headerlink\" title=\"单向连接 / Unidirectional Connect\"></a>单向连接 / Unidirectional Connect</h3>\n<h3>\n<a href=\"https://blog.cyfan.top/#Clients-To-SW\" class=\"headerlink\" title=\"Clients To SW\"></a>Clients To SW</h3>\n<p>浏览器 =&gt; SW</p>\n<p>ServiceWorker中有一个非常简单的API<code>postMessage</code>,全路径为<code>navigator.serviceWorker.controller.postMessage</code>.</p>\n<p>因此,如果你只是作为页面单方面传递给SW,此api是个不错的选择.</p>\n<p>前端写法</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-number\">123</span>navigator.serviceWorker.controller.postMessage(data)<span class=\"hljs-comment\">//发送123</span></code></pre></div>\n<p>SW接收</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\">self.addEventListener(<span class=\"hljs-string\">'message'</span>, (event) =&gt; {  <span class=\"hljs-built_in\">console</span>.log(event.data)  <span class=\"hljs-comment\">//输出123</span>});</code></pre></div>\n<p>此方法可用于单方面向SW提交数据,但无需返回值.比如提示SW可以SkipWaiting,或者提交前端统计数据等等.</p>\n<h4>\n<a href=\"https://blog.cyfan.top/#SW-To-Clients\" class=\"headerlink\" title=\"SW To Clients\"></a>SW To Clients</h4>\n<p>首先,Clients必须要从SW中的一个event事件中获取,比如<code>fetch</code>.无法从<code>message</code>事件中获取client.</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\">addEventListener(<span class=\"hljs-string\">'fetch'</span>, event =&gt; {    event.waitUntil(<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{        <span class=\"hljs-keyword\">if</span> (!event.clientId) <span class=\"hljs-keyword\">return</span>;        <span class=\"hljs-keyword\">const</span> client = <span class=\"hljs-keyword\">await</span> clients.get(event.clientId);        <span class=\"hljs-keyword\">if</span> (!client) <span class=\"hljs-keyword\">return</span>;        <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-number\">123</span>;        client.postMessage(data);    }());});</code></pre></div>\n<h3>\n<a href=\"https://blog.cyfan.top/#%E5%8F%8C%E5%90%91%E9%80%9A%E8%AE%AF-Connect-Each\" class=\"headerlink\" title=\"双向通讯 / Connect Each\"></a>双向通讯 / Connect Each</h3>\n<p>浏览器 &lt;=&gt; SW</p>\n<p>我们拥有两种方式双向通讯:</p>\n<ol>\n<li>\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API\" target=\"_blank\" rel=\"noopener\">Broadcast Channel API</a> 多对多,广播形式.</li>\n<li>\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel\" target=\"_blank\" rel=\"noopener\">Message Channel</a> 一对一</li>\n</ol>\n<h4>\n<a href=\"https://blog.cyfan.top/#MessageChannel\" class=\"headerlink\" title=\"MessageChannel\"></a>MessageChannel</h4>\n<p>顾名思义，MessageChannel API 设置了一个可以发送消息的通道。</p>\n<p>该实现可以归结为3个步骤。</p>\n<p>1.在两侧设置事件侦听器以接收<code>message</code> 事件<br>2.通过发送<code>port</code>并将其存储在SW中，建立与SW的连接。<br>3.使用存储的<code>port</code>回复客户端</p>\n<p>前端写法</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> messageChannel = <span class=\"hljs-keyword\">new</span> MessageChannel();navigator.serviceWorker.controller.postMessage({  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'INIT'</span>,<span class=\"hljs-comment\">//发送init信息,表示以port2为接收端[即SW的发送端]</span>}, [messageChannel.port2]);messageChannel.port1.onmessage = <span class=\"hljs-function\">(<span class=\"hljs-params\">event</span>) =&gt;</span> {  <span class=\"hljs-comment\">//监听port1</span>  navigator.serviceWorker.controller.postMessage({    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'PING'</span><span class=\"hljs-comment\">//发送PING</span>  });};</code></pre></div>\n<p>SW端写法</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\">self.addEventListener(<span class=\"hljs-string\">\"message\"</span>, event =&gt; {    <span class=\"hljs-keyword\">const</span> data = event.data;    <span class=\"hljs-keyword\">if</span> (!!data) {        <span class=\"hljs-keyword\">switch</span> (data.type) {            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'INIT'</span>:                self.ClientPort = event.ports[<span class=\"hljs-number\">0</span>];            <span class=\"hljs-keyword\">default</span>:                self.ClientPort.postMessage({                    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'DATA'</span>,                    <span class=\"hljs-attr\">data</span>: <span class=\"hljs-string\">'pong'</span>                });        }    }})</code></pre></div>\n<p>然后查看控制台,你就会看到里面一直在乒乒乓乓,说明成功了.</p>\n<p>我们简单的改写一下,变成异步形式传输数据:</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> mCh = {        <span class=\"hljs-attr\">init</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {            <span class=\"hljs-built_in\">window</span>.messageChannel = <span class=\"hljs-keyword\">new</span> MessageChannel();            navigator.serviceWorker.controller.postMessage({                <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'INIT'</span>,            }, [messageChannel.port2]);        },        <span class=\"hljs-attr\">send</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> {            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {                <span class=\"hljs-keyword\">const</span> uuid = <span class=\"hljs-function\">(<span class=\"hljs-params\">(</span>) =&gt;</span> {                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'</span>.replace(<span class=\"hljs-regexp\">/[xy]/g</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">c</span>) </span>{                        <span class=\"hljs-keyword\">var</span> r = <span class=\"hljs-built_in\">Math</span>.random() * <span class=\"hljs-number\">16</span> | <span class=\"hljs-number\">0</span>, v = c == <span class=\"hljs-string\">'x'</span> ? r : (r &amp; <span class=\"hljs-number\">0x3</span> | <span class=\"hljs-number\">0x8</span>);                        <span class=\"hljs-keyword\">return</span> v.toString(<span class=\"hljs-number\">16</span>);                    });                })()                navigator.serviceWorker.controller.postMessage({                    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'DATA'</span>,                    <span class=\"hljs-attr\">data</span>: data,                    <span class=\"hljs-attr\">id</span>: uuid                });                setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {                    reject({                        <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'timeout'</span>,                        <span class=\"hljs-attr\">ok</span>: <span class=\"hljs-literal\">false</span>                    })                }, <span class=\"hljs-number\">2000</span>);                messageChannel.port1.onmessage = <span class=\"hljs-function\">(<span class=\"hljs-params\">event</span>) =&gt;</span> {                    <span class=\"hljs-keyword\">if</span> (event.data.id === uuid) {                        resolve({                            <span class=\"hljs-attr\">message</span>: event.data.data,                            <span class=\"hljs-attr\">ok</span>: <span class=\"hljs-literal\">true</span>                        })                    };                }            })        }    }</code></pre></div>\n<p>由于MessageChannel特性,一个port只要不是连续传输数据就会被断开.所以每次传输时我们要先初始化,后发送数据.</p>\n<p>由于传输时无状态的,我们将每一个包都打上特定的uuid,返回包里也写上对应的uuid即可判断那个包是哪个对应的返回值.</p>\n<p>SW端也要做一点点相应的改动</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\">self.ClientPort.postMessage({<span class=\"hljs-comment\">//...</span><span class=\"hljs-attr\">id</span>: data.id});</code></pre></div>\n<p>这样,一个兼容性较好的SW双向传输就解决了.</p>\n<h4>\n<a href=\"https://blog.cyfan.top/#Broadcast-Channel\" class=\"headerlink\" title=\"Broadcast Channel\"></a>Broadcast Channel</h4>\n<blockquote><p>请注意,BroadCast虽然写法建议,但是对浏览器兼容性要求非常高[Chrome 54,IOS Safari全线不支持].用此api请三思.</p></blockquote>\n<blockquote><p>另外,由于是广播形式,一个页面如果有多个SW,他们会同时收到消息.</p></blockquote>\n<p>前端</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> broadcast = <span class=\"hljs-keyword\">new</span> BroadcastChannel(<span class=\"hljs-string\">'Channel Name'</span>);<span class=\"hljs-keyword\">const</span> send_ping = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {    broadcast.postMessage({        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'PING'</span>    });}broadcast.onmessage = <span class=\"hljs-function\">(<span class=\"hljs-params\">event</span>) =&gt;</span> {    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'PONG'</span>)    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {        send_ping()    }, <span class=\"hljs-number\">500</span>);};send_ping()</code></pre></div>\n<p>SW端</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> broadcast = <span class=\"hljs-keyword\">new</span> BroadcastChannel(<span class=\"hljs-string\">'Channel Name'</span>);broadcast.onmessage = <span class=\"hljs-function\">(<span class=\"hljs-params\">event</span>) =&gt;</span> {    broadcast.postMessage({ <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"PONG\"</span> })};</code></pre></div>\n<p>只要ChannelName对应,即可在里面顺利传输消息.</p>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E7%BB%86%E8%8A%82%E4%B8%8E%E6%B3%A8%E6%84%8F-Something-Small-But-Need-to-Be-Mentioned\" class=\"headerlink\" title=\"细节与注意 / Something Small But Need to Be Mentioned\"></a>细节与注意 / Something Small But Need to Be Mentioned</h2>\n<h3>\n<a href=\"https://blog.cyfan.top/#%E6%97%A0%E6%B3%95%E4%BF%AE%E6%94%B9%E7%9A%84-Header\" class=\"headerlink\" title=\"无法修改的 Header\"></a>无法修改的 Header</h3>\n<p>由于ServiceWorker本质上仍然属于浏览器,因此,你无法控制例如header中的<code>Host</code>\\<code>Refferer</code>\\<code>Access-Control-Allow-Origin</code>用于绕过防盗链\\CORS\\指定host选择ip</p>\n<h3>\n<a href=\"https://blog.cyfan.top/#%E9%9A%BE%E4%BB%A5%E5%8D%B8%E8%BD%BD%E7%9A%84-SW\" class=\"headerlink\" title=\"难以卸载的 SW\"></a>难以卸载的 SW</h3>\n<p>SW一大特性,一旦被安装,就不能通过传统方式卸载掉.</p>\n<p>如果你直接删除<code>sw.js</code>文件并删除安装代码,那么,新用户是不会被安装的,但是原先已经安装过的用户sw会继续劫持这他们的网页,导致老用户网页不更新或者出现异常.</p>\n<p>正确的删除方法是将安装代码改成卸载代码:</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">navigator.serviceWorker.getRegistrations().<span class=\"hljs-keyword\">then</span>(function(<span class=\"hljs-keyword\">registrations</span>) { <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">registration</span> <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">registrations</span>) {  <span class=\"hljs-keyword\">registration</span>.unregister()} })</code></pre></div>\n<p>并将sw内容改成透明代理,方便没有卸载的用户正常使用.</p>\n<h3>\n<a href=\"https://blog.cyfan.top/#%E5%A0%B5%E5%A1%9E%E6%95%B4%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BB%A3%E7%A0%81\" class=\"headerlink\" title=\"堵塞整个浏览器的代码\"></a>堵塞整个浏览器的代码</h3>\n<p>由于SW运行在DOM上下文,如果在sw中执行一些消耗资源的代码会直接耗尽浏览器资源,与dom不同的是,dom耗资源代码只会堵塞一个线程,另一个线程依旧可以正常工作,而sw一旦堵塞会将整个浏览器堵死.因此sw固然可以更快的计算,但万不可将一些极易死机的代码交给sw处理.</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#End\" class=\"headerlink\" title=\"End\"></a>End</h1>\n<p>这篇文章结尾的很仓促,毕竟已经快拖了一个月了,也有很多东西没有讲清楚,未来可能会小修小改.</p>\n<p>篇幅所限,一些sw其他功能并没有详细讲述,比如后台更新或者推送通知.这些功能在实际开发中并不是特别有用,或者在国内大环境下并不适合.可能这些功能会在下一篇文章,sw的实操中讲述.</p>\n<p>停下笔的时候,hexo统计这篇文章已经将近1万字,阅读时间近100分钟.不过我认为这值得,毕竟sw就是这么一个凭借着奇思妙想就能绽放出Spark的事物.唯有独特的创造力才能激发无限可能.</p>\n<p>当然,这篇文章讲述的都是些非常基础的东西,那在下一篇文章,我会贴出一个个demo,希望你们能对这些充满着智慧的样例激发你们的灵感.</p>\n<p>另外,在祝贺你们,虎年大吉,新年快乐!</p>\n","link":"https://blog.cyfan.top/p/c0af86bb.html"},{"title":"在 Windows 上快速安装 Hexo · 安装 Node.js","date":"2022-01-14 10:30:00","description":"\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%89%8D%E8%A8%80\" class=\"headerlink\" title=\"前言\"></a>前言</h2>\n<p><strong>本文未经允许，禁止转载！</strong></p>\n<p><strong>视频教程正在制作，等待更新。</strong></p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95\" class=\"headerlink\" title=\"文章目录\"></a>文章目录</h2>\n<ul>\n<li><a href=\"https://blog.yfun.top/posts/hexo-blog/install-git\">安装 Git</a></li>\n<li><a href=\"https://blog.yfun.top/posts/hexo-blog/install-nodejs\">安装 Node.js</a></li>\n</ul>\n<blockquote><p>更多文章等待更新...</p></blockquote>\n<h2>\n<a href=\"https://blog.yfun.top/#%E4%B8%8B%E8%BD%BD\" class=\"headerlink\" title=\"下载\"></a>下载</h2>\n<p>前往 Node.js 官网 (<a href=\"https://node.js.org/\">https://node.js.org</a>)</p>\n<p><img src=\"https://unpkg.zhimg.com/ocoke-osg@0.0.14/rawimg/image-20220114174925675.png\" alt=\"image-20220114174925675\"></p>\n<p>下载 Node.js 安装包（推荐下载 LTS 版本）</p>\n<p><img src=\"https://unpkg.zhimg.com/ocoke-osg@0.0.14/rawimg/20220114175645.png\" alt=\"image-20220114175645642\"></p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%AE%89%E8%A3%85\" class=\"headerlink\" title=\"安装\"></a>安装</h2>\n<p>双击运行安装文件。</p>\n<p>点击 <code>Next</code>。</p>\n<p><img src=\"https://unpkg.zhimg.com/ocoke-osg@0.0.14/rawimg/20220114175750.png\" alt=\"image-20220114175749822\"></p>\n<p>勾选同意协议，点击 <code>Next</code>。</p>\n<p><img src=\"https://unpkg.zhimg.com/ocoke-osg@0.0.14/rawimg/20220114175835.png\" alt=\"image-20220114175835742\"></p>\n<p>修改文件安装位置，点击 <code>Next</code>。（也可以不用改）</p>\n<p><img src=\"https://unpkg.zhimg.com/ocoke-osg@0.0.14/rawimg/20220114175929.png\" alt=\"image-20220114175929226\"></p>\n<p>点击 <code>Next</code>。</p>\n<p><img src=\"https://unpkg.zhimg.com/ocoke-osg@0.0.14/rawimg/20220114180010.png\" alt=\"image-20220114180010036\"></p>\n<p><img src=\"https://unpkg.zhimg.com/ocoke-osg@0.0.14/rawimg/20220114180044.png\" alt=\"image-20220114180043895\"></p>\n<p>点击 <code>Install</code> 开始安装。</p>\n<p><img src=\"https://unpkg.zhimg.com/ocoke-osg@0.0.14/rawimg/20220114180108.png\" alt=\"image-20220114180107827\"></p>\n<p>等待安装完成。<img src=\"https://unpkg.zhimg.com/ocoke-osg@0.0.14/rawimg/20220114180122.png\" alt=\"image-20220114180122728\"></p>\n<p>点击 <code>Finish</code> 完成安装。</p>\n<p><img src=\"https://unpkg.zhimg.com/ocoke-osg@0.0.14/rawimg/20220114180206.png\" alt=\"image-20220114180206024\"></p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E6%B5%8B%E8%AF%95\" class=\"headerlink\" title=\"测试\"></a>测试</h2>\n<p>打开 <code>Git Bash</code>.</p>\n<blockquote><p>在文件夹处右击，点击 <code>Git Bash Here</code> 进入 Git Bash。<br>或是在开始菜单中找到 Git Bash.</p></blockquote>\n<p>输入 <code>node -v</code> 和 <code>npm -v</code> 查看版本，正确输出版本信息即代表安装成功。</p>\n<p><img src=\"https://unpkg.zhimg.com/ocoke-osg@0.0.14/rawimg/20220114180458.png\" alt=\"image-20220114180458685\"></p>\n","link":"https://blog.yfun.top/posts/hexo-blog/install-nodejs/"},{"title":"2022新春小记","date":"2022-01-10 13:57:45","description":"\n<p>这是一篇随迟但到的新春贺词（</p>\n<a></a><p>首先呢，旧年总结是不可能做的，这辈子都不可能做的。我发这篇文章的首要目的就是证明我还活着，毕竟上一篇文章到现在已经快半年了（实际上确实有半年）</p>\n<p>2021年是牛年，这一年过得很平淡，但却伴随着不少热点事件，刨去政治的，防沉迷、反诈、jsd掉备等等。这些热点我会在以后（maybe）一一热炒冷饭。</p>\n<p>新文仍在赶工，可以<a href=\"https://blog.cyfan.top/p/c0af86bb.html\">戳我围观新文</a>（还没写完）</p>\n<p>博客已经开启了自己写的ChenBlogHelper，在第一次进入博客的时候会自动安装并刷新激活。此helper能够在前端绕过备案、优选cdn以及统计。</p>\n<p>博客现在在中国大陆有一个广州节点承载，希望这能够给你们带来更好的访问体验。</p>\n<p>总之，新的一年，祝大家顺心顺意，愉快地享受新年的每一天！</p>\n","link":"https://blog.cyfan.top/p/7c7f6808.html"},{"title":"2022: 新年快乐！","date":"2021-12-31 16:00:00","description":"\n<p>转眼间，2021 年已经过去。这一年非常忙碌，以至于博客一周年的纪念来不及写，许多文章计划停留在了 To Do 里。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%8D%9A%E5%AE%A2\" class=\"headerlink\" title=\"博客\"></a>博客</h2>\n<p>由于 Cloudflare Web Analytics 是在 2021 年 4 月份启用的，再加上后来又将统计代码去除，所以关于访问量的信息不可用。</p>\n<p>截止至 2021 年 12 月 31 日，博客共发布 15 篇文章，其中 2021 年发布 11 篇文章，原创文章 10 篇。</p>\n<p>目前采用 <code>LeanCloud + Waline</code> 的评论方式，自 7 月份被刷评论后将评论权限改为登录（支持 <code>GitHub</code> 登录），还有部分评论在迁移中丢失，实在抱歉。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E4%B8%BB%E9%A2%98\" class=\"headerlink\" title=\"主题\"></a>主题</h2>\n<p>博客自 2021 年 1 月 13 日将主题改为 <code>Miracle</code>，这是一款简洁、轻量的单栏 Hexo 主题。</p>\n<p><code>Miralce</code> 目前的版本是 <code>2.0.1</code>，全新的版本去除 jQuery，进一步提升性能。</p>\n<p>GitHub 仓库：<a href=\"https://github.com/hifun-team/hexo-theme-miracle\">https://github.com/hifun-team/hexo-theme-miracle</a></p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E6%9B%B4%E5%A4%9A\" class=\"headerlink\" title=\"更多\"></a>更多</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">=&gt; ...</span><br></pre></td></tr></table></figure>\n","link":"https://blog.yfun.top/posts/2022/"},{"title":"[译] 不，Web3 不是去中心化","date":"2021-12-14 14:01:00","description":"加密货币社区对元宇宙和 Web3 的狂热仍在继续，大量投资人和开发者前仆后继加入其中。但是，Web3 真的能实现支持者们的种种愿景吗？亦或是另一个镜中月、水中花？也许让历史照进现实，能给我们答案。<img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/123139/11/24965/54827/62215eedE5e3da14a/80c24408e97057dd.png\"><br><p>请前往 <a href=\"https://blog.skk.moe/post/web3-is-not-decentralization/\">https://blog.skk.moe/post/web3-is-not-decentralization/</a> 阅读全文</p>\n","link":"https://blog.skk.moe/post/web3-is-not-decentralization/"},{"title":"[译] 捍卫自由的互联网，对 Web3 说不","date":"2021-12-12 13:40:00","description":"作为一个充满泡沫和噱头的新概念，Web3 和元宇宙在区块链的社区中掀起了一波浪潮。鼓吹者坚信 Web3 就是互联网的未来、不惜砸下大把的金钱和精力、希望能在未来中捞一杯羹；而大部分人保持观望的态度。是时候来一点 Web3 的反对意见了。<img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/87908/13/23797/13415/622032afE3a2f9e9f/95c01e98cd4a707a.png\"><br><p>请前往 <a href=\"https://blog.skk.moe/post/keep-web-free-say-no-to-web3/\">https://blog.skk.moe/post/keep-web-free-say-no-to-web3/</a> 阅读全文</p>\n","link":"https://blog.skk.moe/post/keep-web-free-say-no-to-web3/"},{"title":"2021 年 JavaScript Promise 性能对比","date":"2021-12-07 08:19:00","description":"\n<p>我们正生活在一个「Any application that can be written in JavaScript, will eventually be written in JavaScript」的时代。作为一门兼具动态性和简单性的语言，JavaScript 已经占领了客户端、服务端，甚至在机器学习中也占据一席之地；不可避免的，异步执行也逐渐成为这门语言不可缺少的一部分。TL; DR Bluebird 依然是速度最快、内存占用最少的 Promise 实现 Runtime 的 async / await 实现越来越快、顺序执行的性能已经超过 Native Promise，占用的内存也更少 对于平行并发执行的 Promise，Bluebird 的性能依然一骑绝尘。......</p>\n<img src=\"https://img10.360buyimg.com/ddimg/jfs/t1/157404/28/28495/143414/622032b2Ef7b495fd/6a9bd02e79392c9d.png\"><br><p>请前往 <a href=\"https://blog.skk.moe/post/promise-performance-benchmark/\">https://blog.skk.moe/post/promise-performance-benchmark/</a> 阅读全文</p>\n","link":"https://blog.skk.moe/post/promise-performance-benchmark/"},{"title":"在 Windows 上快速安装 Hexo · 安装 Git","date":"2021-11-12 13:30:00","description":"\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%89%8D%E8%A8%80\" class=\"headerlink\" title=\"前言\"></a>前言</h2>\n<p><strong>本文未经允许，禁止转载！</strong></p>\n<p><strong>视频教程正在制作，等待更新。</strong></p>\n<h3>\n<a href=\"https://blog.yfun.top/#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95\" class=\"headerlink\" title=\"文章目录\"></a>文章目录</h3>\n<ul><li><a href=\"https://blog.yfun.top/posts/hexo-blog/install-git\">安装 Git</a></li></ul>\n<blockquote><p>更多文章等待更新...</p></blockquote>\n<h2>\n<a href=\"https://blog.yfun.top/#%E4%B8%8B%E8%BD%BD\" class=\"headerlink\" title=\"下载\"></a>下载</h2>\n<p>前往 Git 官网 (<a href=\"https://git-scm.com/\">https://git-scm.com</a>).</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.11/rawimg/20211112204849.png\"></p>\n<p>点击页面中的 <code>Download For Windows</code> 下载 Windows 版本。</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.11/rawimg/20211112211507.png\"></p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E5%AE%89%E8%A3%85\" class=\"headerlink\" title=\"安装\"></a>安装</h2>\n<p>双击运行安装文件。</p>\n<p>点击 <code>Next</code>，同意协议。</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.11/rawimg/20211112211528.png\"></p>\n<p>修改程序安装位置，点击 <code>Next</code>（直接装在 C 盘也不是不行）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.11/rawimg/20211112211604.png\"></p>\n<p>组件选项，可选桌面快捷键、右键菜单、LFS 支持、自动检查更新等。</p>\n<p>点击 <code>Next</code> 进入下一步。</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.11/rawimg/20211112211609.png\"></p>\n<p>开始菜单文件夹名，保持默认就可以，点击 <code>Next</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.11/rawimg/20211112211613.png\"></p>\n<p>默认编辑器，保持 Vim 就可以，点击 <code>Next</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.11/rawimg/20211112211616.png\"></p>\n<p>环境变量，选择第 2 个，点击 <code>Next</code>。</p>\n<blockquote><p>如果选择第 1 个，则只能在 Git Bash 中使用，可能会出现问题</p></blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.11/rawimg/20211112211619.png\"></p>\n<p>剩下的都可以保持默认，一路 Next，然后点击 <code>Install</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.11/rawimg/20211112211622.png\"><br><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.11/rawimg/20211112211624.png\"><br><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.11/rawimg/20211112211627.png\"><br><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.11/rawimg/20211112211630.png\"><br><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.11/rawimg/20211112211633.png\"></p>\n<p>等待安装完毕。</p>\n<h2>\n<a href=\"https://blog.yfun.top/#%E6%B5%8B%E8%AF%95\" class=\"headerlink\" title=\"测试\"></a>测试</h2>\n<p>在文件夹处右击，点击 <code>Git Bash Here</code> 进入 Git Bash。</p>\n<p>（或是在开始菜单中找到 Git Bash）</p>\n<p>输入 <code>git --version</code> 查看版本，正确输出版本信息即代表安装成功。</p>\n<p><img src=\"https://cdn.jsdelivr.net/npm/ocoke-osg@0.0.11/rawimg/7ec315b7764cc.png\"></p>\n<p>大功告成！</p>\n","link":"https://blog.yfun.top/posts/hexo-blog/install-git/"},{"title":"为什么是APP而不是网页","date":"2021-07-28 05:24:15","description":"\n<p>一个简单的功能，完全可以在浏览器内实现，凭什么国内某些软件这么希望你去下载，去使用他们的app？</p>\n<a></a><p>就在不久前，我是真的体会到了什么叫流氓厂商。点名批评一下百度，我苹果手机Safari随便在百度上搜索点什么，还没把营销号、广告和垃圾信息从眼中剔除，突然间，AppStore界面平移到我眼前，一个叫<code>百度</code>的软件可怜巴巴的望着我。于是我点击左上角返回键，然后继续搜索…</p>\n<p>这不是一件在国内很常见的事情吗，然后我继续浏览，点击一个百度百科网页链接，又是还没开看，appstore显示了出来，这次是百度百科app。</p>\n<p>好，没事，我平复了一下心情，整理了一下被打乱的思绪，继续浏览着百科，滑到页面底部，加载新的内容时，一个弹窗显示出来：使用百度百科APP，获取更好的浏览体验！</p>\n<p>关闭，继续浏览。</p>\n<p>点击百科内部的内链，尝试跳转到另一个百科界面，突然，浏览器一片空白，我又被引导向appstore。</p>\n<p>很抱歉，我直接关闭了百度，使用谷歌和维基百科继续查询资料。这一次，谷歌虽然也在下方提示【在IOS上尝试使用谷歌桌面版，获取更好的体验】，但至始至终没有把我强制跳到appstore。维基百科就更不用说了，连使用app都没有提示。</p>\n<p>退出了浏览器，我不禁陷入了沉思。我还记得不久前拿到朋友的新鸿蒙手机，划开屏幕一看，第一个界面全是百度系列：百度、百度搜索、百度智能浏览器、百度贴吧、百度知道…一个个功能冗余的百度app赫然显示在我的眼前，当我一脸震惊地看向朋友，他耸耸肩：点进去就自己下载的，不安装就没办法看了。</p>\n<p>看着自己苹果手机中的两个一个浏览器：Safari和Alook，我停止了思考，当一个大厂天天为自己的免费网盘带宽叫屈，下载一个3M的电子书被限成一副狗样时，你还能相信他有这么大的带宽给用户推自己的动辄100MB的APP？这能算是本末倒置吗？</p>\n<p>从此，我在手机上再也没有用过百度系。必应和谷歌，DogeDoge和DuckDuckGo成为了我的搜索主力。</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFAPP\" class=\"headerlink\" title=\"为什么是APP\"></a>为什么是APP</h1>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E9%9A%90%E7%A7%81\" class=\"headerlink\" title=\"隐私\"></a>隐私</h2>\n<p>app对隐私的疯狂到了什么地步？我也就不贴知乎链接了，就贴一个今天cctv的内容吧：</p>\n<p><a href=\"https://tv.cctv.com/live/cctv13/index.shtml?spm=C28340.P1dzdfA9CsHZ.E1oxZyG629bH.79&amp;stime=1627446780&amp;etime=1627448400&amp;type=lbacks\" target=\"_blank\" rel=\"noopener\">https://tv.cctv.com/live/cctv13/index.shtml?spm=C28340.P1dzdfA9CsHZ.E1oxZyG629bH.79&amp;stime=1627446780&amp;etime=1627448400&amp;type=lbacks</a></p>\n<p>在安卓环境【尤其是国内某些套壳系统】下，app的权限不算小，有些时候可以在没有提醒的情况下把你的浏览器记录翻个遍。</p>\n<p>ios其实相对安卓来说，至少系统能主动提醒用户是否给予其访问权利。</p>\n<p>这一点我也十分佩服MIUI，能在这种隐私岁随意获取风气下站住来守住用户的底线，无论其目的如何，这一点已经赢得了我的好感【虽然我不用安卓】</p>\n<p>对于软件商来说，用户的数据是一大笔财富。比如知道所有人的喜好、购买能力等，这些信息掌握得越细致，越能挖掘到更多的商机。</p>\n<p>暂且不说百度，就连TIM和QQ也会主动扫描用户Chrome浏览记录<span class=\"heimu\"><del>我靠那我的nhentai浏览记录怎么办</del></span></p>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E4%BA%92%E5%94%A4%E9%86%92%E3%80%90For%E5%AE%89%E5%8D%93%E3%80%91\" class=\"headerlink\" title=\"互唤醒【For安卓】\"></a>互唤醒【For安卓】</h2>\n<p>为了实现广告营销，部分软件实际上要向用户主动推送广告信息。</p>\n<p>尤其是安卓，由于谷歌市场退出中国大陆，国内安卓生态其实很乱，一个简单的消息推送，也能难倒一群开发者。</p>\n<p>为什么消息推送变成了一个难题？其实我们想象中的消息推送与实际上的方式有很大差距:</p>\n<p>想象中：用户手机&lt;==主动推送==微信服务器<br>实际上：用户手机&lt;==被动推送==&gt;苹果|安卓消息推送服务器&lt;==主动推送==微信服务器</p>\n<p>苹果还好说，18年以前经常会出现微信无法推送的情况，但自从大陆线路优化以及云上贵州的迁移，其推送服务逐渐变得正常。然而谷歌早已退出中国市场，其内置的推送服务器已经不可链接，请问这些app这么办？</p>\n<p>答：常驻系统后台。</p>\n<p>但是常驻系统后台成为一个Zombine进程也不可避免会被杀掉，请问这又能怎么办？</p>\n<p>答：相互唤醒。</p>\n<p>当用户打开一个app，此app会在后台激活另一群app，然后如果当前app被杀了，被激活的app又会激活那个被杀的app。</p>\n<p>这样就很好理解了虽然只有百度app才会推送广告，但他依旧会引导你去下载百度浏览器—避免被杀掉啊。</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BA%94%E7%94%A8\" class=\"headerlink\" title=\"为什么不是浏览器应用\"></a>为什么不是浏览器应用</h1>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E9%9A%90%E7%A7%81-1\" class=\"headerlink\" title=\"隐私\"></a>隐私</h2>\n<p>在这个隐私即金钱的时代，对于国内厂商来说，首先一个遗憾的事情是，浏览器是很难获取到用户的隐私信息。不是说功能限制，而是浏览器其核心就是沙盒化。在没有用户同意和外接接口、插件的前提下，你不可能直接用js获取到用户手机/电脑上的文件。</p>\n<p>而且最致命的是，如果网页应用敢在后台偷偷上传用户隐私，控制台一开就会使其暴露无遗，相对比APP的黑盒操作，那简直是天差地别。</p>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E5%8A%9F%E8%83%BD%E9%99%90%E5%88%B6\" class=\"headerlink\" title=\"功能限制\"></a>功能限制</h2>\n<p>js功能其实很强大，但有些底层和协议上的限制不能做就是不能做，你不可能用js空手写一个SMTP发送邮件，你也不可能直接用SSH协议链接服务器【WebSSH需要在服务器主动安装服务端】</p>\n<p>其次，一些十分耗资源和计算力的服务不可能在浏览器上实现，比如腾讯不可能把王者荣耀搬到浏览器上，你也不可能在浏览器里跑机器学习。</p>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E7%BD%91%E7%BB%9C%E9%99%90%E5%88%B6\" class=\"headerlink\" title=\"网络限制\"></a>网络限制</h2>\n<p>如果使用浏览器，其每一次打开服务网店都要重新下载上面的js、css和图片资源，这一瞬间爆发对服务器压力其实不小。</p>\n<p>而使用app，他可以事先在后台下载好广告图片，其样式和功能无需重新下载，并且很多资源可以缓存在本地，即使短暂离线也能推送。</p>\n<p>这一点，PWA技术完全可以胜任。PWA通过在浏览器内ServiceWorker拦截和缓存内容实现离线浏览。但目前来讲PWA技术在国内不温不火【很明显，触碰到了某些企业的利益】，所以还是以应用程序为主。</p>\n<p><span class=\"heimu\">但是，你这样剩下来的流量费还是比不过强制更新来的多啊</span></p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%BD%E5%A4%96%E6%B2%A1%E6%9C%89%E5%87%BA%E7%8E%B0%E7%B1%BB%E4%BC%BC%E7%9A%84%E6%83%85%E5%86%B5\" class=\"headerlink\" title=\"为什么国外没有出现类似的情况\"></a>为什么国外没有出现类似的情况</h1>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E7%9B%91%E7%AE%A1%E7%BC%BA%E5%A4%B1\" class=\"headerlink\" title=\"监管缺失\"></a>监管缺失</h2>\n<p>海外，安卓应用最官方的商店只有一家：GooglePlay，虽然不像AppStore那种不上架连安装都不给的程度，但也是一种象征。没有上架谷歌商店的应用基本都会被判定为盗版或者危险。而且谷歌play对广告监管很严。如果一个应用敢像百度般，疯狂推送广告和自唤醒，可能连安全审查都过不去。</p>\n<p>在国内，连老大都管不了，宛若袁世凯暴毙天下军阀混战，其乱象不言而喻。</p>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E9%9A%90%E7%A7%81%E6%84%8F%E8%AF%86%E7%BC%BA%E4%B9%8F\" class=\"headerlink\" title=\"隐私意识缺乏\"></a>隐私意识缺乏</h2>\n<p>李彦宏有句<del>名言</del>：中国人更愿意用隐私交换便捷性。</p>\n<p>虽然此话一出被无数网友嘲讽，但也不得不承认这确实如此。甚至有些时候自己也是被迫的。没有多少人会上网的时候开无数个虚拟机中继代理AdGuard，相反，有更多人为了PDD的几分钱蔬菜而抢破头。一句话：国人都喜欢薅羊毛，但最终都会成为韭菜被割。</p>\n<p>相反，在国外，人们对于隐私十分看重，哪怕GoogleAdsense都被罚了好几次，还不用说Tor之类的隐私保护软件。</p>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E4%BD%BF%E7%94%A8%E8%A7%82%E5%BF%B5%E7%9A%84%E4%B8%8D%E5%90%8C\" class=\"headerlink\" title=\"使用观念的不同\"></a>使用观念的不同</h2>\n<p>我个人的习惯是，完成一件事情，用什么东西都越轻越好，不是有必要就不下客户端。比如在电脑微信接收消息，你可以选择下载微信客户端完成传输，也可以用<a href=\"https://wx.qq.com/\" target=\"_blank\" rel=\"noopener\">网页微信</a>。相较于前者，后者用完就关，不留痕迹，速度也快。</p>\n<p>然而国人的习惯大多是：先下载下来，万一以后有用呢。</p>\n<p>当我看到电视上的手机广告，大多8H16G运存128G内存起步，盯着手里这台国产只装了QQ到2021年还能打Minecraft的iPhone6s【实际配置2GB运存A9处理器】，不禁留下了悔恨的泪水：幸好没买安卓。</p>\n<p>安卓手机即使内存再大，其底层核心还是虚拟化，加上国内的恶劣的生态，如果你不留神多下点软件，其流畅度甚至比不过6年前的6s。</p>\n<p>而手机卡，大多数人的第一个想法是：换一台手机。而不是：我删掉点软件，只保留QQ和微信。</p>\n<p>尤其是，在国内的内循环已经完成的前提下，更多人选择了买爱国手机，装爱国软件。实际上，留一条隐私底线其实也没有什么。但偏偏有人喜欢把自己隐私送给别人。</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E5%90%8E%E8%A8%80\" class=\"headerlink\" title=\"后言\"></a>后言</h1>\n<p>实际上，绝大多数软件从C/S架构向B/S架构的转换是不可避免的。但是国内的生态似乎在阻碍着这一发展。</p>\n<p>或许有人会问，隐私再保护有什么用。那我只能说，如果你的隐私在黑市只能卖1毛钱一条，那隐私保护的好的人或许能卖5块钱一条。真正的危害其实不在于精准推送，而更怕有人会拿去做违法事情，暴力你，诈骗你。</p>\n","link":"https://blog.cyfan.top/p/c0af86a9.html"},{"title":"致敬袁老，精神永在","date":"2021-05-22 08:49:21","description":"\n<p>“共和国勋章”获得者、中国工程院院士、国家杂交水稻工程技术研究中心主任、湖南省政协原副主席袁隆平，因多器官功能衰竭，于2021年5月22日13时07分在长沙逝世，享年91岁。</p>\n<p>感谢袁老，让我们端的起饭碗，让我们00后的孩子至少吃得饱。一路走好。</p>\n<p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href=\"https://cloud.tencent.com/developer/support-plan?invite_code=3uzi7w7znlsa\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/support-plan?invite_code=3uzi7w7znlsa</a></p>\n","link":"https://blog.cyfan.top/p/4ee6384.html"},{"title":"再见Z16，Hi Laffey！","date":"2021-04-19 08:26:23","description":"\n<p>2019-7-16 本站建成，第二天，Z16进入了我的博客。今天，我更换了陪伴我641天的看板娘。</p>\n<a></a><p>越来越多的模型采用了最新版本的Live2d Cubism 3或4【以下简称Live2d V3/V4】，而我用的hexo live2d插件<a href=\"https://github.com/EYHN/hexo-helper-live2d\" target=\"_blank\" rel=\"noopener\">hexo-helper-live2d</a>已经很久没更新了，直接使用v3模型显然是不行的。</p>\n<p>原来用的Z16【V2】模型地址：</p>\n<div class=\"hljs\"><pre><code class=\"hljs url\">https://npm.elemecdn.com/chenyfan-cdn@2.0.0/js/live2d-widget-model-z16/assets/z16.model.json</code></pre></div>\n<p>格式如下：</p>\n<div class=\"hljs\"><pre><code class=\"hljs json\">{    <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"Live2DViewerEX Config 1.0\"</span>,    <span class=\"hljs-attr\">\"model\"</span>: <span class=\"hljs-string\">\"moc/z16.moc\"</span>,    <span class=\"hljs-attr\">\"textures\"</span>: [        <span class=\"hljs-string\">\"moc/z16.1024/texture_00.png\"</span>    ],    <span class=\"hljs-attr\">\"layout\"</span>: {        <span class=\"hljs-attr\">\"center_x\"</span>: <span class=\"hljs-number\">0</span>,        <span class=\"hljs-attr\">\"center_y\"</span>: <span class=\"hljs-number\">0</span>,        <span class=\"hljs-attr\">\"width\"</span>: <span class=\"hljs-number\">2</span>    },    <span class=\"hljs-attr\">\"motions\"</span>: {        <span class=\"hljs-attr\">\"idle\"</span>: [            {                <span class=\"hljs-attr\">\"file\"</span>: <span class=\"hljs-string\">\"mtn/idle.mtn\"</span>            }        ]    },    <span class=\"hljs-attr\">\"expressions\"</span>: [        {            <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"f00.exp.json\"</span>,            <span class=\"hljs-attr\">\"file\"</span>: <span class=\"hljs-string\">\"exp/f00.exp.json\"</span>        }    ],    <span class=\"hljs-attr\">\"physics\"</span>: <span class=\"hljs-string\">\"z16.physics.json\"</span>}</code></pre></div>\n<p>而V3模型普遍长这样：</p>\n<div class=\"hljs\"><pre><code class=\"hljs json\">{    <span class=\"hljs-attr\">\"Version\"</span>: <span class=\"hljs-number\">3</span>,    <span class=\"hljs-attr\">\"FileReferences\"</span>: {        <span class=\"hljs-attr\">\"Moc\"</span>: <span class=\"hljs-string\">\"lafei_4.moc3\"</span>,        <span class=\"hljs-attr\">\"Textures\"</span>: [            <span class=\"hljs-string\">\"textures/texture_00.png\"</span>        ],        <span class=\"hljs-attr\">\"Physics\"</span>: <span class=\"hljs-string\">\"lafei_4.physics3.json\"</span>,        <span class=\"hljs-attr\">\"Motions\"</span>: {            <span class=\"hljs-attr\">\"\"</span>: [                {                    <span class=\"hljs-attr\">\"File\"</span>: <span class=\"hljs-string\">\"motions/complete.motion3.json\"</span>                },                ...            ]        }    },    <span class=\"hljs-attr\">\"Groups\"</span>: [        {            <span class=\"hljs-attr\">\"Target\"</span>: <span class=\"hljs-string\">\"Parameter\"</span>,            <span class=\"hljs-attr\">\"Name\"</span>: <span class=\"hljs-string\">\"LipSync\"</span>,            <span class=\"hljs-attr\">\"Ids\"</span>: [                <span class=\"hljs-string\">\"ParamMouthOpenY\"</span>            ]        }    ]}</code></pre></div>\n<p>将所有除了Ver信息全部移入了<code>FileReferences</code>Key里面。</p>\n<p>当然，V3和V2的差别肯定不止json格式的差异，所以我们很显然要一个新的js加载V3。</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E6%9B%B4%E6%96%B0V3-4-Core\" class=\"headerlink\" title=\"更新V3/4 Core\"></a>更新V3/4 Core</h1>\n<blockquote><p>Live2d官网已经决定后来的live2d版本都允许向前兼容到V3,所以V4的core还是能加载V3的模型[当然V2不行]</p></blockquote>\n<p>啃了一遍官文,我们首先需要这些js插件:</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\"><span class=\"hljs-selector-tag\">live2dcubismcore</span><span class=\"hljs-selector-class\">.js</span><span class=\"hljs-selector-tag\">live2dcubismframework</span><span class=\"hljs-selector-class\">.js</span><span class=\"hljs-selector-tag\">pixi</span><span class=\"hljs-selector-class\">.js</span><span class=\"hljs-selector-tag\">live2dcubismpixi</span><span class=\"hljs-selector-class\">.js</span></code></pre></div>\n<p>首先说<code>live2dcubismcore.js</code>,这是一个急需注意的js,由于版权原因,你需要自行去官网下载再上传到自己的cdn,所以不能随便找一个人的网站就爬下来<strong>[包括我的]</strong>,这样会收到官方警告的。</p>\n<p>前往<a href=\"https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js\" target=\"_blank\" rel=\"noopener\">https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js</a>下载。</p>\n<p>然后剩下的你可以选择嫖我的</p>\n<p><a href=\"https://cdn.jsdelivr.net/combine/npm/chenyfan-oss@2.0.3/pixi.min.js,npm/chenyfan-oss@2.0.3/live2dcubismframework.min.js,npm/chenyfan-oss@2.0.3/live2dcubismpixi.min.js\" target=\"_blank\" rel=\"noopener\">https://cdn.jsdelivr.net/combine/npm/chenyfan-oss@2.0.3/pixi.min.js,npm/chenyfan-oss@2.0.3/live2dcubismframework.min.js,npm/chenyfan-oss@2.0.3/live2dcubismpixi.min.js</a></p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B\" class=\"headerlink\" title=\"加载模型\"></a>加载模型</h1>\n<p>我选择白嫖<a href=\"https://github.com/Himehane/live2d_on_website/blob/master/loadModel.js\" target=\"_blank\" rel=\"noopener\">https://github.com/Himehane/live2d_on_website/blob/master/loadModel.js</a></p>\n<p>当然这有一点点小问题，比如上面这么配置：</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> baseModelPath = <span class=\"hljs-string\">'https://npm.elemecdn.com/chenyfan-oss@2.0.2'</span><span class=\"hljs-keyword\">var</span> modelNames = [<span class=\"hljs-string\">\"lafei_4\"</span>];</code></pre></div>\n<p>那么他会这么请求</p>\n<div class=\"hljs\"><pre><code class=\"hljs url\">https://npm.elemecdn.com/chenyfan-oss@2.0.2/lafei_4/lafei_4.model3.json</code></pre></div>\n<p>可是问题是我没有加一层文件夹。。。我的位置是</p>\n<div class=\"hljs\"><pre><code class=\"hljs url\">https://npm.elemecdn.com/chenyfan-oss@2.0.2/lafei_4.model3.json</code></pre></div>\n<p>修改loadModel 288行</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">- modelPath =  <span class=\"hljs-keyword\">baseModelPath </span>+ modelName + <span class=\"hljs-string\">\"/\"</span> + modelName + <span class=\"hljs-string\">\".model3.json\"</span><span class=\"hljs-comment\">;</span>+ modelPath = <span class=\"hljs-keyword\">baseModelPath </span>+ <span class=\"hljs-string\">\"/\"</span> + modelName + <span class=\"hljs-string\">\".model3.json\"</span><span class=\"hljs-comment\">;</span></code></pre></div>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E6%A0%B7%E5%BC%8F%E8%B0%83%E6%95%B4\" class=\"headerlink\" title=\"样式调整\"></a>样式调整</h1>\n<p>首先给live2d一个div位置</p>\n<div class=\"hljs\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"live2d\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"live2d\"</span>&gt;</span>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"live2dm\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"live2d\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"z-index: 999!important;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre></div>\n<p>然后样式微调</p>\n<div class=\"hljs\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.live2d</span> {    <span class=\"hljs-attribute\">position</span>: fixed;     <span class=\"hljs-attribute\">left</span>: -<span class=\"hljs-number\">100px</span>;    <span class=\"hljs-attribute\">bottom</span>: -<span class=\"hljs-number\">20px</span>;    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">500px</span> <span class=\"hljs-meta\">!important</span>;    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">437.5px</span> <span class=\"hljs-meta\">!important</span>;    <span class=\"hljs-attribute\">z-index</span>: <span class=\"hljs-number\">998</span>;}</code></pre></div>\n<p><code>bottom</code>将其固定页面底端，大小用<code>!important</code>强制固定<del>【不规范写法，请勿模仿】</del></p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E5%88%A4%E6%96%AD%E5%B1%8F%E5%B9%95%E5%A4%A7%E5%B0%8F%E8%BF%9B%E8%A1%8C%E6%87%92%E5%8A%A0%E8%BD%BD\" class=\"headerlink\" title=\"判断屏幕大小进行懒加载\"></a>判断屏幕大小进行懒加载</h1>\n<p>嘿嘿，这么大的js怎么不能懒加载呢</p>\n<div class=\"hljs\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">loadScript</span>(<span class=\"hljs-params\">src, callback</span>) </span>{        <span class=\"hljs-keyword\">var</span> script = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">'script'</span>),            head = <span class=\"hljs-built_in\">document</span>.getElementsByTagName(<span class=\"hljs-string\">'head'</span>)[<span class=\"hljs-number\">0</span>];        script.type = <span class=\"hljs-string\">'text/javascript'</span>;        script.charset = <span class=\"hljs-string\">'UTF-8'</span>;        script.src = src;        <span class=\"hljs-keyword\">if</span> (script.addEventListener) {            script.addEventListener(<span class=\"hljs-string\">'load'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{                callback();            }, <span class=\"hljs-literal\">false</span>);        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (script.attachEvent) {            script.attachEvent(<span class=\"hljs-string\">'onreadystatechange'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{                <span class=\"hljs-keyword\">var</span> target = <span class=\"hljs-built_in\">window</span>.event.srcElement;                <span class=\"hljs-keyword\">if</span> (target.readyState == <span class=\"hljs-string\">'loaded'</span>) {                    callback();                }            });        }        head.appendChild(script);    }    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">loadlive2d</span>(<span class=\"hljs-params\"></span>) </span>{        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">document</span>.body.clientWidth &gt; <span class=\"hljs-number\">600</span>) {            <span class=\"hljs-built_in\">document</span>.onreadystatechange = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">document</span>.readyState == <span class=\"hljs-string\">\"complete\"</span>) {                    loadScript(<span class=\"hljs-string\">'https://npm.elemecdn.com/chenyfan-os@0.0.0-r1/load.js'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{                        loadModel();})                }            }        }    }loadlive2d()</code></pre></div>\n<p><code>document.body.clientWidth</code>判断可见宽度，<code>loadScript</code>强制异步执行loadModel，丢上去就行了</p>\n<p>然后你就可以正常使用live2d了，这是一个demo：</p>\n<div class=\"hljs\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">    <span class=\"hljs-selector-class\">.live2d</span> {        <span class=\"hljs-attribute\">position</span>: fixed;        <span class=\"hljs-attribute\">left</span>: -<span class=\"hljs-number\">100px</span>;        <span class=\"hljs-attribute\">bottom</span>: -<span class=\"hljs-number\">20px</span>;        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">500px</span> <span class=\"hljs-meta\">!important</span>;        <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">437.5px</span> <span class=\"hljs-meta\">!important</span>;        <span class=\"hljs-attribute\">z-index</span>: <span class=\"hljs-number\">998</span>;    }</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"live2d\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"live2d\"</span>&gt;</span>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"live2dm\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"live2d\"</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"z-index: 999!important;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://npm.elemecdn.com/chenyfan-oss@2.0.3\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre></div>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0-img/hpp_upload/1618822975000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>然后添加到Hexo就改模板吧…没什么好说的<img src=\"https://npm.elemecdn.com/chenyfan-oss@1.1.8/5896ec2cb7f39.gif\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n","link":"https://blog.cyfan.top/p/a12e0ab7.html"},{"title":"看毛片(KMP)算法小记","date":"2021-04-07 11:22:12","description":"\n<p>一直摸鱼的CYF突然安静了下来,因为他想学学一个别人都会的算法。</p>\n<a></a><p><del>我菜就是菜，只能学别人早就会的算法了</del></p>\n<p>先贴维基链接【讲的比CSDN清楚，自己访问】</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/KMP%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/KMP%E7%AE%97%E6%B3%95</a></p>\n<p>长串匹配短串，基本上DP打一遍就冲了。</p>\n<p>DP本质简单的很：</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">匹配串：ABCDPOPABQO待匹配串：ABQ</code></pre></div>\n<p>开始匹配</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">ABCDPOPABQO↑ABQ↑ABCDPOPABQO ↑ABQ ↑ ABCDPOPABQO  ↑ABQ  ↑  ABCDPOPABQO ↑ ABQ ↑...</code></pre></div>\n<p>显而易见，这种复杂度极高【O(m*n)】，当然，冲个入门级别的绝对没问题</p>\n<p>然而类似基因匹配这种数量级恶心心的东西，DP绝对是不够的。</p>\n<p>或者说一个恶心的数据</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attribute\">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAB</span></code></pre></div>\n<p>这样如果直接硬DP，那绝对TLE。</p>\n<p>于是，我们选择一个简单的算法，<span class=\"heimu\">看毛片</span> KMP算法，他可以很好的提升我们匹配的效率</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h1>\n<p>首先名字很有意思，之所以叫做KMP，是因为这个算法是由Knuth、Morris、Pratt三个提出来的，取了这三个人的名字的头一个字母。</p>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E8%B7%B3%E8%BF%87%E5%B7%B2%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6\" class=\"headerlink\" title=\"跳过已匹配字符\"></a>跳过已匹配字符</h2>\n<p>扯远了，将匹配方式简单讲一下</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attribute\">ABCDPOPABQO</span>↑ABQ↑匹配，指针右移【以下未特殊表明均指针】ABCDPOPABQO ↑ABQ ↑ 匹配，右移ABCDPOPABQO  ↑ABQ  ↑</code></pre></div>\n<p>这时候我们撞上了不匹配的情景，怎么办？右移一位？</p>\n<p>不，我们发现原串里面的<code>C</code>在待匹配串里面根本没出现，并且原串[0]~[2]均不匹配，所以我们选择把匹配串整个向右移动三位</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attribute\">ABCDPOPABQO</span>   ↑   ABQ   ↑   不匹配，字符串右移一位ABCDPOPABQO↑    ABQ    ↑   省略数步ABCDPOPABQO       ↑       ABQ       ↑   匹配，右移ABCDPOPABQO        ↑       ABQ        ↑匹配，右移ABCDPOPABQO         ↑       ABQ         ↑匹配，右移这时候待匹配串已匹配完毕，记录并将整个串移动到末尾ABCDPOPABQO          ↑          ABQ          ↑  待匹配串已超过原串长度，结束</code></pre></div>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D\" class=\"headerlink\" title=\"部分匹配\"></a>部分匹配</h2>\n<p>上面的例子可能没有讲到重点，接下来换个例子，部分匹配才是KMP的核心</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attribute\">ABCEABCABCDABDABCDABD</span></code></pre></div>\n<p>OK我们开始匹配</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attribute\">ABCDABCDABDABCDABD</span>↑ABCDABD↑ABCDABCDABDABCDABD ↑ABCDABD ↑ ABCDABCDABDABCDABD  ↑ABCDABD  ↑ABCDABCDABDABCDABD   ↑ABCDABD   ↑   ABCDABCDABDABCDABD    ↑ABCDABD    ↑ABCDABCDABDABCDABD     ↑ABCDABD     ↑ABCDABCDABDABCDABD      ↑ABCDABD      ↑</code></pre></div>\n<p>这个时候我们发现了原串[6]与比较串不符合,这时候怎么办?直接跳到后面去?</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attribute\">ABCDABCDABDABCDABD</span>       ↑       ABCDABD       ↑</code></pre></div>\n<p>好家伙,你会直接丢掉[4]~[10],而这正是我们要匹配的</p>\n<p>所以我们定个小规矩:</p>\n<blockquote><p>移动位数 = 已匹配的字符数 - 对应的部分匹配值</p></blockquote>\n<blockquote><p>换句话说,就是移动到下一个重复片段的地方</p></blockquote>\n<p>所以这个时候我们应该移动<strong>4位</strong>而不是<strong>6位</strong></p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">ABCDABCDABDABCDABD<span class=\"hljs-code\">      ↑</span><span class=\"hljs-code\">    ABCDABD</span><span class=\"hljs-code\">      ↑</span><span class=\"hljs-code\">  </span><span class=\"hljs-bullet\">...</span>ABCDABCDABDABCDABD<span class=\"hljs-code\">          ↑</span><span class=\"hljs-code\">    ABCDABD</span><span class=\"hljs-code\">          ↑</span></code></pre></div>\n<p>这个时候我们已经匹配到了一串,那么接下来怎么移?还是直接移动6位?</p>\n<p>不,我们还是要用自己定下的规矩,移动<strong>4位</strong></p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attribute\">ABCDABCDABDABCDABD</span>          ↑        ABCDABD          ↑</code></pre></div>\n<p>此时,我们才能将其整个向右移动<strong>2位</strong></p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">ABCDABCDABDABCDABD<span class=\"hljs-code\">           ↑</span><span class=\"hljs-code\">           ABCDABD</span><span class=\"hljs-code\">           ↑</span><span class=\"hljs-code\">   </span><span class=\"hljs-bullet\">...</span>ABCDABCDABDABCDABD<span class=\"hljs-code\">                 ↑</span><span class=\"hljs-code\">           ABCDABD</span><span class=\"hljs-code\">                 ↑</span></code></pre></div>\n<p>OK我们将其匹配完毕,整个<code>ABCDABCDABDABCDABD</code>包含两处<code>ABCDABD</code></p>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D%E8%A1%A8\" class=\"headerlink\" title=\"部分匹配表\"></a>部分匹配表</h2>\n<p>这是一张神奇的表格</p>\n<p>首先我们搞清楚前缀和后缀是什么</p>\n<p><code>SHITERS</code></p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\"><span class=\"hljs-selector-tag\">-</span> 前缀<span class=\"hljs-selector-tag\">Q</span><span class=\"hljs-selector-attr\">[<span class=\"hljs-string\">'S'</span>,<span class=\"hljs-string\">'SH'</span>,<span class=\"hljs-string\">'SHI'</span>,<span class=\"hljs-string\">'SHIT'</span>,<span class=\"hljs-string\">'SHITE'</span>,<span class=\"hljs-string\">'SHITER'</span>]</span><span class=\"hljs-selector-tag\">-</span> 后缀<span class=\"hljs-selector-tag\">H</span><span class=\"hljs-selector-attr\">[<span class=\"hljs-string\">'HITERS'</span>,<span class=\"hljs-string\">'ITERS'</span>,<span class=\"hljs-string\">'TERS'</span>,<span class=\"hljs-string\">'ERS'</span>,<span class=\"hljs-string\">'RS'</span>,<span class=\"hljs-string\">'S'</span>]</span></code></pre></div>\n<p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度</p>\n<p>那么<code>SHITERS</code>的部分匹配值是多少呢?相当于Q和H里面有几个元素是共存的?</p>\n<p>答,一个</p>\n<p>所以,其<code>S</code>部分匹配值是1，而其他均为0</p>\n<p>所以这张表有什么用?和部分匹配表有什么关系?</p>\n<p>回到之前的,我们会发现有些时候往后匹配时有时候后缀和前缀会相同,那么匹配值向右移动就是其部分匹配值。</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E5%B0%9D%E8%AF%95%E4%B8%8A%E6%89%8B\" class=\"headerlink\" title=\"尝试上手\"></a>尝试上手</h1>\n<h2>\n<a href=\"https://blog.cyfan.top/#%E6%9D%BF%E5%AD%90%E9%A2%98P3375\" class=\"headerlink\" title=\"板子题P3375\"></a>板子题<a href=\"https://www.luogu.com.cn/problem/P3375\" target=\"_blank\" rel=\"noopener\">P3375</a>\n</h2>\n<p>匹配这样子就是有手就行，而所谓的<code>border</code>其实就是部分匹配值<del>比较扯淡的是第一次看的时候就是没搞懂border</del></p>\n<p>扯皮点，直接搞getfail</p>\n<div class=\"hljs\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getfail</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> plen)</span></span>{    border[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">0</span>;     <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;plen;i++){        <span class=\"hljs-keyword\">int</span> j=border[i];        <span class=\"hljs-keyword\">while</span>(j&amp;&amp;p[i]!=p[j]) j=border[j];<span class=\"hljs-keyword\">if</span>(p[i]==p[j])border[i+<span class=\"hljs-number\">1</span>]=j+<span class=\"hljs-number\">1</span>;    }}</code></pre></div>\n<p>然后夹带上主代码直接冲了</p>\n<div class=\"hljs\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;bits/stdc++.h&gt;</span></span><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> M 1000000</span><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<span class=\"hljs-comment\">//脚手架</span><span class=\"hljs-keyword\">char</span> c[M],p[M];<span class=\"hljs-keyword\">int</span> border[M];<span class=\"hljs-comment\">//...getfail丢着</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>{    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%s\"</span>,c);<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">\"%s\"</span>,p);    <span class=\"hljs-keyword\">int</span> clen=<span class=\"hljs-built_in\">strlen</span>(c);<span class=\"hljs-keyword\">int</span> plen=<span class=\"hljs-built_in\">strlen</span>(p);    getfail(plen);    <span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;clen;i++){        <span class=\"hljs-keyword\">while</span>(j&amp;&amp;p[j]!=c[i]) j=border[j];        <span class=\"hljs-keyword\">if</span>(p[j]==c[i]) j++;        <span class=\"hljs-keyword\">if</span>(j==plen) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\\n\"</span>,i-plen+<span class=\"hljs-number\">2</span>);    }    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=plen;i++) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d \"</span>,border[i]);    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;}</code></pre></div>\n","link":"https://blog.cyfan.top/p/cef76c6c.html"},{"title":"Euserv正确打开优化方式","date":"2021-03-14 03:12:41","description":"\n<p>Euserv，盛名远扬【老白嫖怪了】，但是如何合理打开它，却是一个难题。这篇文章就是简单讲讲合理使用其免费的纯IPv6小鸡</p>\n<a></a><p>首先是bench测试普通小鸡</p>\n<div class=\"hljs\"><pre><code class=\"hljs sh\">---------------------------------------------------------------------- CPU Model             : AMD Phenom(tm) II X6 1055T Processor CPU Cores             : 1 CPU Frequency         : 3101.198 MHz CPU Cache             : 512 KB Total Disk            : 9.8 GB (3.4 GB Used) Total Mem             : 976 MB (334 MB Used) Total Swap            : 976 MB (0 MB Used) System uptime         : 76 days, 21 hour 6 min Load average          : 16.17, 19.45, 20.53 OS                    : CentOS Linux release 7.9.2009 (Core) Arch                  : x86_64 (64 Bit) Kernel                : 4.20.8-1.el7.elrepo.x86_64 TCP CC                : cubic Virtualization        : LXC Organization          : AS29432 TREX Regional Exchanges Oy Region                : Pirkanmaa---------------------------------------------------------------------- I/O Speed(1st run)    : 19.3 MB/s I/O Speed(2nd run)    : 28.5 MB/s I/O Speed(3rd run)    : 34.0 MB/s Average I/O speed     : 27.3 MB/s---------------------------------------------------------------------- Node Name        Upload Speed      Download Speed      Latency      Speedtest.net    288.12 Mbps       350.72 Mbps         46.84 ms</code></pre></div>\n<p>这是一张简单优化后的小鸡</p>\n<div class=\"hljs\"><pre><code class=\"hljs sh\">---------------------------------------------------------------------- CPU Model             : Intel(R) Xeon(R) CPU E3-1270 v3 @ 3.50GHz CPU Cores             : 1 CPU Frequency         : 3740.322 MHz CPU Cache             : 8192 KB Total Disk            : 9.8 GB (0.9 GB Used) Total Mem             : 976 MB (60 MB Used) Total Swap            : 976 MB (0 MB Used) System uptime         : 0 days, 0 hour 36 min Load average          : 5.06, 6.01, 7.01 OS                    : Debian GNU/Linux 10 Arch                  : x86_64 (64 Bit) Kernel                : 4.20.8-1.el7.elrepo.x86_64 TCP CC                : cubic Virtualization        : LXC Organization          : AS13335 Cloudflare, Inc. Location              : Frankfurt am Main / DE Region                : Hesse---------------------------------------------------------------------- I/O Speed(1st run)    : 71.8 MB/s I/O Speed(2nd run)    : 58.1 MB/s I/O Speed(3rd run)    : 57.3 MB/s Average I/O speed     : 62.4 MB/s---------------------------------------------------------------------- Node Name        Upload Speed      Download Speed      Latency      Speedtest.net    203.45 Mbps       105.67 Mbps         9.28 ms      Beijing    CU    71.94 Mbps        112.58 Mbps         271.97 ms    Shanghai   CU    89.92 Mbps        111.97 Mbps         245.60 ms    Guangzhou  CT    0.18 Mbps         131.79 Mbps         234.00 ms    Guangzhou  CU    103.38 Mbps       118.68 Mbps         284.22 ms    Shenzhen   CU    82.26 Mbps        115.67 Mbps         268.41 ms    Hongkong   CN    81.69 Mbps        141.33 Mbps         274.20 ms    Singapore  SG    99.51 Mbps        108.96 Mbps         330.77 ms    Tokyo      JP    104.81 Mbps       85.70 Mbps          246.56 ms   ----------------------------------------------------------------------</code></pre></div>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E5%AE%89%E8%A3%85-Debian10\" class=\"headerlink\" title=\"安装 - Debian10\"></a>安装 - Debian10</h1>\n<p>这里务必要安装Debian系统，不然后面可能会有点小问题</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615692757000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>可能要很长一段时间，完毕后<code>ServerData</code>记录ipv6地址和密码备用</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E9%93%BE%E6%8E%A5SSH\" class=\"headerlink\" title=\"链接SSH\"></a>链接SSH</h1>\n<p>由于次小鸡用的是纯ipv6,鉴于国内ipv6的部署情况您很有可能连接不上,请选择以下六种方式链接</p>\n<ul>\n<li>CloudFlareSpectrum + UcloudGlobalSSH</li>\n<li>嘿哟终端</li>\n<li>ZeroTier虚拟局域网</li>\n<li>挂ipv6代理</li>\n<li>使用另一台已安装宝塔的Euserv小鸡,用宝塔自带的终端ssh中继到另一台服务器</li>\n<li>使用ipv4+ipv6双栈vps,用ssh链接</li>\n</ul>\n<p>篇幅所限,只讲第一种</p>\n<h2>\n<a href=\"https://blog.cyfan.top/#CloudFlareSpectrum-UcloudGlobalSSH\" class=\"headerlink\" title=\"CloudFlareSpectrum + UcloudGlobalSSH\"></a>CloudFlareSpectrum + UcloudGlobalSSH</h2>\n<p><strong>这个方案比较推荐,就是需要白嫖一个CloudFlarePro</strong></p>\n<p>UcloudGlobalSSH只能支持ipv4,所以你需要一个CloudFlareSpectrum中继</p>\n<p>CloudFlareSpectrum每月5GB流量,仅SSH链接完全足够</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615692972000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693007000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693064000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693130000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>这一步之后需要注意解析你的专属ip，CloudFlareSpectrum使用的ip不是供用的。</p>\n<p>Windows命令提示符使用</p>\n<div class=\"hljs\"><pre><code class=\"hljs cmd\">nslookup abc.cyfan.top.cdn.cloudflare.<span class=\"hljs-built_in\">net</span></code></pre></div>\n<p>或者使用我的DNS over HTTPS</p>\n<div class=\"hljs\"><pre><code class=\"hljs url\">https://api.cyfan.top/ohhhdns?name=abc.cyfan.top.cdn.cloudflare.net&amp;host=true</code></pre></div>\n<p>请自己更改abc.cyfan.top这个域名。</p>\n<p>解析的ip形如<code>172.65.124.0</code>,但这个ip并不好,三网都很差,所以用UcloudGlobalSSH</p>\n<p>UcloudGlobalSSH拥有免费版一天1GB,完全足矣</p>\n<p><a href=\"https://console.ucloud.cn/upathx/globalssh\" target=\"_blank\" rel=\"noopener\">https://console.ucloud.cn/upathx/globalssh</a></p>\n<p>新建一个隧道</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693476000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>将之前解析的ip写入，区域建议香港，点击确定，生成专属域名</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693543000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693601000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>然后链接，我这里用的是XShell，其实客户端自己看喜好</p>\n<p>域名就是ucloud的专属域名，<strong>端口是UC分配给你的而不是22</strong>，922是UC给我的端口，密码是Euserv的密码，用户直接用<code>root</code></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693743000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693767000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>然后就直接链接</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1615693951000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>使用此方式链接方式如下</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">你 - 中国 &lt;=<span class=\"hljs-attribute\">40ms</span>=&gt; Ucloud - 中国香港 &lt;=<span class=\"hljs-attribute\">10ms</span>=&gt; CloudFlareSpectrum - AnyCast &lt;=Argo 横跨北半球,<span class=\"hljs-attribute\">150ms</span>=&gt; Euserv - 德国</code></pre></div>\n<p>也就是说链接直连可以与美国vps媲美</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#DNS%E8%AE%BE%E7%BD%AE-DNS64\" class=\"headerlink\" title=\"DNS设置 -DNS64\"></a>DNS设置 -DNS64</h1>\n<p>Euserv只有一个ipv6地址,没有ipv4网卡,所以只能链接纯ipv6网站</p>\n<p>使用DNS64可以强制把域名解析到ipv6地址,并且原来只有ipv4的也能通过算法解析到ipv6</p>\n<p>由于你要安装Warp,为了下载来自外网的软件,需要使用DNS64</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">nano <span class=\"hljs-regexp\">/etc/</span>resolv.conf</code></pre></div>\n<p>大概是这样的</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\"><span class=\"hljs-selector-tag\">search</span> <span class=\"hljs-selector-tag\">blue</span><span class=\"hljs-selector-class\">.kundencontroller</span><span class=\"hljs-selector-class\">.de</span><span class=\"hljs-selector-tag\">options</span> <span class=\"hljs-selector-tag\">rotate</span><span class=\"hljs-selector-tag\">nameserver</span> 2<span class=\"hljs-selector-tag\">a02</span><span class=\"hljs-selector-pseudo\">:180</span><span class=\"hljs-selector-pseudo\">:6</span><span class=\"hljs-selector-pseudo\">:5</span><span class=\"hljs-selector-pseudo\">::1c</span><span class=\"hljs-selector-tag\">nameserver</span> 2<span class=\"hljs-selector-tag\">a02</span><span class=\"hljs-selector-pseudo\">:180</span><span class=\"hljs-selector-pseudo\">:6</span><span class=\"hljs-selector-pseudo\">:5</span><span class=\"hljs-selector-pseudo\">::1e</span><span class=\"hljs-selector-tag\">nameserver</span> 2<span class=\"hljs-selector-tag\">a02</span><span class=\"hljs-selector-pseudo\">:180</span><span class=\"hljs-selector-pseudo\">:6</span><span class=\"hljs-selector-pseudo\">:5</span><span class=\"hljs-selector-pseudo\">::1d</span><span class=\"hljs-selector-tag\">nameserver</span> 2<span class=\"hljs-selector-tag\">a02</span><span class=\"hljs-selector-pseudo\">:180</span><span class=\"hljs-selector-pseudo\">:6</span><span class=\"hljs-selector-pseudo\">:5</span><span class=\"hljs-selector-pseudo\">::4</span></code></pre></div>\n<p>删除最后4行nameserver,添加</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">nameserver <span class=\"hljs-number\">2001</span>:67c:<span class=\"hljs-number\">2b0</span>::<span class=\"hljs-number\">4</span>nameserver <span class=\"hljs-number\">2001</span>:67c:<span class=\"hljs-number\">2b0</span>::<span class=\"hljs-number\">6</span></code></pre></div>\n<h1>\n<a href=\"https://blog.cyfan.top/#Warp%E5%AE%89%E8%A3%85-%E4%B8%8AIPv4%E5%9C%B0%E5%9D%80\" class=\"headerlink\" title=\"Warp安装 - 上IPv4地址\"></a>Warp安装 - 上IPv4地址</h1>\n<blockquote><p>Debian安装时若意外退出则需要相当麻烦解除锁定,所以建立一个稳定的隧道是必须的</p></blockquote>\n<p>首先安装一些必要依赖</p>\n<div class=\"hljs\"><pre><code class=\"hljs sh\">apt updateapt install curl sudo lsb-release -y</code></pre></div>\n<p>添加 back­ports 源,并安装wireguard</p>\n<div class=\"hljs\"><pre><code class=\"hljs sh\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"deb http://deb.debian.org/debian <span class=\"hljs-variable\">$(lsb_release -sc)</span>-backports main\"</span> | sudo tee /etc/apt/sources.list.d/backports.listsudo apt updatesudo apt install net-tools iproute2 openresolv dnsutils -ysudo apt install wireguard-tools --no-install-recommends</code></pre></div>\n<p>然后因为是LXC虚拟内核,无奈之下只能使用go语言编译的内核</p>\n<div class=\"hljs\"><pre><code class=\"hljs sh\">curl -fsSL git.io/wireguard-go.sh | sudo bash</code></pre></div>\n<p>安装wgcf【第三方注册器】，注册并生成配置</p>\n<div class=\"hljs\"><pre><code class=\"hljs sh\">curl -fsSL git.io/wgcf.sh | sudo bashwgcf registerwgcf generate</code></pre></div>\n<p>修改配置</p>\n<div class=\"hljs\"><pre><code class=\"hljs sh\">nano wgcf-profile.conf</code></pre></div>\n<p>内容差不多这样：</p>\n<div class=\"hljs\"><pre><code class=\"hljs sh\">[Interface]PrivateKey = xxxAddress = 172.16.0.2/32Address = fd01:5ca1:ab1e:89f5:9dfa:759c:9348:13e6/128DNS = 1.1.1.1MTU = 1280[Peer]PublicKey = xxxAllowedIPs = 0.0.0.0/0AllowedIPs = ::/0Endpoint = engage.cloudflareclient.com:2408</code></pre></div>\n<p>几个关键配置</p>\n<ul><li>第五行DNS改成</li></ul>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attr\">DNS</span> = <span class=\"hljs-number\">2606</span>:<span class=\"hljs-number\">4700</span>:<span class=\"hljs-number\">4700</span>::<span class=\"hljs-number\">1111</span></code></pre></div>\n<ul>\n<li>\n<p>删除第十行，否则Warp会托管ipv6</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attr\">AllowedIPs</span> = ::/<span class=\"hljs-number\">0</span></code></pre></div>\n</li>\n<li><p>修改第十一行为</p></li>\n</ul>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">Endpoint = [<span class=\"hljs-number\">2606</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">4700</span><span class=\"hljs-symbol\">:d0</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-symbol\">:a29f</span><span class=\"hljs-symbol\">:c001</span>]<span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">2408</span></code></pre></div>\n<p>输入以下命令</p>\n<div class=\"hljs\"><pre><code class=\"hljs sh\">sudo cp wgcf-profile.conf /etc/wireguard/wgcf.confsudo systemctl start wg-quick@wgcfsudo systemctl <span class=\"hljs-built_in\">enable</span> wg-quick@wgcf<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'precedence  ::ffff:0:0/96   100'</span> | sudo tee -a /etc/gai.conf</code></pre></div>\n<p>然后ping一下baidu：</p>\n<div class=\"hljs\"><pre><code class=\"hljs undefined\">root@srv10866:~#<span class=\"hljs-built_in\"> ping </span>baidu.com<span class=\"hljs-built_in\">PING </span>baidu.com (220.181.38.148) 56(84) bytes of data.64 bytes <span class=\"hljs-keyword\">from</span> 220.181.38.148 (220.181.38.148): <span class=\"hljs-attribute\">icmp_seq</span>=1 <span class=\"hljs-attribute\">ttl</span>=50 <span class=\"hljs-attribute\">time</span>=452 ms64 bytes <span class=\"hljs-keyword\">from</span> 220.181.38.148 (220.181.38.148): <span class=\"hljs-attribute\">icmp_seq</span>=2 <span class=\"hljs-attribute\">ttl</span>=50 <span class=\"hljs-attribute\">time</span>=300 ms64 bytes <span class=\"hljs-keyword\">from</span> 220.181.38.148 (220.181.38.148): <span class=\"hljs-attribute\">icmp_seq</span>=3 <span class=\"hljs-attribute\">ttl</span>=50 <span class=\"hljs-attribute\">time</span>=302 ms<span class=\"hljs-built_in\">..</span>.^C--- baidu.com<span class=\"hljs-built_in\"> ping </span>statistics ---26 packets transmitted, 23 received, 11.5385% packet loss, time 121msrtt min/avg/max/mdev = 297.390/307.370/451.503/30.906 ms</code></pre></div>\n<p>简单安装besttrace</p>\n<div class=\"hljs\"><pre><code class=\"hljs sh\">wget https://cdn.ipip.net/17mon/besttrace4linux.zipapt-get install zipunzip besttrace4linux.zipchmod +x besttrace</code></pre></div>\n<p>路由到CF网络都是一步到位</p>\n<div class=\"hljs\"><pre><code class=\"hljs sh\">root@srv10866:~<span class=\"hljs-comment\"># ./besttrace -q 1 1.0.0.1</span>traceroute to 1.0.0.1 (1.0.0.1), 30 hops max, 32 byte packets 1  one.one.one.one (1.0.0.1)  9.61 ms  AS13335  CLOUDFLARE.COM, apnic.netroot@srv10866:~<span class=\"hljs-comment\"># ./besttrace -q 1 cloudflare.com</span>traceroute to cloudflare.com (104.16.133.229), 30 hops max, 32 byte packets 1  104.16.133.229  13.62 ms  AS13335  CLOUDFLARE.COM, cloudflare.com</code></pre></div>\n<p>路由到谷歌，那就是穿透一层内网直接出去</p>\n<div class=\"hljs\"><pre><code class=\"hljs sh\">root@srv10866:~<span class=\"hljs-comment\"># ./besttrace -q 1 google.com</span>traceroute to google.com (142.250.186.46), 30 hops max, 32 byte packets 1  172.16.0.1  9.45 ms  *  LAN Address 2  162.158.82.1  18.34 ms  AS13335  Germany, Hesse, Frankfurt, cloudflare.com 3  162.158.84.5  10.08 ms  AS13335  Germany, Hesse, Frankfurt, cloudflare.com 4  108.170.251.129  28.06 ms  AS15169  United States, google.com 5  172.253.71.89  11.58 ms  AS15169  United States, google.com 6  fra24s04-in-f14.1e100.net (142.250.186.46)  12.48 ms  AS15169  Germany, Hesse, Frankfurt, google.com</code></pre></div>\n<p>路由到百度就很有意思，从HKG出去进入移动CMI北上北京</p>\n<blockquote><p>去年10月移动在欧洲和cf做的对等互联,因为遵循路由链最短原则,电信和联通在欧洲没有比这个更短的,到联通是cf-gtt-联通,到电信是cf-level3-电信,到移动是cf-移动,所以会走移动<br>金句From – <a href=\"https://www.puresys.net/\" target=\"_blank\" rel=\"noopener\">CLAM</a></p></blockquote>\n<div class=\"hljs\"><pre><code class=\"hljs sh\">root@srv10866:~<span class=\"hljs-comment\"># ./besttrace -q 1 baidu.com</span>traceroute to baidu.com (39.156.69.79), 30 hops max, 32 byte packets 1  172.16.0.1  9.50 ms  *  LAN Address 2  162.158.82.1  10.37 ms  AS13335  Germany, Hesse, Frankfurt, cloudflare.com 3  223.119.65.37  20.01 ms  AS58453  China, Hong Kong, ChinaMobile 4  * 5  221.183.46.250  257.40 ms  AS9808  China, ChinaMobile 6  221.176.27.253  200.99 ms  AS9808  China, ChinaMobile 7  111.24.2.241  202.99 ms  AS9808  China, ChinaMobile 8  * 9  39.156.27.1  203.69 ms  AS9808  China, Beijing, ChinaMobile10  *11  *12  *13  *14  39.156.69.79  259.35 ms  AS9808  China, Beijing, ChinaMobile</code></pre></div>\n<p>Speedtest</p>\n<div class=\"hljs\"><pre><code class=\"hljs sh\">curl -fsSL git.io/speedtest-cli.sh | sudo bashspeedtest</code></pre></div>\n<p>返回</p>\n<div class=\"hljs\"><pre><code class=\"hljs sh\">   Speedtest by Ookla     Server: RETN - Frankfurt (id = 31120)        ISP: Cloudflare Warp    Latency:     9.88 ms   (0.11 ms jitter)   Download:   112.57 Mbps (data used: 101.0 MB)                                    Upload:   127.19 Mbps (data used: 115.5 MB)                               Packet Loss:     0.0% Result URL: https://www.speedtest.net/result/c/556afff6-e56a-4d53-844b-fe88b562ceb8</code></pre></div>\n<p>速度不快,但是起码上ipv4了</p>\n","link":"https://blog.cyfan.top/p/d788bdf3.html"},{"title":"失败的光速叛逃！CloudFlarePage初体验","date":"2021-02-20 01:24:00","description":"\n<p>众所周知，CloudFlare曾开放CloudFlarePage内测资格申请，如今我获得了资格，免费享受边缘部署岂不美哉！可万万没想到，简单的迁移过程会出现如此问题</p>\n<a></a><p>据我所知，使用CloudFlare做hexo无非以下两种：</p>\n<ul>\n<li>GithubPage+CloudFlareCDN</li>\n<li>CloudFlareWorkerKV+ClouFlareWorkerSite</li>\n</ul>\n<p>CloudFlare早先时候支持WorkerSite，当时KV照实没有免费，我也不想为了<code>100ms</code>的回源耗时而花费金钱。不过后来KV在一定额度上免费了，打开WorkerSite的文档，第一步wrangler直接把我劝退。</p>\n<p>笑话，国内使用wrangler，那还不如CloudFlare+GithubPage。</p>\n<p><a href=\"https://blog.skk.moe/post/deploy-blog-to-cf-workers-site/\" target=\"_blank\" rel=\"noopener\">苏卡卡大佬写的一篇文章</a>讲述了自己部署WorkerSite的经历，<a href=\"https://blog.ichr.me/post/cf-workers-site-deploy/\" target=\"_blank\" rel=\"noopener\">ChrAlpha’s Blog</a>也曾提到过迁移的过程。不过我懒<img src=\"https://npm.elemecdn.com/chenyfan-oss@1.1.11/62.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt>，我觉得<code>100ms</code>回源不算什么，赔个Worker还是有点亏。</p>\n<p>2020年11月份，偶然得知CFPage<a href=\"https://www.cloudflare.com/zh-cn/pages-jamstack-platform-beta-sign-up/\" target=\"_blank\" rel=\"noopener\">正在公开招聘Pagebeta计划</a>，抱着试试看的心理，我简单写了些就交了上去。凭借着对CloudFlare发布新产品小心翼翼的态度，我揣摩估计很难申请到。果不其然，年都过了，连封邮件都没通知我。</p>\n<p>2021年2月20日，我先日常翻了遍邮件，0。正准备继续开发HexoPlusPlus，登陆CloudFlare，却发现右边多了个新玩意：</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613786871000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-oss@1.1.11/156.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>不愧是我，我一眼就看出来我的CFPage申请到了。</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E8%BF%81%E7%A7%BB\" class=\"headerlink\" title=\"迁移\"></a>迁移</h1>\n<p>由于我的博客源码在Github上，而CFPage只能从Github上获取源码。<br>我面向中国大陆CDN有一部分用的也是CloudFlare，通过BNXB第三方接入。<br>因为之前用的就是GithubAction的集成部署，所以<code>package.json</code>已经配置完成了。</p>\n<p>那么我看起来确实是最佳的接入选择。</p>\n<div class=\"note note-warning\"><p>非常操蛋的是，我无法删除已经添加的CloudFlarePage域名，所以我没有办法重新演示我如何安装，下面的截图是删除时的错误：<br><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613787919000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt><br><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613787960000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p></div>\n<p>首先，进去，点击<code>创建项目</code>选择博客的github存储库，获得GithubAccess权限后跳转到这：</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613788198000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>勾选需要接入的项目</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613788329000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<ul><li>构建设置 - 框架预设</li></ul>\n<p>由于之前吃过Vercel的亏，不想选Hexo，但是抱着试试看的心态，还是选择了内置的hexo。</p>\n<p>选择之后，后面的构建命令和构建输出也直接填好了，保存并部署？</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613789246000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<blockquote><p>因为本博客使用了neat而不是gulp插件压缩html<del>管他呢反正丢CI</del>，所以构建时间会比较长。</p></blockquote>\n<p>修改CNAME记录和TXT记录，分别去BNXB修改CNMAE和DNSPOD【NS所在处】修改TXT记录</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613790247000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613790482000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>就好了？就好了。</p>\n<p><span class=\"heimu\">这是我最快的迁移速度</span></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613789961000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>NetWork选项卡里出<code>x-server: Cloudflare Pages</code>说明迁移完毕。</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C\" class=\"headerlink\" title=\"使用体验\"></a>使用体验</h1>\n<p>简洁，加载速度快，这是我第一个感受。</p>\n<p>用GithubAction老是卡在同一个界面不会动，要手动刷新一下才能出来，而且加载的东西贼多，我这台破笔记本有点卡。</p>\n<p>CloudFlarePage则轻巧的多，并且部署状况很快就能体现出来。</p>\n<p>无缝切换，这是我的第二个体验。</p>\n<p>以前换CI换CDN的时候，非得断掉先然后才能切换回来，现在两步走之后，直接在dns平台修改无缝迁移，体验良好，总耗时不超过10分钟。</p>\n<p>鉴于CloudFlare在国内的连接情况，电信这一条线我还是切回vercel【也是0回源】，其他的走CloudFlarePage</p>\n<p>平台还是beta，这是第三个感受。</p>\n<p>我删不掉已经添加的域名，这是我最纳闷的一点。</p>\n<p>然后我不想让cfpage检测我的<code>gh-pages</code>分支，因为GithubAction还有存在的必要，但是CFpage每每还是检测pages分支，然后扔出部署失败，提示错误。</p>\n<p>这两个问题<a href=\"https://community.cloudflare.com/t/cloudflarepagebug-i-cannot-delete-my-site/246093\" target=\"_blank\" rel=\"noopener\">我已经丢论坛里了</a>，目前还未回复</p>\n<p>至于快多少，因为没有免费版本Argo做对比，也没有大量数据做对比，<strong>目前</strong>无法得出结论。</p>\n<p>真的要说快多少，因为大部分静态资源切jsd上，所有经过cf的只有一个单html，至少我在国内大环境下，我还没体会出100ms能快多少(´இ皿இ｀)</p>\n<p>另外CloudFlarePage用的证书很奇怪，可能是为了CNAME兼容性，不用自己自家的证书，反而用Let’s Encrypt，鉴于OSCP在国内阻断，ios用户可能会出现首次访问白屏，这一点我有点担心。</p>\n<p>最好的一点莫过于完全贴合HexoPlusPlus了，以后我就有充分的理由宣传HPP了<img src=\"https://npm.elemecdn.com/chenyfan-oss@1.1.11/320.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E9%A2%9D%E5%BA%A6\" class=\"headerlink\" title=\"额度\"></a>额度</h1>\n<ul><li>每月构建次数：500次</li></ul>\n<p>【用了HPP，构建次数再多也不够500/mo，这一点我还是放心的，再说我常年咕咕咕】</p>\n<ul>\n<li><p>自定义域名：10个 【我也没这么多域名】</p></li>\n<li><p>文件：2w个【绝对用不完】</p></li>\n<li><p>总大小：25MB【图片啥的都扔图床，其实也就5MB】</p></li>\n<li><p>带宽：无限制【！！！】</p></li>\n</ul>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E7%84%B6%E5%90%8E%E6%88%91%E5%88%87%E5%9B%9E%E6%9D%A5%E4%BA%86\" class=\"headerlink\" title=\"然后我切回来了\"></a>然后我切回来了</h1>\n<p>高高兴兴的搞完了CFPage部署，<del>水了这篇文章</del>去吃饭。吃完饭后回来一看谷歌统计，好家伙404的怎么这么多。</p>\n<p>还好之前的GithubPage没有删掉，去bnxb赶紧切了回来。</p>\n<p><del>完了我也经历了和Sukka大佬一样的问题</del></p>\n<p>问题很容易定位，所有的404来自cfpage而非vercel。</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613795675000.png\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>首先是Vercel，开代理的情况下国外访问均正确解析至vercel，可以在<code>x-vercel</code>头里看出来</p>\n<p>地址是<code>https://blog.cyfan.top/p/52382e42.html</code>，相应代码是<code>200</code></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613795874000.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>关闭代理，将自动选择CloudFlareCDN+GithubPage，可以从<code>x-github-request-id</code>看出</p>\n<p>地址是<code>https://blog.cyfan.top/p/52382e42.html</code>，相应代码是<code>200</code></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613796163000.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>然后是有问题的CFPage，可以在<code>x-server</code>头里看出来</p>\n<p>地址是<code>https://blog-9una.pages.dev/p/52382e42.html</code>，相应代码是<code>308</code><strong>跳转</strong>，跳向<code>https://blog-9una.pages.dev/p/52382e42</code>，<strong>CFPage会把末尾.html抹掉</strong></p>\n<p>抹掉就罢了,结果在vercel这边又出问题</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613796374000.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>但是最奇葩的是,githubpage是允许不带html裸访</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-cdn@2.0.0/img/hpp_upload/1613796456000.jpg\" srcset=\"https://npm.elemecdn.com/chenyfan-blog@1.0.1/themes/fluid/source/img/loading.gif\" alt></p>\n<p>这就是整个经过,CFPage必须抹掉后缀,GithubPage保持无所谓,Vercel必须不能抹掉</p>\n<h1>\n<a href=\"https://blog.cyfan.top/#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h1>\n<p>先从自己入手，CFPage和vercel不能共留，干掉vercel？好主意，毕竟国内访问CF并无大碍，但是有个大问题梗在面前，评论怎么办，之前的收录怎么办，首页链接不一致怎么办？</p>\n<p>我又不想抛弃CFpage，于是试图和Sukka大佬针对中文解码一样来个拯救计划，结果发现，CFPage不开源……</p>\n<p>后来仔细翻了一遍<a href=\"https://developers.cloudflare.com/pages/platform/serving-pages#route-matching\" target=\"_blank\" rel=\"noopener\">文档</a>才发现，这样是有意为之，故意删掉后缀名。</p>\n<p>的，切回Github+CFCDN，这一早上的折腾白费了( ง ᵒ̌皿ᵒ̌)ง⁼³₌₃</p>\n","link":"https://blog.cyfan.top/p/363f2ff1.html"},{"title":"图床的千层套路","date":"2020-09-13 06:57:39","description":"\n<blockquote>\n<p>转载自<a href=\"https://blog.cyfan.top/p/eb490c73.html\">CYF的博客</a></p>\n</blockquote>\n<blockquote>\n<p>博客最近在细心打磨终于上95分了，其中我认为图片功劳不可没。<img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/cUEQrVYGFiDjqhy.jpg\" alt=\"\"></p>\n</blockquote>\n<p>2020年8月9日<a href=\"https://github.com/jsdelivr/jsdelivr/pull/18247/files\">Jsdelivr发布了一次使用政策：Create Acceptable Use Policy</a>，其中第4条Prohibited Use引起了众多议论：</p>\n<pre><code class=\"language-markdown\">4. Prohibited Use\n\nThe following behavior is prohibited:\n\n 1. Hosting or accessing content that:\n     - contains malware or harmful code in any form,\n     - violates proprietary rights of others,\n     - is sexually explicit,\n     - is potentially illegal in the EU or the USA.\n\n 2. Abusing the service and its resources, or using jsDelivr as a general-purpose\n    file or media hosting service. This includes, for example:\n     - running an image hosting website and using jsDelivr as a storage for all\n       uploaded images,\n     - hosting videos, file backups, or other files in large quantities.\n\n    We recognize that there are legitimate projects that consist of a large number\n    of files, and these are not considered abuse. For example: icons packs, apps,\n    or games with a large number of assets.\n\n</code></pre>\n<p>其中<code>running an image hosting website and using jsDelivr as a storage for all uploaded images</code> 这一句相当的有歧义，要多少的图片才能算是图站？博客里面图片放里面算吗？上传的图片怎样才不行？<img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/TlAGjm6IvJSMVpq.jpg\" alt=\"\"></p>\n<p>反观网上流传的白嫖Github做图床，基本点进去都是<code>https://cdn.jsdelivr.net/gh/</code> 这样子的图床，这种行为，我不敢妄加评论。但是，jsdelivr诞生的意义似乎并不是为了图床而生的，这种行为也很难判断成滥用。<img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5896ece29a8e0.jpg\" alt=\"\"></p>\n<p>使用政策发布之后，一时间，QQ群、v2ex、知乎上立刻就炸了锅。很多人猜测jsdelivr是不是滥用过度而禁止将其作为图床？免费图床的白嫖日子要结束了吗？更多的人，是在哭诉和询问那里还有像jsd一样优秀的<strong>图床</strong>可以白嫖，微博炸了，那里还有免费图床啊？</p>\n<p>实际上，我一般采用的是<code>BackBlaze+CloudFlare</code> 但是自从八月底移动开始改道，从原先优秀的CMI绕路LAX后，国内CloudFlare访问质量再次暴跌，这不得不使我将博客迁至Vercel。好在八月份我有幸申请到了<code>doegdoge图床</code>使用权限，获得了国内较高速的图床.</p>\n<p>但是，对于哪些没有没有图床的人来说，免费图床真的这么难以获得吗？</p>\n<p>不好意思，<strong>免费图床非常多</strong>，只是你不会用而已，这篇文章，就是拯救面前陷入图床危机的你【当然是面向小白，大佬也可以在底下给我提意见鸭】。<img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/stick_56.png\" alt=\"\"></p>\n<h1>公益图床</h1>\n<h2>sm.ms</h2>\n<p><a href=\"https://sm.ms/\">https://sm.ms</a></p>\n<p>推荐程度：★</p>\n<p>首先推荐的是这个图床，loli.net域名经典重现。三年前此图床域名还有备案采用的是国内CDN，可惜后来因为滥用吊销备案号而被迫迁移国外，用的是CloudFlare。实际使用效果面向国内确实不太好，建议备用。</p>\n<p>你不需要注册，拖拽直接上传，只要不违反大陆和香港法律，他就能永久保留你的图片</p>\n<p><img src=\"https://i.loli.net/2020/09/12/OxvnMBwd3VA8uyD.jpg\" alt=\"\"></p>\n<p>可搭配PicGo</p>\n<h2>Imgur</h2>\n<p><a href=\"https://imgur.com/\">https://imgur.com</a></p>\n<p>推荐程度：★★</p>\n<p>国外一家牛逼的图片托管服务商，你可以选择注册或不注册，同样的，拖拽上传，永久保留，其SLA有着相当高的保证。</p>\n<p>然而很可惜的是，这种网站很早就在国内被<strong>DNS域名污染</strong>，也就意味着访客无法正常加载你的图片。这也就是被打为两颗星的原因。<img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/%E4%B8%8D%E8%AF%B4%E8%AF%9D.png\" alt=\"\"></p>\n<p>当然，你也可以通过<a href=\"https://blog.mk1.io/#%E5%9B%BE%E5%83%8F%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1\">#图像缓存服务</a> 从而实现国内访问。</p>\n<p>可搭配PicGo【需注册】</p>\n<h2>去不图床</h2>\n<p><a href=\"https://7bu.top/\">https://7bu.top/</a></p>\n<p>推荐程度：★★★★</p>\n<p>由<a href=\"https://dusays.com/241/\">杜老师</a>提供的个人公益图床，存储于阿里和腾讯的COS，官方保证SLA&gt;=99%，是一个不错的选择，当然，7bu毕竟是个人维护的图床，能不能永久撑下去还是个问题，我也没有做过深度评测，无法表明其可用性。</p>\n<p>可搭配PicGo。</p>\n<pre><code class=\"language-yml\">接口地址：https://7bu.top/api/upload\npost参数：image\n回调json：data.url\n</code></pre>\n<p><a href=\"https://7bu.top/index/api.html\">更准确的API文档</a></p>\n<p><img src=\"https://7.dusays.com/2020/09/13/aa555748a9f38.jpg\" alt=\"\"></p>\n<blockquote>\n<p><del>而且，就在我上传测试图片的时候，明明已经表明图片已经上传，打开却发现COS提示404，这一点我不得陷入思考，个人维持的公益项目真的能保证SLA吗？<img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/%E4%BE%BF%E4%BE%BF.png\" alt=\"\"></del></p>\n</blockquote>\n<blockquote>\n<p>昨天上传的时候撞上服务器维修了，很抱歉做出了不够恰当的评价.7bu采用的是全国腾讯云CDN加速，国内访问速度十分优良。然而请注意，7bu刚开始建立的目的并不是面向全球【仅面对中国大陆游客】，这导致其大陆以外基本解析至国内西藏腾讯，访问效果并不好。并且，这是通过腾讯云的鉴黄，可能会存在误杀行为。具体使用请个人斟酌【不过作为开发环境还是可行的】。</p>\n</blockquote>\n<h1>白嫖的</h1>\n<h2>阿里图床</h2>\n<p><del>推荐程度：★★★★</del></p>\n<p><del>我个人搭建的API：<a href=\"https://picbed.cyfan.top/\">https://picbed.cyfan.top</a> 不保证上传SLA<img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5c53ce897ab55.jpg\" alt=\"\"></del></p>\n<p><del>由于小鸡联通国内网络不太好，很有可能无法正常上传，<a href=\"https://github.com/ChenYFan-Tester/Alibaba_pic\">原项目已经开源</a> ，你完全可以通过在国内的机子或者是本地搭建以获得更佳体验。</del></p>\n<p><del>如果上传成功了，图片将会托管于阿里云的CDN，无论是速度还是延迟都相当的优秀。</del></p>\n<p><del>官方大厂，下载SLA有保障。</del></p>\n<p><del>可搭配PicGo。</del></p>\n<pre><code class=\"language-yml\">接口地址：https://picbed.cyfan.top/update.php\npost参数：file\n回调json：data.url\n</code></pre>\n<p><strong>已失效，切勿使用</strong></p>\n<h2>DogeDoge图床</h2>\n<p>推荐程度：★★★★★</p>\n<p><img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20200912192303.jpg\" alt=\"TEST\"></p>\n<p>其实很早就看到<a href=\"https://v2ex.com/t/659652\">V2EX的那篇征文了</a>：</p>\n<p><img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20200912190301.png?q=45\" alt=\"\"></p>\n<p>可是当时我不够优秀啊虽然现在同样不优秀，博客也没满一年啊，于是白嫖的心态搁浅了。<img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5896e8a408253.jpg\" alt=\"\"></p>\n<p>后来突然看到Jalen的博客也用了DogeDoge图床，这才突然意识到原来我已经满一年了。于是抱着试试看的心态向doge官方邮箱发送了邮件，结果真过了。。。</p>\n<p>dogedoge拥有着国内相当不错的CDN，国内访问飞快，但是国外的访问质量的确不如人意。【反正此博客面向中国大陆】</p>\n<p>而且，DogeDoge拥有着很良心的处理参数：</p>\n<pre><code class=\"language-yml\">w：宽\nh：高\nmode：模式 - crop 裁剪、clip 缩略\nfmt：格式 - jpg、png、webp（原图为 gif，且没有 frame 参数时，不做任何裁切、缩略处理）\nframe：1 - EOF帧，默认为 1 （对动画有效）\nq：压缩质量 - 1 - 100（默认 90 ）\nrect：指定位置裁剪 - top,left,w,h（若与 w / h 参数同时存在，则 会在 rect 裁剪过后，继续按照 w / h 的要求缩略）\npos：（配合 w / h ）裁剪位置 - top-left、top、top-right、left、center、right、bottom-left、bottom、bottom-right，默认为center\npos 还有一个特殊的值 auto，该值目前为 alpha 状态，可以根据图片重点来进行 pos 的位置取舍。\n</code></pre>\n<p>话说回来，DogeDoge也可以搭配PicGo使用。</p>\n<pre><code class=\"language-yml\">接口地址：https://www.dogedoge.com/tools/upload/{Your_Token}\npost参数：file\n回调json：data.o_url\n</code></pre>\n<p>当然，现在的Doge图床还是处于免费的试用期【Creater】，不过好在试用期过后价格也比较合理，一般的tester也足够使用，目前看来SLA还是不错的。</p>\n<p>不过，申请不到dogedoge图床也没关系，看下去你就会发现，白嫖的路千千万万，何必执着于一条。<img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/stick_34.png\" alt=\"\"></p>\n<p><img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20200912205753.png?q=45\" alt=\"\"></p>\n<h2>BackBlaze</h2>\n<p>推荐程度：★★★</p>\n<p>具体可以看看<a href=\"https://blog.mk1.io/p/ce240368.html\">这篇文章</a></p>\n<h2>千奇百怪的</h2>\n<h2>Github+JSDelivr</h2>\n<p>正如我所说的，这种组合已经被广大博主所采纳，并且网上教程已经泛滥了，在这里不再阐述。</p>\n<h2>npm+JSDelivr&amp;&amp;Zhimg&amp;&amp;bdstatic&amp;&amp;自定义镜像</h2>\n<p>推荐程度：★★★★★</p>\n<p>为什么很多文章都没有提到用npm做图床？我想其中很大的原因是，白嫖jsd做图床的，很多都是小白【或者不愿花时间在于此的大佬】，同样的，这些文章面向的都是这些人，毕竟，以拖拽方式上传的Github和命令行方式上传，我想，大都数人会选择前者吧。</p>\n<p>可是，你们没有想到的是，github文件镜像【github.com.cnpmjs.org是站点镜像】只有jsd一个，npm镜像可远远不止这一个啊！</p>\n<p>让我们看看分别镜像在jsd、zhimg、bdstatic的文件怎么样：</p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-oss@0.0.1/1.jpg\" alt=\"\"></p>\n<p><img src=\"https://npm.elemecdn.com/chenyfan-oss@0.0.1/2.jpg\" alt=\"\"></p>\n<p><img src=\"https://code.bdstatic.com/npm/chenyfan-oss@0.0.1/3.jpg\" alt=\"\"></p>\n<p>【unpkg镜像用的是CloudFlare，国内加速效果不好，暂时不写】</p>\n<p>jsd就不必多说了，国内拥有强劲的网宿节点支撑【虽然以前出现过网宿下游投毒】，速度丝滑无比，国外也有强劲的CloudFlare上岗，可谓国内外两不误。而且，jsd对于npm的package单文件没有大小限制，也就是说泡个视频也不是问题。</p>\n<p>zhimg是知乎的unpkg镜像，也是一个不错的选择【阿里CDN】，知乎官方也未对此做出限制，日常使用是可以的。</p>\n<p>bdstatic是百度的内用npm镜像，速度也很好【百度CDN】，但是请注意，bdstatic作为内用cdn，其拉取频率较慢，经常出现无法及时更新。</p>\n<p>啊哈？不会上传？<br><img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/stick_31.png\" alt=\"\">去<a href=\"https://npmjs.org/\">npm</a><br>\n官网注册个账号去,然后先：</p>\n<pre><code class=\"language-bash\">npm login\n</code></pre>\n<p>接着：</p>\n<pre><code class=\"language-bash\">npm init\nnpm publish\n</code></pre>\n<p>请注意，如果你之前用过淘宝镜像，那么请先手动切回源：</p>\n<pre><code class=\"language-bash\">npm config set registry https://registry.npmjs.org\n</code></pre>\n<p>每一次发布图片后，你可以将原来的图片删除，更改<code>package.json</code> 版本号【向上增加】,然后<code>npm publish</code>即可</p>\n<p>这个似乎可以搭配picgo，不过好像没这个插件，写起来也麻烦。。。</p>\n<p>unpkg的国内镜像其实远远不止这些，包括七牛、饿了么、腾讯都有，不过这个就要自己找了。<img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/7DgSoyqwtYBxchE.jpg\" alt=\"\"></p>\n<p>一些推荐的npm【or unpkg镜像】：</p>\n<pre><code class=\"language-markdown\">【jsd出品，网宿国内节点】https://npm.elemecdn.com/\n【知乎出品，网宿国内节点】https://npm.elemecdn.com/\n【百度出品，网宿国内节点】https://code.bdstatic.com/npm/\n【饿了么出品，网宿国内节点，回源是Unpkg，建议用这个】https://npm.elemecdn.com/\n【饿了么出品，网宿国内节点，回源是JSdelivr，貌似可以用github，但是我用的时候大多无法正常回源，只能获取几个已缓存的热门库】https://shadow.elemecdn.com/npm/\n【怎么都是网宿的】\n</code></pre>\n<p>或者说，你还可以自建unpkg镜像。</p>\n<p>啊，你说你没有服务器反向代理unpkg？</p>\n<p>其实，七牛的对象存储，腾讯的COS和阿里的OSS都是支持镜像回源的鸭！</p>\n<p>七牛http流量每月免费10GB，腾讯的国内免费60GB6个月，作为自用完全足够了！</p>\n<p><img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/L6LVJL_1ZUM2ISQ%5D10R%7B3HF.png?q=45\" alt=\"\"></p>\n<h2>ipfs</h2>\n<p>我曾经<a href=\"https://blog.mk1.io/2020/04/07/IPFS-CloudFlare-ServerLessWebPage/\">写过关于ipfs的讲解</a> ,作为一个去中心化的存储系统拿来做公开图床其实挺不错的。</p>\n<p>我个人搭建的ipfs镜像【托管于CloudFlareWorkers】：<a href=\"https://ipfs.cyfan.top/\">https://ipfs.cyfan.top</a> <img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5c53d78c3f4a5.jpg\" alt=\"\"></p>\n<p>我个人搭建的ipfs上传API：<a href=\"https://ipfsupload.cyfan.top/\">https://ipfsupload.cyfan.top</a></p>\n<p>基于Vercel+CloudFlare~~【我也不知道worker为什么死活上传不上去】~~</p>\n<pre><code class=\"language-yml\">接口地址：https://ipfsupload.cyfan.top/api/v0/add?pin=true\npost参数：file\n回调json：Hash\n</code></pre>\n<blockquote>\n<p>此处Hash获得的是文件的Qmhash，你还要依托ipfs镜像，如<a href=\"https://ipfs.cyfan.top/ipfs/%7BQmHash%7D\">https://ipfs.cyfan.top/ipfs/{QmHash}</a></p>\n</blockquote>\n<p><img src=\"https://ipfs.cyfan.top/ipfs/QmctXmCyxkN72nzoHMAgw1geR7u9XvK7sLo72W4bDZsCm2\" alt=\"\"></p>\n<p>顺便收录一些ipfs网关【可访问】：</p>\n<pre><code class=\"language-html\">【北京 阿里云】https://hashnews.k1ic.com/\n【香港 阿里云】https://ipfs.jbb.one/\n【美国 DigitalOcean】https://ipfs.telos.miami/\n【Amazon】https://ipfs.oceanprotocol.com/\n</code></pre>\n<p>你可以在<a href=\"https://ipfs.github.io/public-gateway-checker/\">https://ipfs.github.io/public-gateway-checker/</a>找到更多</p>\n<h1>图片缓存服务</h1>\n<p>正如<a href=\"https://blog.mk1.io/#%23Imgur\">##Imgur</a>所说的，imgur在国内已经无法访问了，但是，图片缓存服务可以啊！</p>\n<p><img src=\"https://search.pstatic.net/common/?src=https://i.imgur.com/Usdr0IT.jpg\" alt=\"\"></p>\n<p>收集了一些图片缓存服务：</p>\n<pre><code class=\"language-http\">【国内网宿节点，只能加载特定图床图片如imgur】https://search.pstatic.net/common/?src=\n【Akamai节点，没有使用限制】https://imageproxy.pimg.tw/resize?url=\n【CloudFlare节点】https://images.weserv.nl/?url=\n【CloudFlare节点】https://pic1.xuehuaimg.com/proxy/\n</code></pre>\n<h1>PicGo的搭配使用</h1>\n<p>PicGo默认已经集成了部分图床，其拖拽上传、自动复制剪贴板实在赢得了无数人的心。但是，对于一些冷门的图床支持似乎就不太好，这时候你需要用自定义web图床实现这一切：</p>\n<p><img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20200912205225.png?q=45\" alt=\"\"></p>\n<p>我在上方介绍的图床如果支持web端上传，基本上就会写一个post请求，你可以依葫芦画瓢填写进去</p>\n<p><img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20200912205449.png?q=45\" alt=\"\"></p>\n<p>这样子你就可以实现较为丝滑的上传图片了：</p>\n<p><img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20200912210009.jpg?q=45\" alt=\"\"></p>\n<p><img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/20200912210420.gif?q=45\" alt=\"\"></p>\n<p>【为了压缩方便删除了部分帧】</p>\n<h1>后言</h1>\n<p>实际上最保险的莫过于使用各大厂商的对象存储，当然这笔钱不大好使。<br>\n你也可以用自己的VPS搭建Chevereto，当然前提是你有VPS<img src=\"https://rmt.dogedoge.com/fetch/hi-c-oss/storage/5c53de1a4d14d.gif\" alt=\"\"></p>\n","link":"https://blog.mk1.io/posts/hey-picbed"}]